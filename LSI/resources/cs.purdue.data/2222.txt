<DOC>
<DOCNO> http://www.cs.purdue.edu/homes/dec/eca.cont.html </DOCNO>
<HTML> <HEAD> <TITLE> nsd contents </TITLE> </HEAD> <BODY> <CENTER> <H2> Table of Contents For <BR><BR> Essentials Of<BR><BR> Computer Architecture <BR><BR> </H2> </CENTER> <UL><UL> <BR><H3> Preface &nbsp;&nbsp;xxi</H3> <BR> <H3>Chapter 1 &nbsp; Introduction And Overview &nbsp;&nbsp; 1</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>1.1 <TD ALIGN=left COLSPAN=2> The Importance Of Architecture &nbsp;&nbsp 1 <TR> <TD ALIGN=left>1.2 <TD ALIGN=left COLSPAN=2> Learning The Essentials &nbsp;&nbsp 1 <TR> <TD ALIGN=left>1.3 <TD ALIGN=left COLSPAN=2> Organization Of The Text &nbsp;&nbsp 2 <TR> <TD ALIGN=left>1.4 <TD ALIGN=left COLSPAN=2> What We Will Omit &nbsp;&nbsp 3 <TR> <TD ALIGN=left>1.5 <TD ALIGN=left COLSPAN=2> Terminology: Architecture And Design &nbsp;&nbsp 3 <TR> <TD ALIGN=left>1.6 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 3 </TABLE> <BR> <BR><H3> PART I &nbsp;&nbsp; Basics &nbsp;&nbsp; 5</H3> <BR> <H3>Chapter 2 &nbsp; Fundamentals Of Digital Logic &nbsp;&nbsp; 7</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>2.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 7 <TR> <TD ALIGN=left>2.2 <TD ALIGN=left COLSPAN=2> Electrical Terminology: Voltage And Current &nbsp;&nbsp 7 <TR> <TD ALIGN=left>2.3 <TD ALIGN=left COLSPAN=2> The Transistor &nbsp;&nbsp 8 <TR> <TD ALIGN=left>2.4 <TD ALIGN=left COLSPAN=2> Logic Gates &nbsp;&nbsp 9 <TR> <TD ALIGN=left>2.5 <TD ALIGN=left COLSPAN=2> Symbols Used For Gates &nbsp;&nbsp 10 <TR> <TD ALIGN=left>2.6 <TD ALIGN=left COLSPAN=2> Construction Of Gates From Transistors &nbsp;&nbsp 11 <TR> <TD ALIGN=left>2.7 <TD ALIGN=left COLSPAN=2> Example Interconnection Of Gates &nbsp;&nbsp 12 <TR> <TD ALIGN=left>2.8 <TD ALIGN=left COLSPAN=2> Multiple Gates Per Integrated Circuit &nbsp;&nbsp 14 <TR> <TD ALIGN=left>2.9 <TD ALIGN=left COLSPAN=2> The Need For More Than Combinatorial Circuits &nbsp;&nbsp 15 <TR> <TD ALIGN=left>2.10 <TD ALIGN=left COLSPAN=2> Circuits That Maintain State &nbsp;&nbsp 15 <TR> <TD ALIGN=left>2.11 <TD ALIGN=left COLSPAN=2> Transition Diagrams &nbsp;&nbsp 16 <TR> <TD ALIGN=left>2.12 <TD ALIGN=left COLSPAN=2> Binary Counters &nbsp;&nbsp 17 <TR> <TD ALIGN=left>2.13 <TD ALIGN=left COLSPAN=2> Clocks And Sequences &nbsp;&nbsp 18 <TR> <TD ALIGN=left>2.14 <TD ALIGN=left COLSPAN=2> The Important Concept Of Feedback &nbsp;&nbsp 20 <TR> <TD ALIGN=left>2.15 <TD ALIGN=left COLSPAN=2> Starting A Sequence &nbsp;&nbsp 22 <TR> <TD ALIGN=left>2.16 <TD ALIGN=left COLSPAN=2> Iteration In Software Vs. Replication In Hardware &nbsp;&nbsp 22 <TR> <TD ALIGN=left>2.17 <TD ALIGN=left COLSPAN=2> Gate And Chip Minimization &nbsp;&nbsp 23 <TR> <TD ALIGN=left>2.18 <TD ALIGN=left COLSPAN=2> Using Spare Gates &nbsp;&nbsp 24 <TR> <TD ALIGN=left>2.19 <TD ALIGN=left COLSPAN=2> Power Distribution And Heat Dissipation &nbsp;&nbsp 24 <TR> <TD ALIGN=left>2.20 <TD ALIGN=left COLSPAN=2> Timing &nbsp;&nbsp 25 <TR> <TD ALIGN=left>2.21 <TD ALIGN=left COLSPAN=2> Physical Size And Process Technologies &nbsp;&nbsp 26 <TR> <TD ALIGN=left>2.22 <TD ALIGN=left COLSPAN=2> Circuit Boards And Layers &nbsp;&nbsp 27 <TR> <TD ALIGN=left>2.23 <TD ALIGN=left COLSPAN=2> Levels Of Abstraction &nbsp;&nbsp 27 <TR> <TD ALIGN=left>2.24 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 28 </TABLE> <BR> <BR> <H3>Chapter 3 &nbsp; Data And Program Representation &nbsp;&nbsp; 29</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>3.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 29 <TR> <TD ALIGN=left>3.2 <TD ALIGN=left COLSPAN=2> Digital Logic And Abstraction &nbsp;&nbsp 29 <TR> <TD ALIGN=left>3.3 <TD ALIGN=left COLSPAN=2> Bits And Bytes &nbsp;&nbsp 30 <TR> <TD ALIGN=left>3.4 <TD ALIGN=left COLSPAN=2> Byte Size And Possible Values &nbsp;&nbsp 30 <TR> <TD ALIGN=left>3.5 <TD ALIGN=left COLSPAN=2> Binary Arithmetic &nbsp;&nbsp 31 <TR> <TD ALIGN=left>3.6 <TD ALIGN=left COLSPAN=2> Hexadecimal Notation &nbsp;&nbsp 32 <TR> <TD ALIGN=left>3.7 <TD ALIGN=left COLSPAN=2> Notation For Hexadecimal And Binary Constants &nbsp;&nbsp 33 <TR> <TD ALIGN=left>3.8 <TD ALIGN=left COLSPAN=2> Character Sets &nbsp;&nbsp 34 <TR> <TD ALIGN=left>3.9 <TD ALIGN=left COLSPAN=2> Unicode &nbsp;&nbsp 35 <TR> <TD ALIGN=left>3.10 <TD ALIGN=left COLSPAN=2> Unsigned Integers, Overflow, And Underflow &nbsp;&nbsp 35 <TR> <TD ALIGN=left>3.11 <TD ALIGN=left COLSPAN=2> Numbering Bits And Bytes &nbsp;&nbsp 36 <TR> <TD ALIGN=left>3.12 <TD ALIGN=left COLSPAN=2> Signed Integers &nbsp;&nbsp 37 <TR> <TD ALIGN=left>3.13 <TD ALIGN=left COLSPAN=2> An Example Of Two's Complement Numbers &nbsp;&nbsp 38 <TR> <TD ALIGN=left>3.14 <TD ALIGN=left COLSPAN=2> Sign Extension &nbsp;&nbsp 39 <TR> <TD ALIGN=left>3.15 <TD ALIGN=left COLSPAN=2> Floating Point &nbsp;&nbsp 40 <TR> <TD ALIGN=left>3.16 <TD ALIGN=left COLSPAN=2> Special Values &nbsp;&nbsp 42 <TR> <TD ALIGN=left>3.17 <TD ALIGN=left COLSPAN=2> Range Of IEEE Floating Point Values &nbsp;&nbsp 42 <TR> <TD ALIGN=left>3.18 <TD ALIGN=left COLSPAN=2> Data Aggregates &nbsp;&nbsp 42 <TR> <TD ALIGN=left>3.19 <TD ALIGN=left COLSPAN=2> Program Representation &nbsp;&nbsp 43 <TR> <TD ALIGN=left>3.20 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 43 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 44<BR> </TABLE> <BR> <BR><H3> PART II &nbsp;&nbsp; Processors &nbsp;&nbsp; 45</H3> <BR> <H3>Chapter 4 &nbsp; The Variety Of Processors And Computational Engines &nbsp;&nbsp; 47</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>4.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 47 <TR> <TD ALIGN=left>4.2 <TD ALIGN=left COLSPAN=2> Von Neumann Architecture &nbsp;&nbsp 47 <TR> <TD ALIGN=left>4.3 <TD ALIGN=left COLSPAN=2> Definition Of A Processor &nbsp;&nbsp 48 <TR> <TD ALIGN=left>4.4 <TD ALIGN=left COLSPAN=2> The Range Of Processors &nbsp;&nbsp 48 <TR> <TD ALIGN=left>4.5 <TD ALIGN=left COLSPAN=2> Hierarchical Structure And Computational Engines &nbsp;&nbsp 49 <TR> <TD ALIGN=left>4.6 <TD ALIGN=left COLSPAN=2> Structure Of A Conventional Processor &nbsp;&nbsp 51 <TR> <TD ALIGN=left>4.7 <TD ALIGN=left COLSPAN=2> Definition Of An Arithmetic Logic Unit (ALU) &nbsp;&nbsp 52 <TR> <TD ALIGN=left>4.8 <TD ALIGN=left COLSPAN=2> Processor Categories And Roles &nbsp;&nbsp 52 <TR> <TD ALIGN=left>4.9 <TD ALIGN=left COLSPAN=2> Processor Technologies &nbsp;&nbsp 54 <TR> <TD ALIGN=left>4.10 <TD ALIGN=left COLSPAN=2> Stored Programs &nbsp;&nbsp 54 <TR> <TD ALIGN=left>4.11 <TD ALIGN=left COLSPAN=2> The Fetch-Execute Cycle &nbsp;&nbsp 55 <TR> <TD ALIGN=left>4.12 <TD ALIGN=left COLSPAN=2> Clock Rate And Instruction Rate &nbsp;&nbsp 56 <TR> <TD ALIGN=left>4.13 <TD ALIGN=left COLSPAN=2> Control: Getting Started And Stopping &nbsp;&nbsp 57 <TR> <TD ALIGN=left>4.14 <TD ALIGN=left COLSPAN=2> Starting The Fetch-Execute Cycle &nbsp;&nbsp 57 <TR> <TD ALIGN=left>4.15 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 58 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 58<BR> </TABLE> <BR> <BR> <H3>Chapter 5 &nbsp; Processor Types And Instruction Sets &nbsp;&nbsp; 61</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>5.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 61 <TR> <TD ALIGN=left>5.2 <TD ALIGN=left COLSPAN=2> Mathematical Power, Convenience, And Cost &nbsp;&nbsp 61 <TR> <TD ALIGN=left>5.3 <TD ALIGN=left COLSPAN=2> Instruction Set And Representation &nbsp;&nbsp 62 <TR> <TD ALIGN=left>5.4 <TD ALIGN=left COLSPAN=2> Opcodes, Operands, And Results &nbsp;&nbsp 63 <TR> <TD ALIGN=left>5.5 <TD ALIGN=left COLSPAN=2> Typical Instruction Format &nbsp;&nbsp 63 <TR> <TD ALIGN=left>5.6 <TD ALIGN=left COLSPAN=2> Variable-Length Vs. Fixed-Length Instructions &nbsp;&nbsp 63 <TR> <TD ALIGN=left>5.7 <TD ALIGN=left COLSPAN=2> General-Purpose Registers &nbsp;&nbsp 64 <TR> <TD ALIGN=left>5.8 <TD ALIGN=left COLSPAN=2> Floating Point Registers And Register Identification &nbsp;&nbsp 65 <TR> <TD ALIGN=left>5.9 <TD ALIGN=left COLSPAN=2> Programming With Registers &nbsp;&nbsp 65 <TR> <TD ALIGN=left>5.10 <TD ALIGN=left COLSPAN=2> Register Banks &nbsp;&nbsp 66 <TR> <TD ALIGN=left>5.11 <TD ALIGN=left COLSPAN=2> Complex And Reduced Instruction Sets &nbsp;&nbsp 67 <TR> <TD ALIGN=left>5.12 <TD ALIGN=left COLSPAN=2> RISC Design And The Execution Pipeline &nbsp;&nbsp 68 <TR> <TD ALIGN=left>5.13 <TD ALIGN=left COLSPAN=2> Pipelines And Instruction Stalls &nbsp;&nbsp 69 <TR> <TD ALIGN=left>5.14 <TD ALIGN=left COLSPAN=2> Other Causes Of Pipeline Stalls &nbsp;&nbsp 71 <TR> <TD ALIGN=left>5.15 <TD ALIGN=left COLSPAN=2> Consequences For Programmers &nbsp;&nbsp 71 <TR> <TD ALIGN=left>5.16 <TD ALIGN=left COLSPAN=2> Programming, Stalls, And No-Op Instructions &nbsp;&nbsp 72 <TR> <TD ALIGN=left>5.17 <TD ALIGN=left COLSPAN=2> Forwarding &nbsp;&nbsp 72 <TR> <TD ALIGN=left>5.18 <TD ALIGN=left COLSPAN=2> Types Of Operations &nbsp;&nbsp 73 <TR> <TD ALIGN=left>5.19 <TD ALIGN=left COLSPAN=2> Program Counter, Fetch-Execute, And Branching &nbsp;&nbsp 73 <TR> <TD ALIGN=left>5.20 <TD ALIGN=left COLSPAN=2> Subroutine Calls, Arguments, And Register Windows &nbsp;&nbsp 75 <TR> <TD ALIGN=left>5.21 <TD ALIGN=left COLSPAN=2> An Example Instruction Set &nbsp;&nbsp 76 <TR> <TD ALIGN=left>5.22 <TD ALIGN=left COLSPAN=2> Minimalistic Instruction Set &nbsp;&nbsp 78 <TR> <TD ALIGN=left>5.23 <TD ALIGN=left COLSPAN=2> The Principle Of Orthogonality &nbsp;&nbsp 79 <TR> <TD ALIGN=left>5.24 <TD ALIGN=left COLSPAN=2> Condition Codes And Conditional Branching &nbsp;&nbsp 80 <TR> <TD ALIGN=left>5.25 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 80 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 81<BR> </TABLE> <BR> <BR> <H3>Chapter 6 &nbsp; Operand Addressing And Instruction Representation &nbsp;&nbsp; 83</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>6.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 83 <TR> <TD ALIGN=left>6.2 <TD ALIGN=left COLSPAN=2> Zero, One, Two, Or Three Address Designs &nbsp;&nbsp 83 <TR> <TD ALIGN=left>6.3 <TD ALIGN=left COLSPAN=2> Zero Operands Per Instruction &nbsp;&nbsp 84 <TR> <TD ALIGN=left>6.4 <TD ALIGN=left COLSPAN=2> One Operand Per Instruction &nbsp;&nbsp 85 <TR> <TD ALIGN=left>6.5 <TD ALIGN=left COLSPAN=2> Two Operands Per Instruction &nbsp;&nbsp 85 <TR> <TD ALIGN=left>6.6 <TD ALIGN=left COLSPAN=2> Three Operands Per Instruction &nbsp;&nbsp 86 <TR> <TD ALIGN=left>6.7 <TD ALIGN=left COLSPAN=2> Operand Sources And Immediate Values &nbsp;&nbsp 86 <TR> <TD ALIGN=left>6.8 <TD ALIGN=left COLSPAN=2> The Von Neumann Bottleneck &nbsp;&nbsp 87 <TR> <TD ALIGN=left>6.9 <TD ALIGN=left COLSPAN=2> Explicit And Implicit Operand Encoding &nbsp;&nbsp 88 <TR> <TD ALIGN=left> <TD ALIGN=left>6.9.1 <TD ALIGN=left> Implicit Operand Encoding &nbsp;&nbsp 88 <TR> <TD ALIGN=left> <TD ALIGN=left>6.9.2 <TD ALIGN=left> Explicit Operand Encoding &nbsp;&nbsp 88 <TR> <TD ALIGN=left>6.10 <TD ALIGN=left COLSPAN=2> Operands That Combine Multiple Values &nbsp;&nbsp 89 <TR> <TD ALIGN=left>6.11 <TD ALIGN=left COLSPAN=2> Tradeoffs In The Choice Of Operands &nbsp;&nbsp 90 <TR> <TD ALIGN=left>6.12 <TD ALIGN=left COLSPAN=2> Values In Memory And Indirect Reference &nbsp;&nbsp 91 <TR> <TD ALIGN=left>6.13 <TD ALIGN=left COLSPAN=2> Operand Addressing Modes &nbsp;&nbsp 92 <TR> <TD ALIGN=left>6.14 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 93 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 93<BR> </TABLE> <BR> <BR> <H3>Chapter 7 &nbsp; CPUs: Microcode, Protection, And Processor Modes &nbsp;&nbsp; 95</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>7.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 95 <TR> <TD ALIGN=left>7.2 <TD ALIGN=left COLSPAN=2> A Central Processor &nbsp;&nbsp 95 <TR> <TD ALIGN=left>7.3 <TD ALIGN=left COLSPAN=2> CPU Complexity &nbsp;&nbsp 96 <TR> <TD ALIGN=left>7.4 <TD ALIGN=left COLSPAN=2> Modes Of Execution &nbsp;&nbsp 97 <TR> <TD ALIGN=left>7.5 <TD ALIGN=left COLSPAN=2> Backward Compatibility &nbsp;&nbsp 97 <TR> <TD ALIGN=left>7.6 <TD ALIGN=left COLSPAN=2> Changing Modes &nbsp;&nbsp 98 <TR> <TD ALIGN=left>7.7 <TD ALIGN=left COLSPAN=2> Privilege And Protection &nbsp;&nbsp 99 <TR> <TD ALIGN=left>7.8 <TD ALIGN=left COLSPAN=2> Multiple Levels Of Protection &nbsp;&nbsp 99 <TR> <TD ALIGN=left>7.9 <TD ALIGN=left COLSPAN=2> Microcoded Instructions &nbsp;&nbsp 100 <TR> <TD ALIGN=left>7.10 <TD ALIGN=left COLSPAN=2> Microcode Variations &nbsp;&nbsp 102 <TR> <TD ALIGN=left>7.11 <TD ALIGN=left COLSPAN=2> The Advantage Of Microcode &nbsp;&nbsp 102 <TR> <TD ALIGN=left>7.12 <TD ALIGN=left COLSPAN=2> Making Microcode Visible To Programmers &nbsp;&nbsp 103 <TR> <TD ALIGN=left>7.13 <TD ALIGN=left COLSPAN=2> Vertical Microcode &nbsp;&nbsp 103 <TR> <TD ALIGN=left>7.14 <TD ALIGN=left COLSPAN=2> Horizontal Microcode &nbsp;&nbsp 104 <TR> <TD ALIGN=left>7.15 <TD ALIGN=left COLSPAN=2> Example Horizontal Microcode &nbsp;&nbsp 105 <TR> <TD ALIGN=left>7.16 <TD ALIGN=left COLSPAN=2> A Horizontal Microcode Example &nbsp;&nbsp 107 <TR> <TD ALIGN=left>7.17 <TD ALIGN=left COLSPAN=2> Operations That Require Multiple Cycles &nbsp;&nbsp 108 <TR> <TD ALIGN=left>7.18 <TD ALIGN=left COLSPAN=2> Horizontal Microcode And Parallel Execution &nbsp;&nbsp 109 <TR> <TD ALIGN=left>7.19 <TD ALIGN=left COLSPAN=2> Look-Ahead And High Performance Execution &nbsp;&nbsp 110 <TR> <TD ALIGN=left>7.20 <TD ALIGN=left COLSPAN=2> Parallelism And Execution Order &nbsp;&nbsp 111 <TR> <TD ALIGN=left>7.21 <TD ALIGN=left COLSPAN=2> Out-Of-Order Instruction Execution &nbsp;&nbsp 111 <TR> <TD ALIGN=left>7.22 <TD ALIGN=left COLSPAN=2> Conditional Branches And Branch Prediction &nbsp;&nbsp 112 <TR> <TD ALIGN=left>7.23 <TD ALIGN=left COLSPAN=2> Consequences For Programmers &nbsp;&nbsp 113 <TR> <TD ALIGN=left>7.24 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 113 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 114<BR> </TABLE> <BR> <BR> <H3>Chapter 8 &nbsp; Assembly Languages And Programming Paradigm &nbsp;&nbsp; 115</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>8.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 115 <TR> <TD ALIGN=left>8.2 <TD ALIGN=left COLSPAN=2> Characteristics Of A High-level Programming Language &nbsp;&nbsp 115 <TR> <TD ALIGN=left>8.3 <TD ALIGN=left COLSPAN=2> Characteristics Of A Low-Level Programming Language &nbsp;&nbsp 116 <TR> <TD ALIGN=left>8.4 <TD ALIGN=left COLSPAN=2> Assembly Language &nbsp;&nbsp 117 <TR> <TD ALIGN=left>8.5 <TD ALIGN=left COLSPAN=2> Assembly Language Syntax And Opcodes &nbsp;&nbsp 118 <TR> <TD ALIGN=left> <TD ALIGN=left>8.5.1 <TD ALIGN=left> Statement Format &nbsp;&nbsp 118 <TR> <TD ALIGN=left> <TD ALIGN=left>8.5.2 <TD ALIGN=left> Opcode Names &nbsp;&nbsp 118 <TR> <TD ALIGN=left> <TD ALIGN=left>8.5.3 <TD ALIGN=left> Commenting Conventions &nbsp;&nbsp 119 <TR> <TD ALIGN=left>8.6 <TD ALIGN=left COLSPAN=2> Operand Order &nbsp;&nbsp 120 <TR> <TD ALIGN=left>8.7 <TD ALIGN=left COLSPAN=2> Register Names &nbsp;&nbsp 121 <TR> <TD ALIGN=left>8.8 <TD ALIGN=left COLSPAN=2> Operand Types &nbsp;&nbsp 122 <TR> <TD ALIGN=left>8.9 <TD ALIGN=left COLSPAN=2> Assembly Language Programming Paradigm And Idioms &nbsp;&nbsp 122 <TR> <TD ALIGN=left>8.10 <TD ALIGN=left COLSPAN=2> Assembly Code For Conditional Execution &nbsp;&nbsp 123 <TR> <TD ALIGN=left>8.11 <TD ALIGN=left COLSPAN=2> Assembly Code For A Conditional Alternative &nbsp;&nbsp 124 <TR> <TD ALIGN=left>8.12 <TD ALIGN=left COLSPAN=2> Assembly Code For Definite Iteration &nbsp;&nbsp 124 <TR> <TD ALIGN=left>8.13 <TD ALIGN=left COLSPAN=2> Assembly Code For Indefinite Iteration &nbsp;&nbsp 125 <TR> <TD ALIGN=left>8.14 <TD ALIGN=left COLSPAN=2> Assembly Code For Procedure Invocation &nbsp;&nbsp 125 <TR> <TD ALIGN=left>8.15 <TD ALIGN=left COLSPAN=2> Assembly Code For Parameterized Procedure Invocation &nbsp;&nbsp 126 <TR> <TD ALIGN=left>8.16 <TD ALIGN=left COLSPAN=2> Consequence For Programmers &nbsp;&nbsp 127 <TR> <TD ALIGN=left>8.17 <TD ALIGN=left COLSPAN=2> Assembly Code For Function Invocation &nbsp;&nbsp 128 <TR> <TD ALIGN=left>8.18 <TD ALIGN=left COLSPAN=2> Interaction Between Assembly And High-Level Languages &nbsp;&nbsp 128 <TR> <TD ALIGN=left>8.19 <TD ALIGN=left COLSPAN=2> Assembly Code For Variables And Storage &nbsp;&nbsp 129 <TR> <TD ALIGN=left>8.20 <TD ALIGN=left COLSPAN=2> Two-Pass Assembler &nbsp;&nbsp 130 <TR> <TD ALIGN=left>8.21 <TD ALIGN=left COLSPAN=2> Assembly Language Macros &nbsp;&nbsp 131 <TR> <TD ALIGN=left>8.22 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 134 </TABLE> <BR> <BR><H3> PART III &nbsp;&nbsp; Memories &nbsp;&nbsp; 135</H3> <BR> <H3>Chapter 9 &nbsp; Memory And Storage &nbsp;&nbsp; 137</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>9.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 137 <TR> <TD ALIGN=left>9.2 <TD ALIGN=left COLSPAN=2> Definition &nbsp;&nbsp 137 <TR> <TD ALIGN=left>9.3 <TD ALIGN=left COLSPAN=2> The Key Aspects Of Memory &nbsp;&nbsp 138 <TR> <TD ALIGN=left>9.4 <TD ALIGN=left COLSPAN=2> Characteristics Of Memory Technologies &nbsp;&nbsp 138 <TR> <TD ALIGN=left> <TD ALIGN=left>9.4.1 <TD ALIGN=left> Memory Volatility &nbsp;&nbsp 138 <TR> <TD ALIGN=left> <TD ALIGN=left>9.4.2 <TD ALIGN=left> Memory Access Paradigm &nbsp;&nbsp 139 <TR> <TD ALIGN=left> <TD ALIGN=left>9.4.3 <TD ALIGN=left> Permanence Of Values &nbsp;&nbsp 139 <TR> <TD ALIGN=left> <TD ALIGN=left>9.4.4 <TD ALIGN=left> Primary And Secondary Memory &nbsp;&nbsp 139 <TR> <TD ALIGN=left>9.5 <TD ALIGN=left COLSPAN=2> The Important Concept Of A Memory Hierarchy &nbsp;&nbsp 140 <TR> <TD ALIGN=left>9.6 <TD ALIGN=left COLSPAN=2> Instruction And Data Store &nbsp;&nbsp 140 <TR> <TD ALIGN=left>9.7 <TD ALIGN=left COLSPAN=2> The Fetch-Store Paradigm &nbsp;&nbsp 141 <TR> <TD ALIGN=left>9.8 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 141 </TABLE> <BR> <BR> <H3>Chapter 10 &nbsp; Physical Memory And Physical Addressing &nbsp;&nbsp; 143</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>10.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 143 <TR> <TD ALIGN=left>10.2 <TD ALIGN=left COLSPAN=2> Characteristics Of Computer Memory &nbsp;&nbsp 143 <TR> <TD ALIGN=left>10.3 <TD ALIGN=left COLSPAN=2> Static And Dynamic RAM Technologies &nbsp;&nbsp 144 <TR> <TD ALIGN=left>10.4 <TD ALIGN=left COLSPAN=2> Measures Of Memory Technology &nbsp;&nbsp 145 <TR> <TD ALIGN=left>10.5 <TD ALIGN=left COLSPAN=2> Density &nbsp;&nbsp 146 <TR> <TD ALIGN=left>10.6 <TD ALIGN=left COLSPAN=2> Separation Of Read And Write Performance &nbsp;&nbsp 146 <TR> <TD ALIGN=left>10.7 <TD ALIGN=left COLSPAN=2> Latency And Memory Controllers &nbsp;&nbsp 146 <TR> <TD ALIGN=left>10.8 <TD ALIGN=left COLSPAN=2> Synchronized Memory Technologies &nbsp;&nbsp 147 <TR> <TD ALIGN=left>10.9 <TD ALIGN=left COLSPAN=2> Multiple Data Rate Memory Technologies &nbsp;&nbsp 148 <TR> <TD ALIGN=left>10.10 <TD ALIGN=left COLSPAN=2> Examples Of Memory Technologies &nbsp;&nbsp 148 <TR> <TD ALIGN=left>10.11 <TD ALIGN=left COLSPAN=2> Memory Organization &nbsp;&nbsp 148 <TR> <TD ALIGN=left>10.12 <TD ALIGN=left COLSPAN=2> Memory Access And Memory Bus &nbsp;&nbsp 149 <TR> <TD ALIGN=left>10.13 <TD ALIGN=left COLSPAN=2> Memory Transfer Size &nbsp;&nbsp 150 <TR> <TD ALIGN=left>10.14 <TD ALIGN=left COLSPAN=2> Physical Addresses And Words &nbsp;&nbsp 150 <TR> <TD ALIGN=left>10.15 <TD ALIGN=left COLSPAN=2> Physical Memory Operations &nbsp;&nbsp 150 <TR> <TD ALIGN=left>10.16 <TD ALIGN=left COLSPAN=2> Word Size And Other Data Types &nbsp;&nbsp 151 <TR> <TD ALIGN=left>10.17 <TD ALIGN=left COLSPAN=2> An Extreme Case: Byte Addressing &nbsp;&nbsp 151 <TR> <TD ALIGN=left>10.18 <TD ALIGN=left COLSPAN=2> Byte Addressing With Word Transfers &nbsp;&nbsp 152 <TR> <TD ALIGN=left>10.19 <TD ALIGN=left COLSPAN=2> Using Powers Of Two &nbsp;&nbsp 153 <TR> <TD ALIGN=left>10.20 <TD ALIGN=left COLSPAN=2> Byte Alignment And Programming &nbsp;&nbsp 154 <TR> <TD ALIGN=left>10.21 <TD ALIGN=left COLSPAN=2> Memory Size And Address Space &nbsp;&nbsp 154 <TR> <TD ALIGN=left>10.22 <TD ALIGN=left COLSPAN=2> Programming With Word Addressing &nbsp;&nbsp 155 <TR> <TD ALIGN=left>10.23 <TD ALIGN=left COLSPAN=2> Measures Of Memory Size &nbsp;&nbsp 155 <TR> <TD ALIGN=left>10.24 <TD ALIGN=left COLSPAN=2> Pointers And Data Structures &nbsp;&nbsp 156 <TR> <TD ALIGN=left>10.25 <TD ALIGN=left COLSPAN=2> A Memory Dump &nbsp;&nbsp 156 <TR> <TD ALIGN=left>10.26 <TD ALIGN=left COLSPAN=2> Indirection And Indirect Operands &nbsp;&nbsp 158 <TR> <TD ALIGN=left>10.27 <TD ALIGN=left COLSPAN=2> Memory Banks And Interleaving &nbsp;&nbsp 158 <TR> <TD ALIGN=left>10.28 <TD ALIGN=left COLSPAN=2> Content Addressable Memory &nbsp;&nbsp 159 <TR> <TD ALIGN=left>10.29 <TD ALIGN=left COLSPAN=2> Ternary CAM &nbsp;&nbsp 160 <TR> <TD ALIGN=left>10.30 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 160 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 161<BR> </TABLE> <BR> <BR> <H3>Chapter 11 &nbsp; Virtual Memory Technologies And Virtual Addressing &nbsp;&nbsp; 163</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>11.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 163 <TR> <TD ALIGN=left>11.2 <TD ALIGN=left COLSPAN=2> Definition &nbsp;&nbsp 163 <TR> <TD ALIGN=left>11.3 <TD ALIGN=left COLSPAN=2> A Virtual Example: Byte Addressing &nbsp;&nbsp 164 <TR> <TD ALIGN=left>11.4 <TD ALIGN=left COLSPAN=2> Virtual Memory Terminology &nbsp;&nbsp 164 <TR> <TD ALIGN=left>11.5 <TD ALIGN=left COLSPAN=2> An Interface To Multiple Physical Memory Systems &nbsp;&nbsp 164 <TR> <TD ALIGN=left>11.6 <TD ALIGN=left COLSPAN=2> Address Translation Or Address Mapping &nbsp;&nbsp 166 <TR> <TD ALIGN=left>11.7 <TD ALIGN=left COLSPAN=2> Avoiding Arithmetic Calculation &nbsp;&nbsp 167 <TR> <TD ALIGN=left>11.8 <TD ALIGN=left COLSPAN=2> Discontiguous Address Spaces &nbsp;&nbsp 168 <TR> <TD ALIGN=left>11.9 <TD ALIGN=left COLSPAN=2> Other Memory Organizations &nbsp;&nbsp 169 <TR> <TD ALIGN=left>11.10 <TD ALIGN=left COLSPAN=2> Motivation For Virtual Memory &nbsp;&nbsp 169 <TR> <TD ALIGN=left>11.11 <TD ALIGN=left COLSPAN=2> Multiple Virtual Spaces And Multiprogramming &nbsp;&nbsp 170 <TR> <TD ALIGN=left>11.12 <TD ALIGN=left COLSPAN=2> Multiple Levels Of Virtualization &nbsp;&nbsp 171 <TR> <TD ALIGN=left>11.13 <TD ALIGN=left COLSPAN=2> Creating Virtual Spaces Dynamically &nbsp;&nbsp 171 <TR> <TD ALIGN=left>11.14 <TD ALIGN=left COLSPAN=2> Base-Bound Registers &nbsp;&nbsp 172 <TR> <TD ALIGN=left>11.15 <TD ALIGN=left COLSPAN=2> Changing The Virtual Space &nbsp;&nbsp 172 <TR> <TD ALIGN=left>11.16 <TD ALIGN=left COLSPAN=2> Virtual Memory, Base-Bound, And Protection &nbsp;&nbsp 173 <TR> <TD ALIGN=left>11.17 <TD ALIGN=left COLSPAN=2> Segmentation &nbsp;&nbsp 174 <TR> <TD ALIGN=left>11.18 <TD ALIGN=left COLSPAN=2> Demand Paging &nbsp;&nbsp 175 <TR> <TD ALIGN=left>11.19 <TD ALIGN=left COLSPAN=2> Hardware And Software For Demand Paging &nbsp;&nbsp 175 <TR> <TD ALIGN=left>11.20 <TD ALIGN=left COLSPAN=2> Page Replacement &nbsp;&nbsp 176 <TR> <TD ALIGN=left>11.21 <TD ALIGN=left COLSPAN=2> Paging Terminology And Data Structures &nbsp;&nbsp 176 <TR> <TD ALIGN=left>11.22 <TD ALIGN=left COLSPAN=2> Address Translation In A Paging System &nbsp;&nbsp 177 <TR> <TD ALIGN=left>11.23 <TD ALIGN=left COLSPAN=2> Using Powers Of Two &nbsp;&nbsp 178 <TR> <TD ALIGN=left>11.24 <TD ALIGN=left COLSPAN=2> Presence, Use, And Modified Bits &nbsp;&nbsp 179 <TR> <TD ALIGN=left>11.25 <TD ALIGN=left COLSPAN=2> Page Table Storage &nbsp;&nbsp 180 <TR> <TD ALIGN=left>11.26 <TD ALIGN=left COLSPAN=2> Paging Efficiency And A Translation Lookaside Buffer &nbsp;&nbsp 181 <TR> <TD ALIGN=left>11.27 <TD ALIGN=left COLSPAN=2> Consequences For Programmers &nbsp;&nbsp 182 <TR> <TD ALIGN=left>11.28 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 183 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 183<BR> </TABLE> <BR> <BR> <H3>Chapter 12 &nbsp; Caches And Caching &nbsp;&nbsp; 185</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>12.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 185 <TR> <TD ALIGN=left>12.2 <TD ALIGN=left COLSPAN=2> Definition &nbsp;&nbsp 185 <TR> <TD ALIGN=left>12.3 <TD ALIGN=left COLSPAN=2> Characteristics Of A Cache &nbsp;&nbsp 186 <TR> <TD ALIGN=left>12.4 <TD ALIGN=left COLSPAN=2> The Importance Of Caching &nbsp;&nbsp 187 <TR> <TD ALIGN=left>12.5 <TD ALIGN=left COLSPAN=2> Examples Of Caching &nbsp;&nbsp 188 <TR> <TD ALIGN=left>12.6 <TD ALIGN=left COLSPAN=2> Cache Terminology &nbsp;&nbsp 188 <TR> <TD ALIGN=left>12.7 <TD ALIGN=left COLSPAN=2> Best And Worst Case Cache Performance &nbsp;&nbsp 189 <TR> <TD ALIGN=left>12.8 <TD ALIGN=left COLSPAN=2> Cache Performance On A Typical Sequence &nbsp;&nbsp 190 <TR> <TD ALIGN=left>12.9 <TD ALIGN=left COLSPAN=2> Cache Replacement Policy &nbsp;&nbsp 190 <TR> <TD ALIGN=left>12.10 <TD ALIGN=left COLSPAN=2> LRU Replacement &nbsp;&nbsp 191 <TR> <TD ALIGN=left>12.11 <TD ALIGN=left COLSPAN=2> Multi-level Cache Hierarchy &nbsp;&nbsp 191 <TR> <TD ALIGN=left>12.12 <TD ALIGN=left COLSPAN=2> Preloading Caches &nbsp;&nbsp 192 <TR> <TD ALIGN=left>12.13 <TD ALIGN=left COLSPAN=2> Caches Used With Memory &nbsp;&nbsp 192 <TR> <TD ALIGN=left>12.14 <TD ALIGN=left COLSPAN=2> TLB As A Cache &nbsp;&nbsp 193 <TR> <TD ALIGN=left>12.15 <TD ALIGN=left COLSPAN=2> Demand Paging As A Form Of Caching &nbsp;&nbsp 193 <TR> <TD ALIGN=left>12.16 <TD ALIGN=left COLSPAN=2> Physical Memory Cache &nbsp;&nbsp 194 <TR> <TD ALIGN=left>12.17 <TD ALIGN=left COLSPAN=2> Write Through And Write Back &nbsp;&nbsp 194 <TR> <TD ALIGN=left>12.18 <TD ALIGN=left COLSPAN=2> Cache Coherence &nbsp;&nbsp 195 <TR> <TD ALIGN=left>12.19 <TD ALIGN=left COLSPAN=2> L1, L2, and L3 Caches &nbsp;&nbsp 196 <TR> <TD ALIGN=left>12.20 <TD ALIGN=left COLSPAN=2> Sizes Of L1, L2, And L3 Caches &nbsp;&nbsp 197 <TR> <TD ALIGN=left>12.21 <TD ALIGN=left COLSPAN=2> Instruction And Data Caches &nbsp;&nbsp 197 <TR> <TD ALIGN=left>12.22 <TD ALIGN=left COLSPAN=2> Virtual Memory Caching And A Cache Flush &nbsp;&nbsp 198 <TR> <TD ALIGN=left>12.23 <TD ALIGN=left COLSPAN=2> Implementation Of Memory Caching &nbsp;&nbsp 199 <TR> <TD ALIGN=left>12.24 <TD ALIGN=left COLSPAN=2> Direct Mapping Memory Cache &nbsp;&nbsp 200 <TR> <TD ALIGN=left>12.25 <TD ALIGN=left COLSPAN=2> Using Powers Of Two For Efficiency &nbsp;&nbsp 201 <TR> <TD ALIGN=left>12.26 <TD ALIGN=left COLSPAN=2> Set Associative Memory Cache &nbsp;&nbsp 202 <TR> <TD ALIGN=left>12.27 <TD ALIGN=left COLSPAN=2> Consequences For Programmers &nbsp;&nbsp 203 <TR> <TD ALIGN=left>12.28 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 204 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 204<BR> </TABLE> <BR> <BR><H3> PART IV &nbsp;&nbsp; I/O &nbsp;&nbsp; 205</H3> <BR> <H3>Chapter 13 &nbsp; Input|/|Output Concepts And Terminology &nbsp;&nbsp; 207</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>13.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 207 <TR> <TD ALIGN=left>13.2 <TD ALIGN=left COLSPAN=2> Input And Output Devices &nbsp;&nbsp 207 <TR> <TD ALIGN=left>13.3 <TD ALIGN=left COLSPAN=2> Control Of An External Device &nbsp;&nbsp 208 <TR> <TD ALIGN=left>13.4 <TD ALIGN=left COLSPAN=2> Data Transfer &nbsp;&nbsp 209 <TR> <TD ALIGN=left>13.5 <TD ALIGN=left COLSPAN=2> Serial And Parallel Data Transfers &nbsp;&nbsp 209 <TR> <TD ALIGN=left>13.6 <TD ALIGN=left COLSPAN=2> Self-Clocking Data &nbsp;&nbsp 210 <TR> <TD ALIGN=left>13.7 <TD ALIGN=left COLSPAN=2> Full-Duplex And Half-Duplex Interaction &nbsp;&nbsp 210 <TR> <TD ALIGN=left>13.8 <TD ALIGN=left COLSPAN=2> Interface Latency And Throughput &nbsp;&nbsp 211 <TR> <TD ALIGN=left>13.9 <TD ALIGN=left COLSPAN=2> The Fundamental Idea Of Multiplexing &nbsp;&nbsp 211 <TR> <TD ALIGN=left>13.10 <TD ALIGN=left COLSPAN=2> Multiple Devices Per External Interface &nbsp;&nbsp 212 <TR> <TD ALIGN=left>13.11 <TD ALIGN=left COLSPAN=2> A Processor's View Of I^/^O &nbsp;&nbsp 213 <TR> <TD ALIGN=left>13.12 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 213 </TABLE> <BR> <BR> <H3>Chapter 14 &nbsp; Buses And Bus Architectures &nbsp;&nbsp; 215</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>14.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 215 <TR> <TD ALIGN=left>14.2 <TD ALIGN=left COLSPAN=2> Definition Of A Bus &nbsp;&nbsp 215 <TR> <TD ALIGN=left>14.3 <TD ALIGN=left COLSPAN=2> Processors, I^/^O Devices, And Buses &nbsp;&nbsp 216 <TR> <TD ALIGN=left>14.4 <TD ALIGN=left COLSPAN=2> Proprietary And Standardized Buses &nbsp;&nbsp 216 <TR> <TD ALIGN=left>14.5 <TD ALIGN=left COLSPAN=2> Shared Buses And An Access Protocol &nbsp;&nbsp 217 <TR> <TD ALIGN=left>14.6 <TD ALIGN=left COLSPAN=2> Multiple Buses &nbsp;&nbsp 217 <TR> <TD ALIGN=left>14.7 <TD ALIGN=left COLSPAN=2> A Parallel, Passive Mechanism &nbsp;&nbsp 217 <TR> <TD ALIGN=left>14.8 <TD ALIGN=left COLSPAN=2> Physical Connections &nbsp;&nbsp 217 <TR> <TD ALIGN=left>14.9 <TD ALIGN=left COLSPAN=2> Bus Interface &nbsp;&nbsp 218 <TR> <TD ALIGN=left>14.10 <TD ALIGN=left COLSPAN=2> Address, Control, And Data Lines &nbsp;&nbsp 219 <TR> <TD ALIGN=left>14.11 <TD ALIGN=left COLSPAN=2> The Fetch-Store Paradigm &nbsp;&nbsp 220 <TR> <TD ALIGN=left>14.12 <TD ALIGN=left COLSPAN=2> Fetch-Store Over A Bus &nbsp;&nbsp 220 <TR> <TD ALIGN=left>14.13 <TD ALIGN=left COLSPAN=2> The Width Of A Bus &nbsp;&nbsp 220 <TR> <TD ALIGN=left>14.14 <TD ALIGN=left COLSPAN=2> Multiplexing &nbsp;&nbsp 221 <TR> <TD ALIGN=left>14.15 <TD ALIGN=left COLSPAN=2> Bus Width And Size Of Data Items &nbsp;&nbsp 222 <TR> <TD ALIGN=left>14.16 <TD ALIGN=left COLSPAN=2> Bus Address Space &nbsp;&nbsp 223 <TR> <TD ALIGN=left>14.17 <TD ALIGN=left COLSPAN=2> Potential Errors &nbsp;&nbsp 224 <TR> <TD ALIGN=left>14.18 <TD ALIGN=left COLSPAN=2> Address Configuration And Sockets &nbsp;&nbsp 225 <TR> <TD ALIGN=left>14.19 <TD ALIGN=left COLSPAN=2> Many Buses Or One Bus &nbsp;&nbsp 226 <TR> <TD ALIGN=left>14.20 <TD ALIGN=left COLSPAN=2> Using Fetch-Store With Devices &nbsp;&nbsp 226 <TR> <TD ALIGN=left>14.21 <TD ALIGN=left COLSPAN=2> An Example Of Device Control Using Fetch-Store &nbsp;&nbsp 226 <TR> <TD ALIGN=left>14.22 <TD ALIGN=left COLSPAN=2> Operation Of An Interface &nbsp;&nbsp 227 <TR> <TD ALIGN=left>14.23 <TD ALIGN=left COLSPAN=2> Asymmetric Assignments &nbsp;&nbsp 228 <TR> <TD ALIGN=left>14.24 <TD ALIGN=left COLSPAN=2> Unified Memory And Device Addressing &nbsp;&nbsp 228 <TR> <TD ALIGN=left>14.25 <TD ALIGN=left COLSPAN=2> Holes In The Address Space &nbsp;&nbsp 230 <TR> <TD ALIGN=left>14.26 <TD ALIGN=left COLSPAN=2> Address Map &nbsp;&nbsp 230 <TR> <TD ALIGN=left>14.27 <TD ALIGN=left COLSPAN=2> Program Interface To A Bus &nbsp;&nbsp 231 <TR> <TD ALIGN=left>14.28 <TD ALIGN=left COLSPAN=2> Bridging Between Two Buses &nbsp;&nbsp 232 <TR> <TD ALIGN=left>14.29 <TD ALIGN=left COLSPAN=2> Main And Auxiliary Buses &nbsp;&nbsp 232 <TR> <TD ALIGN=left>14.30 <TD ALIGN=left COLSPAN=2> Consequences For Programmers &nbsp;&nbsp 234 <TR> <TD ALIGN=left>14.31 <TD ALIGN=left COLSPAN=2> Switching Fabrics &nbsp;&nbsp 234 <TR> <TD ALIGN=left>14.32 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 235 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 236<BR> </TABLE> <BR> <BR> <H3>Chapter 15 &nbsp; Programmed And Interrupt-Driven I/O &nbsp;&nbsp; 237</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>15.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 237 <TR> <TD ALIGN=left>15.2 <TD ALIGN=left COLSPAN=2> I^/^O Paradigms &nbsp;&nbsp 237 <TR> <TD ALIGN=left>15.3 <TD ALIGN=left COLSPAN=2> Programmed I^/^O &nbsp;&nbsp 238 <TR> <TD ALIGN=left>15.4 <TD ALIGN=left COLSPAN=2> Synchronization &nbsp;&nbsp 238 <TR> <TD ALIGN=left>15.5 <TD ALIGN=left COLSPAN=2> Polling &nbsp;&nbsp 239 <TR> <TD ALIGN=left>15.6 <TD ALIGN=left COLSPAN=2> Code For Polling &nbsp;&nbsp 239 <TR> <TD ALIGN=left>15.7 <TD ALIGN=left COLSPAN=2> Control And Status Registers &nbsp;&nbsp 241 <TR> <TD ALIGN=left>15.8 <TD ALIGN=left COLSPAN=2> Processor Use And Polling &nbsp;&nbsp 241 <TR> <TD ALIGN=left>15.9 <TD ALIGN=left COLSPAN=2> First, Second, And Third Generation Computers &nbsp;&nbsp 242 <TR> <TD ALIGN=left>15.10 <TD ALIGN=left COLSPAN=2> Interrupt-Driven I^/^O &nbsp;&nbsp 242 <TR> <TD ALIGN=left>15.11 <TD ALIGN=left COLSPAN=2> A Hardware Interrupt Mechanism &nbsp;&nbsp 243 <TR> <TD ALIGN=left>15.12 <TD ALIGN=left COLSPAN=2> Interrupts And The Fetch-Execute Cycle &nbsp;&nbsp 243 <TR> <TD ALIGN=left>15.13 <TD ALIGN=left COLSPAN=2> Handling An Interrupt &nbsp;&nbsp 244 <TR> <TD ALIGN=left>15.14 <TD ALIGN=left COLSPAN=2> Interrupt Vectors &nbsp;&nbsp 245 <TR> <TD ALIGN=left>15.15 <TD ALIGN=left COLSPAN=2> Initialization And Enabling And Disabling Interrupts &nbsp;&nbsp 246 <TR> <TD ALIGN=left>15.16 <TD ALIGN=left COLSPAN=2> Preventing Interrupt Code From Being Interrupted &nbsp;&nbsp 246 <TR> <TD ALIGN=left>15.17 <TD ALIGN=left COLSPAN=2> Multiple Levels Of Interrupts &nbsp;&nbsp 246 <TR> <TD ALIGN=left>15.18 <TD ALIGN=left COLSPAN=2> Assignment Of Interrupt Vectors And Priorities &nbsp;&nbsp 247 <TR> <TD ALIGN=left>15.19 <TD ALIGN=left COLSPAN=2> Dynamic Bus Connections And Pluggable Devices &nbsp;&nbsp 248 <TR> <TD ALIGN=left>15.20 <TD ALIGN=left COLSPAN=2> The Advantage Of Interrupts &nbsp;&nbsp 249 <TR> <TD ALIGN=left>15.21 <TD ALIGN=left COLSPAN=2> Smart Devices And Improved I^/^O Performance &nbsp;&nbsp 249 <TR> <TD ALIGN=left>15.22 <TD ALIGN=left COLSPAN=2> Direct Memory Access (DMA) &nbsp;&nbsp 250 <TR> <TD ALIGN=left>15.23 <TD ALIGN=left COLSPAN=2> Buffer Chaining &nbsp;&nbsp 251 <TR> <TD ALIGN=left>15.24 <TD ALIGN=left COLSPAN=2> Scatter Read And Gather Write Operations &nbsp;&nbsp 252 <TR> <TD ALIGN=left>15.25 <TD ALIGN=left COLSPAN=2> Operation Chaining &nbsp;&nbsp 252 <TR> <TD ALIGN=left>15.26 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 253 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 253<BR> </TABLE> <BR> <BR> <H3>Chapter 16 &nbsp; A Programmer's View Of Devices, I^/^O, And Buffering &nbsp;&nbsp; 255</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>16.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 255 <TR> <TD ALIGN=left>16.2 <TD ALIGN=left COLSPAN=2> Definition Of A Device Driver &nbsp;&nbsp 256 <TR> <TD ALIGN=left>16.3 <TD ALIGN=left COLSPAN=2> Device Independence, Encapsulation, And Hiding &nbsp;&nbsp 256 <TR> <TD ALIGN=left>16.4 <TD ALIGN=left COLSPAN=2> Conceptual Parts Of A Device Driver &nbsp;&nbsp 257 <TR> <TD ALIGN=left>16.5 <TD ALIGN=left COLSPAN=2> Two Types Of Devices &nbsp;&nbsp 258 <TR> <TD ALIGN=left>16.6 <TD ALIGN=left COLSPAN=2> Example Flow Through A Device Driver &nbsp;&nbsp 258 <TR> <TD ALIGN=left>16.7 <TD ALIGN=left COLSPAN=2> Queued Output Operations &nbsp;&nbsp 259 <TR> <TD ALIGN=left>16.8 <TD ALIGN=left COLSPAN=2> Forcing An Interrupt &nbsp;&nbsp 261 <TR> <TD ALIGN=left>16.9 <TD ALIGN=left COLSPAN=2> Queued Input Operations &nbsp;&nbsp 261 <TR> <TD ALIGN=left>16.10 <TD ALIGN=left COLSPAN=2> Devices That Support Bi-Directional Transfer &nbsp;&nbsp 262 <TR> <TD ALIGN=left>16.11 <TD ALIGN=left COLSPAN=2> Asynchronous Vs. Synchronous Programming Paradigm &nbsp;&nbsp 263 <TR> <TD ALIGN=left>16.12 <TD ALIGN=left COLSPAN=2> Asynchrony, Smart Devices, And Mutual Exclusion &nbsp;&nbsp 264 <TR> <TD ALIGN=left>16.13 <TD ALIGN=left COLSPAN=2> I^/^O As Viewed By An Application &nbsp;&nbsp 264 <TR> <TD ALIGN=left>16.14 <TD ALIGN=left COLSPAN=2> Run-Time I^/^O Libraries &nbsp;&nbsp 265 <TR> <TD ALIGN=left>16.15 <TD ALIGN=left COLSPAN=2> The Library^/^Operating System Dichotomy &nbsp;&nbsp 266 <TR> <TD ALIGN=left>16.16 <TD ALIGN=left COLSPAN=2> I^/^O Operations The OS Supports &nbsp;&nbsp 267 <TR> <TD ALIGN=left>16.17 <TD ALIGN=left COLSPAN=2> The Cost Of I^/^O Operations &nbsp;&nbsp 268 <TR> <TD ALIGN=left>16.18 <TD ALIGN=left COLSPAN=2> Reducing The System Call Overhead &nbsp;&nbsp 268 <TR> <TD ALIGN=left>16.19 <TD ALIGN=left COLSPAN=2> The Important Concept Of Buffering &nbsp;&nbsp 269 <TR> <TD ALIGN=left>16.20 <TD ALIGN=left COLSPAN=2> Implementation of Buffering &nbsp;&nbsp 270 <TR> <TD ALIGN=left>16.21 <TD ALIGN=left COLSPAN=2> Flushing A Buffer &nbsp;&nbsp 271 <TR> <TD ALIGN=left>16.22 <TD ALIGN=left COLSPAN=2> Buffering On Input &nbsp;&nbsp 272 <TR> <TD ALIGN=left>16.23 <TD ALIGN=left COLSPAN=2> Effectiveness Of Buffering &nbsp;&nbsp 272 <TR> <TD ALIGN=left>16.24 <TD ALIGN=left COLSPAN=2> Buffering In An Operating System &nbsp;&nbsp 273 <TR> <TD ALIGN=left>16.25 <TD ALIGN=left COLSPAN=2> Relation To Caching &nbsp;&nbsp 274 <TR> <TD ALIGN=left>16.26 <TD ALIGN=left COLSPAN=2> An Example: The Unix Standard I^/^O Library &nbsp;&nbsp 274 <TR> <TD ALIGN=left>16.27 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 274 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 275<BR> </TABLE> <BR> <BR><H3> PART V &nbsp;&nbsp; Advanced Topics &nbsp;&nbsp; 277</H3> <BR> <H3>Chapter 17 &nbsp; Parallelism &nbsp;&nbsp; 279</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>17.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 279 <TR> <TD ALIGN=left>17.2 <TD ALIGN=left COLSPAN=2> Parallel And Pipelined Architectures &nbsp;&nbsp 279 <TR> <TD ALIGN=left>17.3 <TD ALIGN=left COLSPAN=2> Characterizations Of Parallelism &nbsp;&nbsp 280 <TR> <TD ALIGN=left>17.4 <TD ALIGN=left COLSPAN=2> Microscopic Vs. Macroscopic &nbsp;&nbsp 280 <TR> <TD ALIGN=left>17.5 <TD ALIGN=left COLSPAN=2> Examples Of Microscopic Parallelism &nbsp;&nbsp 281 <TR> <TD ALIGN=left>17.6 <TD ALIGN=left COLSPAN=2> Examples Of Macroscopic Parallelism &nbsp;&nbsp 281 <TR> <TD ALIGN=left>17.7 <TD ALIGN=left COLSPAN=2> Symmetric Vs. Asymmetric &nbsp;&nbsp 282 <TR> <TD ALIGN=left>17.8 <TD ALIGN=left COLSPAN=2> Fine-grain Vs. Coarse-grain Parallelism &nbsp;&nbsp 282 <TR> <TD ALIGN=left>17.9 <TD ALIGN=left COLSPAN=2> Explicit Vs. Implicit Parallelism &nbsp;&nbsp 283 <TR> <TD ALIGN=left>17.10 <TD ALIGN=left COLSPAN=2> Parallel Architectures &nbsp;&nbsp 283 <TR> <TD ALIGN=left>17.11 <TD ALIGN=left COLSPAN=2> Types Of Parallel Architectures (Flynn Classification) &nbsp;&nbsp 283 <TR> <TD ALIGN=left>17.12 <TD ALIGN=left COLSPAN=2> Single Instruction Single Data (SISD) &nbsp;&nbsp 284 <TR> <TD ALIGN=left>17.13 <TD ALIGN=left COLSPAN=2> Single Instruction Multiple Data (SIMD) &nbsp;&nbsp 284 <TR> <TD ALIGN=left>17.14 <TD ALIGN=left COLSPAN=2> Multiple Instructions Multiple Data (MIMD) &nbsp;&nbsp 286 <TR> <TD ALIGN=left>17.15 <TD ALIGN=left COLSPAN=2> Communication, Coordination, And Contention &nbsp;&nbsp 288 <TR> <TD ALIGN=left>17.16 <TD ALIGN=left COLSPAN=2> Performance Of Multiprocessors &nbsp;&nbsp 290 <TR> <TD ALIGN=left>17.17 <TD ALIGN=left COLSPAN=2> Consequences For Programmers &nbsp;&nbsp 292 <TR> <TD ALIGN=left> <TD ALIGN=left>17.17.1 <TD ALIGN=left> Locks And Mutual Exclusion &nbsp;&nbsp 292 <TR> <TD ALIGN=left> <TD ALIGN=left>17.17.2 <TD ALIGN=left> Programming Explicit And Implicit Parallel Computers &nbsp;&nbsp 293 <TR> <TD ALIGN=left> <TD ALIGN=left>17.17.3 <TD ALIGN=left> Programming Symmetric And Asymmetric Multiprocessors &nbsp;&nbsp 294 <TR> <TD ALIGN=left>17.18 <TD ALIGN=left COLSPAN=2> Redundant Parallel Architectures &nbsp;&nbsp 294 <TR> <TD ALIGN=left>17.19 <TD ALIGN=left COLSPAN=2> Distributed And Cluster Computers &nbsp;&nbsp 295 <TR> <TD ALIGN=left>17.20 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 296 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 297<BR> </TABLE> <BR> <BR> <H3>Chapter 18 &nbsp; Pipelining &nbsp;&nbsp; 299</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>18.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 299 <TR> <TD ALIGN=left>18.2 <TD ALIGN=left COLSPAN=2> The Concept Of Pipelining &nbsp;&nbsp 299 <TR> <TD ALIGN=left>18.3 <TD ALIGN=left COLSPAN=2> Software Pipelining &nbsp;&nbsp 301 <TR> <TD ALIGN=left>18.4 <TD ALIGN=left COLSPAN=2> Software Pipeline Performance And Overhead &nbsp;&nbsp 302 <TR> <TD ALIGN=left>18.5 <TD ALIGN=left COLSPAN=2> Hardware Pipelining &nbsp;&nbsp 303 <TR> <TD ALIGN=left>18.6 <TD ALIGN=left COLSPAN=2> How Hardware Pipelining Increases Performance &nbsp;&nbsp 303 <TR> <TD ALIGN=left>18.7 <TD ALIGN=left COLSPAN=2> When Pipelining Can Be Used &nbsp;&nbsp 306 <TR> <TD ALIGN=left>18.8 <TD ALIGN=left COLSPAN=2> The Conceptual Division Of Processing &nbsp;&nbsp 307 <TR> <TD ALIGN=left>18.9 <TD ALIGN=left COLSPAN=2> Pipeline Architectures &nbsp;&nbsp 307 <TR> <TD ALIGN=left>18.10 <TD ALIGN=left COLSPAN=2> Pipeline Setup, Stall, And Flush Times &nbsp;&nbsp 308 <TR> <TD ALIGN=left>18.11 <TD ALIGN=left COLSPAN=2> Definition Of Superpipeline Architecture &nbsp;&nbsp 308 <TR> <TD ALIGN=left>18.12 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 309 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 309<BR> </TABLE> <BR> <BR> <H3>Chapter 19 &nbsp; Assessing Performance &nbsp;&nbsp; 311</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>19.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 311 <TR> <TD ALIGN=left>19.2 <TD ALIGN=left COLSPAN=2> Measuring Power And Performance &nbsp;&nbsp 311 <TR> <TD ALIGN=left>19.3 <TD ALIGN=left COLSPAN=2> Measures Of Computational Power &nbsp;&nbsp 312 <TR> <TD ALIGN=left>19.4 <TD ALIGN=left COLSPAN=2> Application Specific Instruction Counts &nbsp;&nbsp 313 <TR> <TD ALIGN=left>19.5 <TD ALIGN=left COLSPAN=2> Instruction Mix &nbsp;&nbsp 314 <TR> <TD ALIGN=left>19.6 <TD ALIGN=left COLSPAN=2> Standardized Benchmarks &nbsp;&nbsp 315 <TR> <TD ALIGN=left>19.7 <TD ALIGN=left COLSPAN=2> I^/^O And Memory Bottlenecks &nbsp;&nbsp 316 <TR> <TD ALIGN=left>19.8 <TD ALIGN=left COLSPAN=2> Boundary Between Hardware And Software &nbsp;&nbsp 316 <TR> <TD ALIGN=left>19.9 <TD ALIGN=left COLSPAN=2> Choosing Items To Optimize &nbsp;&nbsp 317 <TR> <TD ALIGN=left>19.10 <TD ALIGN=left COLSPAN=2> Amdahl's Law And Parallel Systems &nbsp;&nbsp 317 <TR> <TD ALIGN=left>19.11 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 318 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 318<BR> </TABLE> <BR> <BR> <H3>Chapter 20 &nbsp; Architecture Examples And Hierarchy &nbsp;&nbsp; 319</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>20.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 319 <TR> <TD ALIGN=left>20.2 <TD ALIGN=left COLSPAN=2> Architectural Levels &nbsp;&nbsp 319 <TR> <TD ALIGN=left>20.3 <TD ALIGN=left COLSPAN=2> System-Level Architecture: A Personal Computer &nbsp;&nbsp 320 <TR> <TD ALIGN=left>20.4 <TD ALIGN=left COLSPAN=2> Bus Interconnection And Bridging &nbsp;&nbsp 321 <TR> <TD ALIGN=left>20.5 <TD ALIGN=left COLSPAN=2> Controller Chips And Physical Architecture &nbsp;&nbsp 322 <TR> <TD ALIGN=left>20.6 <TD ALIGN=left COLSPAN=2> Virtual Buses &nbsp;&nbsp 323 <TR> <TD ALIGN=left>20.7 <TD ALIGN=left COLSPAN=2> Connection Speeds &nbsp;&nbsp 325 <TR> <TD ALIGN=left>20.8 <TD ALIGN=left COLSPAN=2> Bridging Functionality And Virtual Buses &nbsp;&nbsp 325 <TR> <TD ALIGN=left>20.9 <TD ALIGN=left COLSPAN=2> Board-Level Architecture &nbsp;&nbsp 325 <TR> <TD ALIGN=left>20.10 <TD ALIGN=left COLSPAN=2> Chip-Level Architecture &nbsp;&nbsp 327 <TR> <TD ALIGN=left>20.11 <TD ALIGN=left COLSPAN=2> Structure Of Functional Units On A Chip &nbsp;&nbsp 328 <TR> <TD ALIGN=left>20.12 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 329 <TR> <TD ALIGN=left>20.13 <TD ALIGN=left COLSPAN=2> Hierarchy Beyond Computer Architectures &nbsp;&nbsp 329 </TABLE> <BR> <BR><H3> Appendix 1 &nbsp; Lab Exercises For A Computer Architecture Course &nbsp;&nbsp; 331</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>A1.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 331 <TR> <TD ALIGN=left>A1.2 <TD ALIGN=left COLSPAN=2> Digital Hardware For A Lab &nbsp;&nbsp 332 <TR> <TD ALIGN=left>A1.3 <TD ALIGN=left COLSPAN=2> Solderless Breadboard &nbsp;&nbsp 332 <TR> <TD ALIGN=left>A1.4 <TD ALIGN=left COLSPAN=2> Using A Solderless Breadboard &nbsp;&nbsp 333 <TR> <TD ALIGN=left>A1.5 <TD ALIGN=left COLSPAN=2> Testing &nbsp;&nbsp 334 <TR> <TD ALIGN=left>A1.6 <TD ALIGN=left COLSPAN=2> Power And Ground Connections &nbsp;&nbsp 334 <TR> <TD ALIGN=left>A1.7 <TD ALIGN=left COLSPAN=2> Lab Exercises &nbsp;&nbsp 335 </TABLE> <BR><H3> Bibliography &nbsp;&nbsp;359</H3> <BR><H3> Index &nbsp;&nbsp;361</H3> </UL></UL> </BODY> </BODY>
</DOC>
