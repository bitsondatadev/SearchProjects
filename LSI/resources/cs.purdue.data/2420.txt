<DOC>
<DOCNO> http://www.cs.purdue.edu/homes/dec/tcpip3l.cont.html </DOCNO>
<HTML> <HEAD> <TITLE> vol3 (Linux/POSIX) contents </TITLE> </HEAD> <BODY> <CENTER> <H2> Table of Contents For <BR><BR> Internetworking With TCP/IP &nbsp;&nbsp; Volume 3 (Linux/POSIX)<BR><BR> 1st Edition <BR><BR> </H2> </CENTER> <UL><UL> <BR><H3> Foreword &nbsp;&nbsp;xxiii</H3> <BR><H3> Preface &nbsp;&nbsp;xxv</H3> <BR> <H3>Chapter 1 &nbsp; Introduction And Overview &nbsp;&nbsp; 1</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>1.1 <TD ALIGN=left COLSPAN=2> Internet Applications Using TCP/IP &nbsp;&nbsp 1 <TR> <TD ALIGN=left>1.2 <TD ALIGN=left COLSPAN=2> Designing Applications For A Distributed Environment &nbsp;&nbsp 1 <TR> <TD ALIGN=left>1.3 <TD ALIGN=left COLSPAN=2> Standard And Nonstandard Application Protocols &nbsp;&nbsp 2 <TR> <TD ALIGN=left>1.4 <TD ALIGN=left COLSPAN=2> An Example Of Standard Application Protocol Use &nbsp;&nbsp 2 <TR> <TD ALIGN=left>1.5 <TD ALIGN=left COLSPAN=2> An Example TELNET Connection &nbsp;&nbsp 3 <TR> <TD ALIGN=left>1.6 <TD ALIGN=left COLSPAN=2> Using TELNET To Access An Alternative Service &nbsp;&nbsp 4 <TR> <TD ALIGN=left>1.7 <TD ALIGN=left COLSPAN=2> Application Protocols And Software Flexibility &nbsp;&nbsp 5 <TR> <TD ALIGN=left>1.8 <TD ALIGN=left COLSPAN=2> Viewing Services From The Provider's Perspective &nbsp;&nbsp 6 <TR> <TD ALIGN=left>1.9 <TD ALIGN=left COLSPAN=2> The Remainder Of This Text &nbsp;&nbsp 6 <TR> <TD ALIGN=left>1.10 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 7 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 8<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 8<BR> </TABLE> <BR> <BR> <H3>Chapter 2 &nbsp; The Client Server Model And Software Design &nbsp;&nbsp; 9</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>2.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 9 <TR> <TD ALIGN=left>2.2 <TD ALIGN=left COLSPAN=2> Motivation &nbsp;&nbsp 10 <TR> <TD ALIGN=left>2.3 <TD ALIGN=left COLSPAN=2> Terminology And Concepts &nbsp;&nbsp 10 <TR> <TD ALIGN=left> <TD ALIGN=left>2.3.1 <TD ALIGN=left> Clients And Servers &nbsp;&nbsp 11 <TR> <TD ALIGN=left> <TD ALIGN=left>2.3.2 <TD ALIGN=left> Privilege And Complexity &nbsp;&nbsp 11 <TR> <TD ALIGN=left> <TD ALIGN=left>2.3.3 <TD ALIGN=left> Standard Vs. Nonstandard Client Software &nbsp;&nbsp 12 <TR> <TD ALIGN=left> <TD ALIGN=left>2.3.4 <TD ALIGN=left> Parameterization Of Clients &nbsp;&nbsp 12 <TR> <TD ALIGN=left> <TD ALIGN=left>2.3.5 <TD ALIGN=left> Connectionless Vs. Connection-Oriented Servers &nbsp;&nbsp 13 <TR> <TD ALIGN=left> <TD ALIGN=left>2.3.6 <TD ALIGN=left> Stateless Vs. Stateful Servers &nbsp;&nbsp 14 <TR> <TD ALIGN=left> <TD ALIGN=left>2.3.7 <TD ALIGN=left> A Stateless File Server Example &nbsp;&nbsp 15 <TR> <TD ALIGN=left> <TD ALIGN=left>2.3.8 <TD ALIGN=left> A Stateful File Server Example &nbsp;&nbsp 15 <TR> <TD ALIGN=left> <TD ALIGN=left>2.3.9 <TD ALIGN=left> Identifying A Client &nbsp;&nbsp 16 <TR> <TD ALIGN=left> <TD ALIGN=left>2.3.10 <TD ALIGN=left> Statelessness Is A Protocol Issue &nbsp;&nbsp 18 <TR> <TD ALIGN=left> <TD ALIGN=left>2.3.11 <TD ALIGN=left> Servers As Clients &nbsp;&nbsp 19 <TR> <TD ALIGN=left>2.4 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 20 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 20<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 20<BR> </TABLE> <BR> <BR> <H3>Chapter 3 &nbsp; Concurrent Processing In Client-Server Software &nbsp;&nbsp; 23</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>3.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 23 <TR> <TD ALIGN=left>3.2 <TD ALIGN=left COLSPAN=2> Concurrency In Networks &nbsp;&nbsp 23 <TR> <TD ALIGN=left>3.3 <TD ALIGN=left COLSPAN=2> Concurrency In Servers &nbsp;&nbsp 25 <TR> <TD ALIGN=left>3.4 <TD ALIGN=left COLSPAN=2> Terminology And Concepts &nbsp;&nbsp 26 <TR> <TD ALIGN=left> <TD ALIGN=left>3.4.1 <TD ALIGN=left> The Process Concept &nbsp;&nbsp 26 <TR> <TD ALIGN=left> <TD ALIGN=left>3.4.2 <TD ALIGN=left> Sharing Of Local And Global Variables &nbsp;&nbsp 27 <TR> <TD ALIGN=left> <TD ALIGN=left>3.4.3 <TD ALIGN=left> Procedure Calls &nbsp;&nbsp 28 <TR> <TD ALIGN=left>3.5 <TD ALIGN=left COLSPAN=2> An Example Of Concurrent Process Creation &nbsp;&nbsp 29 <TR> <TD ALIGN=left> <TD ALIGN=left>3.5.1 <TD ALIGN=left> A Sequential C Example &nbsp;&nbsp 29 <TR> <TD ALIGN=left> <TD ALIGN=left>3.5.2 <TD ALIGN=left> A Concurrent Version &nbsp;&nbsp 30 <TR> <TD ALIGN=left> <TD ALIGN=left>3.5.3 <TD ALIGN=left> Timeslicing &nbsp;&nbsp 31 <TR> <TD ALIGN=left> <TD ALIGN=left>3.5.4 <TD ALIGN=left> Singly-Threaded Process Assumption &nbsp;&nbsp 32 <TR> <TD ALIGN=left> <TD ALIGN=left>3.5.5 <TD ALIGN=left> Making Processes Diverge &nbsp;&nbsp 33 <TR> <TD ALIGN=left>3.6 <TD ALIGN=left COLSPAN=2> Executing New Code &nbsp;&nbsp 34 <TR> <TD ALIGN=left>3.7 <TD ALIGN=left COLSPAN=2> Context Switching And Protocol Software Design &nbsp;&nbsp 34 <TR> <TD ALIGN=left>3.8 <TD ALIGN=left COLSPAN=2> Concurrency And Asynchronous I/O &nbsp;&nbsp 35 <TR> <TD ALIGN=left>3.9 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 36 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 36<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 36<BR> </TABLE> <BR> <BR> <H3>Chapter 4 &nbsp; Application Interface To Protocols &nbsp;&nbsp; 39</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>4.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 39 <TR> <TD ALIGN=left>4.2 <TD ALIGN=left COLSPAN=2> Loosely Specified Protocol Software Interface &nbsp;&nbsp 39 <TR> <TD ALIGN=left> <TD ALIGN=left>4.2.1 <TD ALIGN=left> Advantages And Disadvantages &nbsp;&nbsp 40 <TR> <TD ALIGN=left>4.3 <TD ALIGN=left COLSPAN=2> Interface Functionality &nbsp;&nbsp 40 <TR> <TD ALIGN=left>4.4 <TD ALIGN=left COLSPAN=2> Conceptual Interface Specification &nbsp;&nbsp 41 <TR> <TD ALIGN=left>4.5 <TD ALIGN=left COLSPAN=2> System Calls &nbsp;&nbsp 42 <TR> <TD ALIGN=left>4.6 <TD ALIGN=left COLSPAN=2> Two Basic Approaches To Network Communication &nbsp;&nbsp 43 <TR> <TD ALIGN=left>4.7 <TD ALIGN=left COLSPAN=2> The Basic I/O Functions Available In Linux &nbsp;&nbsp 43 <TR> <TD ALIGN=left>4.8 <TD ALIGN=left COLSPAN=2> Using Linux I/O With TCP/IP &nbsp;&nbsp 45 <TR> <TD ALIGN=left>4.9 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 45 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 46<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 46<BR> </TABLE> <BR> <BR> <H3>Chapter 5 &nbsp; The Socket API &nbsp;&nbsp; 47</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>5.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 47 <TR> <TD ALIGN=left>5.2 <TD ALIGN=left COLSPAN=2> Berkeley Sockets &nbsp;&nbsp 47 <TR> <TD ALIGN=left>5.3 <TD ALIGN=left COLSPAN=2> Specifying A Protocol Interface &nbsp;&nbsp 48 <TR> <TD ALIGN=left>5.4 <TD ALIGN=left COLSPAN=2> The Socket Abstraction &nbsp;&nbsp 49 <TR> <TD ALIGN=left> <TD ALIGN=left>5.4.1 <TD ALIGN=left> Socket Descriptors And File Descriptors &nbsp;&nbsp 49 <TR> <TD ALIGN=left> <TD ALIGN=left>5.4.2 <TD ALIGN=left> System Data Structures For Sockets &nbsp;&nbsp 50 <TR> <TD ALIGN=left> <TD ALIGN=left>5.4.3 <TD ALIGN=left> Making A Socket Active Or Passive &nbsp;&nbsp 51 <TR> <TD ALIGN=left>5.5 <TD ALIGN=left COLSPAN=2> Specifying An Endpoint Address &nbsp;&nbsp 52 <TR> <TD ALIGN=left>5.6 <TD ALIGN=left COLSPAN=2> A Generic Address Structure &nbsp;&nbsp 52 <TR> <TD ALIGN=left>5.7 <TD ALIGN=left COLSPAN=2> Major System Calls In The Socket API &nbsp;&nbsp 54 <TR> <TD ALIGN=left> <TD ALIGN=left>5.7.1 <TD ALIGN=left> The Socket Call &nbsp;&nbsp 54 <TR> <TD ALIGN=left> <TD ALIGN=left>5.7.2 <TD ALIGN=left> The Connect Call &nbsp;&nbsp 54 <TR> <TD ALIGN=left> <TD ALIGN=left>5.7.3 <TD ALIGN=left> The Send Call &nbsp;&nbsp 55 <TR> <TD ALIGN=left> <TD ALIGN=left>5.7.4 <TD ALIGN=left> The Recv Call &nbsp;&nbsp 55 <TR> <TD ALIGN=left> <TD ALIGN=left>5.7.5 <TD ALIGN=left> The Close Call &nbsp;&nbsp 55 <TR> <TD ALIGN=left> <TD ALIGN=left>5.7.6 <TD ALIGN=left> The Bind Call &nbsp;&nbsp 56 <TR> <TD ALIGN=left> <TD ALIGN=left>5.7.7 <TD ALIGN=left> The Listen Call &nbsp;&nbsp 56 <TR> <TD ALIGN=left> <TD ALIGN=left>5.7.8 <TD ALIGN=left> The Accept Call &nbsp;&nbsp 56 <TR> <TD ALIGN=left> <TD ALIGN=left>5.7.9 <TD ALIGN=left> Using Read And Write With Sockets &nbsp;&nbsp 56 <TR> <TD ALIGN=left> <TD ALIGN=left>5.7.10 <TD ALIGN=left> Summary Of Socket Calls &nbsp;&nbsp 57 <TR> <TD ALIGN=left>5.8 <TD ALIGN=left COLSPAN=2> Utility Routines For Integer Conversion &nbsp;&nbsp 58 <TR> <TD ALIGN=left>5.9 <TD ALIGN=left COLSPAN=2> Using Socket Calls In A Program &nbsp;&nbsp 58 <TR> <TD ALIGN=left>5.10 <TD ALIGN=left COLSPAN=2> Symbolic Constants For Socket Call Parameters &nbsp;&nbsp 59 <TR> <TD ALIGN=left>5.11 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 60 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 61<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 61<BR> </TABLE> <BR> <BR> <H3>Chapter 6 &nbsp; Algorithms And Issues In Client Software Design &nbsp;&nbsp; 63</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>6.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 63 <TR> <TD ALIGN=left>6.2 <TD ALIGN=left COLSPAN=2> Learning Algorithms Instead Of Details &nbsp;&nbsp 63 <TR> <TD ALIGN=left>6.3 <TD ALIGN=left COLSPAN=2> Client Architecture &nbsp;&nbsp 64 <TR> <TD ALIGN=left>6.4 <TD ALIGN=left COLSPAN=2> Identifying The Location Of A Server &nbsp;&nbsp 64 <TR> <TD ALIGN=left>6.5 <TD ALIGN=left COLSPAN=2> Parsing An Address Argument &nbsp;&nbsp 66 <TR> <TD ALIGN=left>6.6 <TD ALIGN=left COLSPAN=2> Looking Up A Domain Name &nbsp;&nbsp 67 <TR> <TD ALIGN=left>6.7 <TD ALIGN=left COLSPAN=2> Looking Up A Well-Known Port By Name &nbsp;&nbsp 68 <TR> <TD ALIGN=left>6.8 <TD ALIGN=left COLSPAN=2> Port Numbers And Network Byte Order &nbsp;&nbsp 68 <TR> <TD ALIGN=left>6.9 <TD ALIGN=left COLSPAN=2> Looking Up A Protocol By Name &nbsp;&nbsp 69 <TR> <TD ALIGN=left>6.10 <TD ALIGN=left COLSPAN=2> The TCP Client Algorithm &nbsp;&nbsp 69 <TR> <TD ALIGN=left>6.11 <TD ALIGN=left COLSPAN=2> Allocating A Socket &nbsp;&nbsp 70 <TR> <TD ALIGN=left>6.12 <TD ALIGN=left COLSPAN=2> Choosing A Local Protocol Port Number &nbsp;&nbsp 71 <TR> <TD ALIGN=left>6.13 <TD ALIGN=left COLSPAN=2> A Fundamental Problem In Choosing A Local IP Address &nbsp;&nbsp 71 <TR> <TD ALIGN=left>6.14 <TD ALIGN=left COLSPAN=2> Connecting A TCP Socket To A Server &nbsp;&nbsp 72 <TR> <TD ALIGN=left>6.15 <TD ALIGN=left COLSPAN=2> Communicating With The Server Using TCP &nbsp;&nbsp 72 <TR> <TD ALIGN=left>6.16 <TD ALIGN=left COLSPAN=2> Receiving A Response From A TCP Connection &nbsp;&nbsp 73 <TR> <TD ALIGN=left>6.17 <TD ALIGN=left COLSPAN=2> Closing A TCP Connection &nbsp;&nbsp 74 <TR> <TD ALIGN=left> <TD ALIGN=left>6.17.1 <TD ALIGN=left> The Need For Partial Close &nbsp;&nbsp 74 <TR> <TD ALIGN=left> <TD ALIGN=left>6.17.2 <TD ALIGN=left> A Partial Close Operation &nbsp;&nbsp 74 <TR> <TD ALIGN=left>6.18 <TD ALIGN=left COLSPAN=2> Programming A UDP Client &nbsp;&nbsp 75 <TR> <TD ALIGN=left>6.19 <TD ALIGN=left COLSPAN=2> Connected And Unconnected UDP Sockets &nbsp;&nbsp 76 <TR> <TD ALIGN=left>6.20 <TD ALIGN=left COLSPAN=2> Using Connect With UDP &nbsp;&nbsp 76 <TR> <TD ALIGN=left>6.21 <TD ALIGN=left COLSPAN=2> Communicating With A Server Using UDP &nbsp;&nbsp 76 <TR> <TD ALIGN=left>6.22 <TD ALIGN=left COLSPAN=2> Closing A Socket That Uses UDP &nbsp;&nbsp 77 <TR> <TD ALIGN=left>6.23 <TD ALIGN=left COLSPAN=2> Partial Close For UDP &nbsp;&nbsp 77 <TR> <TD ALIGN=left>6.24 <TD ALIGN=left COLSPAN=2> A Warning About UDP Unreliability &nbsp;&nbsp 77 <TR> <TD ALIGN=left>6.25 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 77 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 78<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 78<BR> </TABLE> <BR> <BR> <H3>Chapter 7 &nbsp; Example Client Software &nbsp;&nbsp; 81</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>7.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 81 <TR> <TD ALIGN=left>7.2 <TD ALIGN=left COLSPAN=2> The Importance Of Small Examples &nbsp;&nbsp 81 <TR> <TD ALIGN=left>7.3 <TD ALIGN=left COLSPAN=2> Hiding Details &nbsp;&nbsp 82 <TR> <TD ALIGN=left>7.4 <TD ALIGN=left COLSPAN=2> An Example Procedure Library For Client Programs &nbsp;&nbsp 82 <TR> <TD ALIGN=left>7.5 <TD ALIGN=left COLSPAN=2> Implementation Of ConnectTCP &nbsp;&nbsp 83 <TR> <TD ALIGN=left>7.6 <TD ALIGN=left COLSPAN=2> Implementation Of ConnectUDP &nbsp;&nbsp 84 <TR> <TD ALIGN=left>7.7 <TD ALIGN=left COLSPAN=2> A Procedure That Forms Connections &nbsp;&nbsp 85 <TR> <TD ALIGN=left>7.8 <TD ALIGN=left COLSPAN=2> Using The Example Library &nbsp;&nbsp 88 <TR> <TD ALIGN=left>7.9 <TD ALIGN=left COLSPAN=2> The DAYTIME Service &nbsp;&nbsp 88 <TR> <TD ALIGN=left>7.10 <TD ALIGN=left COLSPAN=2> Implementation Of A TCP Client For DAYTIME &nbsp;&nbsp 89 <TR> <TD ALIGN=left>7.11 <TD ALIGN=left COLSPAN=2> Reading From A TCP Connection &nbsp;&nbsp 90 <TR> <TD ALIGN=left>7.12 <TD ALIGN=left COLSPAN=2> The TIME Service &nbsp;&nbsp 91 <TR> <TD ALIGN=left>7.13 <TD ALIGN=left COLSPAN=2> Accessing The TIME Service &nbsp;&nbsp 91 <TR> <TD ALIGN=left>7.14 <TD ALIGN=left COLSPAN=2> Accurate Times And Network Delays &nbsp;&nbsp 92 <TR> <TD ALIGN=left>7.15 <TD ALIGN=left COLSPAN=2> A UDP Client For The TIME Service &nbsp;&nbsp 92 <TR> <TD ALIGN=left>7.16 <TD ALIGN=left COLSPAN=2> The ECHO Service &nbsp;&nbsp 94 <TR> <TD ALIGN=left>7.17 <TD ALIGN=left COLSPAN=2> A TCP Client For The ECHO Service &nbsp;&nbsp 94 <TR> <TD ALIGN=left>7.18 <TD ALIGN=left COLSPAN=2> A UDP Client For The ECHO Service &nbsp;&nbsp 96 <TR> <TD ALIGN=left>7.19 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 98 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 99<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 99<BR> </TABLE> <BR> <BR> <H3>Chapter 8 &nbsp; Algorithms And Issues In Server Software Design &nbsp;&nbsp; 101</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>8.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 101 <TR> <TD ALIGN=left>8.2 <TD ALIGN=left COLSPAN=2> The Conceptual Server Algorithm &nbsp;&nbsp 101 <TR> <TD ALIGN=left>8.3 <TD ALIGN=left COLSPAN=2> Concurrent Vs. Iterative Servers &nbsp;&nbsp 102 <TR> <TD ALIGN=left>8.4 <TD ALIGN=left COLSPAN=2> Connection-Oriented Vs. Connectionless Access &nbsp;&nbsp 102 <TR> <TD ALIGN=left>8.5 <TD ALIGN=left COLSPAN=2> Transport Protocol Semantics &nbsp;&nbsp 103 <TR> <TD ALIGN=left> <TD ALIGN=left>8.5.1 <TD ALIGN=left> TCP Semantics &nbsp;&nbsp 103 <TR> <TD ALIGN=left> <TD ALIGN=left>8.5.2 <TD ALIGN=left> UDP Semantics &nbsp;&nbsp 103 <TR> <TD ALIGN=left>8.6 <TD ALIGN=left COLSPAN=2> Choice Of Transport &nbsp;&nbsp 104 <TR> <TD ALIGN=left>8.7 <TD ALIGN=left COLSPAN=2> Connection-Oriented Servers &nbsp;&nbsp 104 <TR> <TD ALIGN=left>8.8 <TD ALIGN=left COLSPAN=2> Connectionless Servers &nbsp;&nbsp 105 <TR> <TD ALIGN=left>8.9 <TD ALIGN=left COLSPAN=2> Failure, Reliability, And Statelessness &nbsp;&nbsp 106 <TR> <TD ALIGN=left>8.10 <TD ALIGN=left COLSPAN=2> Optimizing Stateless Servers &nbsp;&nbsp 106 <TR> <TD ALIGN=left>8.11 <TD ALIGN=left COLSPAN=2> Four Basic Types Of Servers &nbsp;&nbsp 109 <TR> <TD ALIGN=left>8.12 <TD ALIGN=left COLSPAN=2> Request Processing Time &nbsp;&nbsp 109 <TR> <TD ALIGN=left>8.13 <TD ALIGN=left COLSPAN=2> Iterative Server Algorithms &nbsp;&nbsp 110 <TR> <TD ALIGN=left>8.14 <TD ALIGN=left COLSPAN=2> An Iterative, Connection-Oriented Server Algorithm &nbsp;&nbsp 110 <TR> <TD ALIGN=left>8.15 <TD ALIGN=left COLSPAN=2> Binding To A Well-Known Address Using INADDR_ANY &nbsp;&nbsp 111 <TR> <TD ALIGN=left>8.16 <TD ALIGN=left COLSPAN=2> Placing The Socket In Passive Mode &nbsp;&nbsp 112 <TR> <TD ALIGN=left>8.17 <TD ALIGN=left COLSPAN=2> Accepting Connections And Using Them &nbsp;&nbsp 112 <TR> <TD ALIGN=left>8.18 <TD ALIGN=left COLSPAN=2> An Iterative, Connectionless Server Algorithm &nbsp;&nbsp 112 <TR> <TD ALIGN=left>8.19 <TD ALIGN=left COLSPAN=2> Forming A Reply Address In A Connectionless Server &nbsp;&nbsp 113 <TR> <TD ALIGN=left>8.20 <TD ALIGN=left COLSPAN=2> Concurrent Server Algorithms &nbsp;&nbsp 114 <TR> <TD ALIGN=left>8.21 <TD ALIGN=left COLSPAN=2> Master And Slaves &nbsp;&nbsp 114 <TR> <TD ALIGN=left>8.22 <TD ALIGN=left COLSPAN=2> A Concurrent, Connectionless Server Algorithm &nbsp;&nbsp 115 <TR> <TD ALIGN=left>8.23 <TD ALIGN=left COLSPAN=2> A Concurrent, Connection-Oriented Server Algorithm &nbsp;&nbsp 116 <TR> <TD ALIGN=left>8.24 <TD ALIGN=left COLSPAN=2> Implementations Of Server Concurrency &nbsp;&nbsp 117 <TR> <TD ALIGN=left>8.25 <TD ALIGN=left COLSPAN=2> Using Separate Programs As Slaves &nbsp;&nbsp 118 <TR> <TD ALIGN=left>8.26 <TD ALIGN=left COLSPAN=2> Apparent Concurrency Using A Single Thread &nbsp;&nbsp 118 <TR> <TD ALIGN=left>8.27 <TD ALIGN=left COLSPAN=2> When To Use Each Server Type &nbsp;&nbsp 119 <TR> <TD ALIGN=left>8.28 <TD ALIGN=left COLSPAN=2> A Summary of Server Types &nbsp;&nbsp 120 <TR> <TD ALIGN=left>8.29 <TD ALIGN=left COLSPAN=2> The Important Problem Of Server Deadlock &nbsp;&nbsp 121 <TR> <TD ALIGN=left>8.30 <TD ALIGN=left COLSPAN=2> Alternative Implementations &nbsp;&nbsp 122 <TR> <TD ALIGN=left>8.31 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 122 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 123<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 123<BR> </TABLE> <BR> <BR> <H3>Chapter 9 &nbsp; Iterative, Connectionless Servers (UDP) &nbsp;&nbsp; 125</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>9.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 125 <TR> <TD ALIGN=left>9.2 <TD ALIGN=left COLSPAN=2> Creating A Passive Socket &nbsp;&nbsp 125 <TR> <TD ALIGN=left>9.3 <TD ALIGN=left COLSPAN=2> Process Structure &nbsp;&nbsp 129 <TR> <TD ALIGN=left>9.4 <TD ALIGN=left COLSPAN=2> An Example TIME Server &nbsp;&nbsp 130 <TR> <TD ALIGN=left>9.5 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 132 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 132<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 133<BR> </TABLE> <BR> <BR> <H3>Chapter 10 &nbsp; Iterative, Connection-Oriented Servers (TCP) &nbsp;&nbsp; 135</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>10.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 135 <TR> <TD ALIGN=left>10.2 <TD ALIGN=left COLSPAN=2> Allocating A Passive TCP Socket &nbsp;&nbsp 135 <TR> <TD ALIGN=left>10.3 <TD ALIGN=left COLSPAN=2> A Server For The DAYTIME Service &nbsp;&nbsp 136 <TR> <TD ALIGN=left>10.4 <TD ALIGN=left COLSPAN=2> Process Structure &nbsp;&nbsp 136 <TR> <TD ALIGN=left>10.5 <TD ALIGN=left COLSPAN=2> An Example DAYTIME Server &nbsp;&nbsp 137 <TR> <TD ALIGN=left>10.6 <TD ALIGN=left COLSPAN=2> Closing Connections &nbsp;&nbsp 140 <TR> <TD ALIGN=left>10.7 <TD ALIGN=left COLSPAN=2> Connection Termination And Server Vulnerability &nbsp;&nbsp 140 <TR> <TD ALIGN=left>10.8 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 141 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 141<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 142<BR> </TABLE> <BR> <BR> <H3>Chapter 11 &nbsp; Concurrent, Connection-Oriented Servers (TCP) &nbsp;&nbsp; 143</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>11.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 143 <TR> <TD ALIGN=left>11.2 <TD ALIGN=left COLSPAN=2> ECHO Service &nbsp;&nbsp 143 <TR> <TD ALIGN=left>11.3 <TD ALIGN=left COLSPAN=2> Iterative Vs. Concurrent Implementations &nbsp;&nbsp 144 <TR> <TD ALIGN=left>11.4 <TD ALIGN=left COLSPAN=2> Process Structure &nbsp;&nbsp 144 <TR> <TD ALIGN=left>11.5 <TD ALIGN=left COLSPAN=2> An Example Concurrent ECHO Server &nbsp;&nbsp 145 <TR> <TD ALIGN=left>11.6 <TD ALIGN=left COLSPAN=2> Cleaning Up Errant Processes &nbsp;&nbsp 149 <TR> <TD ALIGN=left>11.7 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 150 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 150<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 150<BR> </TABLE> <BR> <BR> <H3>Chapter 12 &nbsp; Using Threads For Concurrency (TCP) &nbsp;&nbsp; 151</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>12.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 151 <TR> <TD ALIGN=left>12.2 <TD ALIGN=left COLSPAN=2> Overview Of Linux Threads &nbsp;&nbsp 151 <TR> <TD ALIGN=left>12.3 <TD ALIGN=left COLSPAN=2> Advantages Of Threads &nbsp;&nbsp 152 <TR> <TD ALIGN=left>12.4 <TD ALIGN=left COLSPAN=2> Disadvantages Of Threads &nbsp;&nbsp 153 <TR> <TD ALIGN=left>12.5 <TD ALIGN=left COLSPAN=2> Descriptors, Delay, And Exit &nbsp;&nbsp 153 <TR> <TD ALIGN=left>12.6 <TD ALIGN=left COLSPAN=2> Thread Exit &nbsp;&nbsp 154 <TR> <TD ALIGN=left>12.7 <TD ALIGN=left COLSPAN=2> Thread Coordination And Synchronization &nbsp;&nbsp 154 <TR> <TD ALIGN=left> <TD ALIGN=left>12.7.1 <TD ALIGN=left> Mutex &nbsp;&nbsp 154 <TR> <TD ALIGN=left> <TD ALIGN=left>12.7.2 <TD ALIGN=left> Semaphore &nbsp;&nbsp 155 <TR> <TD ALIGN=left> <TD ALIGN=left>12.7.3 <TD ALIGN=left> Condition Variable &nbsp;&nbsp 155 <TR> <TD ALIGN=left>12.8 <TD ALIGN=left COLSPAN=2> An Example Server Using Threads &nbsp;&nbsp 156 <TR> <TD ALIGN=left>12.9 <TD ALIGN=left COLSPAN=2> Monitor And Control &nbsp;&nbsp 160 <TR> <TD ALIGN=left>12.10 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 161 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 161<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 161<BR> </TABLE> <BR> <BR> <H3>Chapter 13 &nbsp; Single-Thread, Concurrent Servers (TCP) &nbsp;&nbsp; 163</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>13.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 163 <TR> <TD ALIGN=left>13.2 <TD ALIGN=left COLSPAN=2> Data-driven Processing In A Server &nbsp;&nbsp 163 <TR> <TD ALIGN=left>13.3 <TD ALIGN=left COLSPAN=2> Data-Driven Processing With A Single Thread &nbsp;&nbsp 164 <TR> <TD ALIGN=left>13.4 <TD ALIGN=left COLSPAN=2> Process Structure Of A Single-Thread Server &nbsp;&nbsp 165 <TR> <TD ALIGN=left>13.5 <TD ALIGN=left COLSPAN=2> An Example Single-Thread ECHO Server &nbsp;&nbsp 166 <TR> <TD ALIGN=left>13.6 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 168 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 169<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 169<BR> </TABLE> <BR> <BR> <H3>Chapter 14 &nbsp; Multiprotocol Servers (TCP, UDP) &nbsp;&nbsp; 171</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>14.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 171 <TR> <TD ALIGN=left>14.2 <TD ALIGN=left COLSPAN=2> The Motivation For Reducing The Number Of Servers &nbsp;&nbsp 171 <TR> <TD ALIGN=left>14.3 <TD ALIGN=left COLSPAN=2> Multiprotocol Server Design &nbsp;&nbsp 172 <TR> <TD ALIGN=left>14.4 <TD ALIGN=left COLSPAN=2> Process Structure &nbsp;&nbsp 172 <TR> <TD ALIGN=left>14.5 <TD ALIGN=left COLSPAN=2> An Example Multiprotocol DAYTIME Server &nbsp;&nbsp 173 <TR> <TD ALIGN=left>14.6 <TD ALIGN=left COLSPAN=2> The Concept Of Shared Code &nbsp;&nbsp 177 <TR> <TD ALIGN=left>14.7 <TD ALIGN=left COLSPAN=2> Concurrent Multiprotocol Servers &nbsp;&nbsp 177 <TR> <TD ALIGN=left>14.8 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 178 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 178<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 178<BR> </TABLE> <BR> <BR> <H3>Chapter 15 &nbsp; Multiservice Servers (TCP, UDP) &nbsp;&nbsp; 179</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>15.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 179 <TR> <TD ALIGN=left>15.2 <TD ALIGN=left COLSPAN=2> Consolidating Servers &nbsp;&nbsp 179 <TR> <TD ALIGN=left>15.3 <TD ALIGN=left COLSPAN=2> A Connectionless, Multiservice Server Design &nbsp;&nbsp 180 <TR> <TD ALIGN=left>15.4 <TD ALIGN=left COLSPAN=2> A Connection-Oriented, Multiservice Server Design &nbsp;&nbsp 181 <TR> <TD ALIGN=left>15.5 <TD ALIGN=left COLSPAN=2> A Concurrent, Connection-Oriented, Multiservice Server &nbsp;&nbsp 182 <TR> <TD ALIGN=left>15.6 <TD ALIGN=left COLSPAN=2> A Single-Thread, Multiservice Server Implementation &nbsp;&nbsp 182 <TR> <TD ALIGN=left>15.7 <TD ALIGN=left COLSPAN=2> Invoking Separate Programs From A Multiservice Server &nbsp;&nbsp 183 <TR> <TD ALIGN=left>15.8 <TD ALIGN=left COLSPAN=2> Multiservice, Multiprotocol Designs &nbsp;&nbsp 185 <TR> <TD ALIGN=left>15.9 <TD ALIGN=left COLSPAN=2> An Example Multiservice Server &nbsp;&nbsp 185 <TR> <TD ALIGN=left>15.10 <TD ALIGN=left COLSPAN=2> Static and Dynamic Server Configuration &nbsp;&nbsp 192 <TR> <TD ALIGN=left>15.11 <TD ALIGN=left COLSPAN=2> The Super Server, Inetd &nbsp;&nbsp 193 <TR> <TD ALIGN=left>15.12 <TD ALIGN=left COLSPAN=2> An Example Inetd Server &nbsp;&nbsp 195 <TR> <TD ALIGN=left>15.13 <TD ALIGN=left COLSPAN=2> A List Of Server Variations &nbsp;&nbsp 197 <TR> <TD ALIGN=left>15.14 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 197 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 198<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 198<BR> </TABLE> <BR> <BR> <H3>Chapter 16 &nbsp; Uniform, Efficient Management Of Server Concurrency &nbsp;&nbsp; 199</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>16.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 199 <TR> <TD ALIGN=left>16.2 <TD ALIGN=left COLSPAN=2> Choosing Between An Iterative And A Concurrent Design &nbsp;&nbsp 199 <TR> <TD ALIGN=left>16.3 <TD ALIGN=left COLSPAN=2> Level Of Concurrency &nbsp;&nbsp 200 <TR> <TD ALIGN=left>16.4 <TD ALIGN=left COLSPAN=2> Demand-Driven Concurrency &nbsp;&nbsp 201 <TR> <TD ALIGN=left>16.5 <TD ALIGN=left COLSPAN=2> The Cost Of Concurrency &nbsp;&nbsp 201 <TR> <TD ALIGN=left>16.6 <TD ALIGN=left COLSPAN=2> Overhead And Delay &nbsp;&nbsp 202 <TR> <TD ALIGN=left>16.7 <TD ALIGN=left COLSPAN=2> Small Delays Can Matter &nbsp;&nbsp 202 <TR> <TD ALIGN=left>16.8 <TD ALIGN=left COLSPAN=2> Slave Preallocation &nbsp;&nbsp 204 <TR> <TD ALIGN=left> <TD ALIGN=left>16.8.1 <TD ALIGN=left> Preallocation In Linux &nbsp;&nbsp 204 <TR> <TD ALIGN=left> <TD ALIGN=left>16.8.2 <TD ALIGN=left> Preallocation In A Connection-Oriented Server &nbsp;&nbsp 205 <TR> <TD ALIGN=left> <TD ALIGN=left>16.8.3 <TD ALIGN=left> Mutex, File Locking, and Concurrent Calls To Accept &nbsp;&nbsp 206 <TR> <TD ALIGN=left> <TD ALIGN=left>16.8.4 <TD ALIGN=left> Preallocation In A Connectionless Server &nbsp;&nbsp 207 <TR> <TD ALIGN=left> <TD ALIGN=left>16.8.5 <TD ALIGN=left> Preallocation, Bursty Traffic, And NFS &nbsp;&nbsp 208 <TR> <TD ALIGN=left> <TD ALIGN=left>16.8.6 <TD ALIGN=left> Preallocation On A Multiprocessor &nbsp;&nbsp 208 <TR> <TD ALIGN=left>16.9 <TD ALIGN=left COLSPAN=2> Delayed Slave Allocation &nbsp;&nbsp 208 <TR> <TD ALIGN=left>16.10 <TD ALIGN=left COLSPAN=2> The Uniform Basis For Both Techniques &nbsp;&nbsp 210 <TR> <TD ALIGN=left>16.11 <TD ALIGN=left COLSPAN=2> Combining Techniques &nbsp;&nbsp 210 <TR> <TD ALIGN=left>16.12 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 211 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 211<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 211<BR> </TABLE> <BR> <BR> <H3>Chapter 17 &nbsp; Concurrency In Clients &nbsp;&nbsp; 213</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>17.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 213 <TR> <TD ALIGN=left>17.2 <TD ALIGN=left COLSPAN=2> The Advantages Of Concurrency &nbsp;&nbsp 213 <TR> <TD ALIGN=left>17.3 <TD ALIGN=left COLSPAN=2> The Motivation For Exercising Control &nbsp;&nbsp 214 <TR> <TD ALIGN=left>17.4 <TD ALIGN=left COLSPAN=2> Concurrent Contact With Multiple Servers &nbsp;&nbsp 215 <TR> <TD ALIGN=left>17.5 <TD ALIGN=left COLSPAN=2> Implementing Concurrent Clients &nbsp;&nbsp 216 <TR> <TD ALIGN=left>17.6 <TD ALIGN=left COLSPAN=2> Single-Thread Implementations &nbsp;&nbsp 217 <TR> <TD ALIGN=left>17.7 <TD ALIGN=left COLSPAN=2> An Example Concurrent Client That Uses ECHO &nbsp;&nbsp 218 <TR> <TD ALIGN=left>17.8 <TD ALIGN=left COLSPAN=2> Execution Of The Concurrent Client &nbsp;&nbsp 222 <TR> <TD ALIGN=left>17.9 <TD ALIGN=left COLSPAN=2> Concurrency In The Example Code &nbsp;&nbsp 224 <TR> <TD ALIGN=left>17.10 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 224 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 224<BR> </TABLE> <BR> <BR> <H3>Chapter 18 &nbsp; Tunneling At The Transport And Application Levels &nbsp;&nbsp; 227</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>18.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 227 <TR> <TD ALIGN=left>18.2 <TD ALIGN=left COLSPAN=2> Multiprotocol Environments &nbsp;&nbsp 227 <TR> <TD ALIGN=left>18.3 <TD ALIGN=left COLSPAN=2> Mixing Network Technologies &nbsp;&nbsp 229 <TR> <TD ALIGN=left>18.4 <TD ALIGN=left COLSPAN=2> Dynamic Circuit Allocation &nbsp;&nbsp 230 <TR> <TD ALIGN=left>18.5 <TD ALIGN=left COLSPAN=2> Encapsulation And Tunneling &nbsp;&nbsp 231 <TR> <TD ALIGN=left>18.6 <TD ALIGN=left COLSPAN=2> Tunneling Through An IP Internet &nbsp;&nbsp 232 <TR> <TD ALIGN=left>18.7 <TD ALIGN=left COLSPAN=2> Application-Level Tunneling Between Clients And Servers &nbsp;&nbsp 232 <TR> <TD ALIGN=left>18.8 <TD ALIGN=left COLSPAN=2> Tunneling, Encapsulation, And Dialup Phone Lines &nbsp;&nbsp 233 <TR> <TD ALIGN=left>18.9 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 234 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 234<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 235<BR> </TABLE> <BR> <BR> <H3>Chapter 19 &nbsp; Application Level Gateways &nbsp;&nbsp; 237</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>19.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 237 <TR> <TD ALIGN=left>19.2 <TD ALIGN=left COLSPAN=2> Clients And Servers In Constrained Environments &nbsp;&nbsp 237 <TR> <TD ALIGN=left> <TD ALIGN=left>19.2.1 <TD ALIGN=left> The Reality Of Limited Access &nbsp;&nbsp 237 <TR> <TD ALIGN=left> <TD ALIGN=left>19.2.2 <TD ALIGN=left> Computers With Limited Functionality &nbsp;&nbsp 238 <TR> <TD ALIGN=left> <TD ALIGN=left>19.2.3 <TD ALIGN=left> Connectivity Constraints That Arise From Security &nbsp;&nbsp 238 <TR> <TD ALIGN=left>19.3 <TD ALIGN=left COLSPAN=2> Using Application Gateways &nbsp;&nbsp 238 <TR> <TD ALIGN=left>19.4 <TD ALIGN=left COLSPAN=2> Interoperability Through A Mail Gateway &nbsp;&nbsp 240 <TR> <TD ALIGN=left>19.5 <TD ALIGN=left COLSPAN=2> Implementation Of A Mail Gateway &nbsp;&nbsp 240 <TR> <TD ALIGN=left>19.6 <TD ALIGN=left COLSPAN=2> A Comparison Of Application Gateways And Tunneling &nbsp;&nbsp 241 <TR> <TD ALIGN=left>19.7 <TD ALIGN=left COLSPAN=2> Application Gateways And Limited Internet Connectivity &nbsp;&nbsp 243 <TR> <TD ALIGN=left>19.8 <TD ALIGN=left COLSPAN=2> Application Gateways Used For Security &nbsp;&nbsp 245 <TR> <TD ALIGN=left>19.9 <TD ALIGN=left COLSPAN=2> Application Gateways And The Extra Hop Problem &nbsp;&nbsp 245 <TR> <TD ALIGN=left>19.10 <TD ALIGN=left COLSPAN=2> An Example Application Gateway &nbsp;&nbsp 247 <TR> <TD ALIGN=left>19.11 <TD ALIGN=left COLSPAN=2> Implementation Of An Application Gateway &nbsp;&nbsp 248 <TR> <TD ALIGN=left>19.12 <TD ALIGN=left COLSPAN=2> Code For The Application Gateway &nbsp;&nbsp 250 <TR> <TD ALIGN=left>19.13 <TD ALIGN=left COLSPAN=2> An Example Gateway Exchange &nbsp;&nbsp 251 <TR> <TD ALIGN=left>19.14 <TD ALIGN=left COLSPAN=2> Using Rfcd With .forward Or Slocal &nbsp;&nbsp 252 <TR> <TD ALIGN=left>19.15 <TD ALIGN=left COLSPAN=2> A General-Purpose Application Gateway &nbsp;&nbsp 253 <TR> <TD ALIGN=left>19.16 <TD ALIGN=left COLSPAN=2> Operation Of SLIRP &nbsp;&nbsp 253 <TR> <TD ALIGN=left>19.17 <TD ALIGN=left COLSPAN=2> How SLIRP Handles Connections &nbsp;&nbsp 254 <TR> <TD ALIGN=left>19.18 <TD ALIGN=left COLSPAN=2> IP Addressing And SLIRP &nbsp;&nbsp 254 <TR> <TD ALIGN=left>19.19 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 255 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 256<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 256<BR> </TABLE> <BR> <BR> <H3>Chapter 20 &nbsp; External Data Representation (XDR) &nbsp;&nbsp; 257</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>20.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 257 <TR> <TD ALIGN=left>20.2 <TD ALIGN=left COLSPAN=2> Representations Of Data &nbsp;&nbsp 257 <TR> <TD ALIGN=left>20.3 <TD ALIGN=left COLSPAN=2> Asymmetric Conversion And The N-Squared Problem &nbsp;&nbsp 258 <TR> <TD ALIGN=left>20.4 <TD ALIGN=left COLSPAN=2> Network Standard Byte Order &nbsp;&nbsp 259 <TR> <TD ALIGN=left>20.5 <TD ALIGN=left COLSPAN=2> A De Facto Standard External Data Representation &nbsp;&nbsp 261 <TR> <TD ALIGN=left>20.6 <TD ALIGN=left COLSPAN=2> XDR Data Types &nbsp;&nbsp 261 <TR> <TD ALIGN=left>20.7 <TD ALIGN=left COLSPAN=2> Implicit Types &nbsp;&nbsp 263 <TR> <TD ALIGN=left>20.8 <TD ALIGN=left COLSPAN=2> Software Support For Using XDR &nbsp;&nbsp 263 <TR> <TD ALIGN=left>20.9 <TD ALIGN=left COLSPAN=2> XDR Library Routines &nbsp;&nbsp 263 <TR> <TD ALIGN=left>20.10 <TD ALIGN=left COLSPAN=2> Building A Message One Piece At A Time &nbsp;&nbsp 264 <TR> <TD ALIGN=left>20.11 <TD ALIGN=left COLSPAN=2> Conversion Routines In The XDR Library &nbsp;&nbsp 265 <TR> <TD ALIGN=left>20.12 <TD ALIGN=left COLSPAN=2> XDR Streams, I/O, and TCP &nbsp;&nbsp 267 <TR> <TD ALIGN=left>20.13 <TD ALIGN=left COLSPAN=2> Records, Record Boundaries, And Datagram I/O &nbsp;&nbsp 268 <TR> <TD ALIGN=left>20.14 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 268 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 269<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 269<BR> </TABLE> <BR> <BR> <H3>Chapter 21 &nbsp; Remote Procedure Call Concept (RPC) &nbsp;&nbsp; 271</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>21.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 271 <TR> <TD ALIGN=left>21.2 <TD ALIGN=left COLSPAN=2> Remote Procedure Call Model &nbsp;&nbsp 271 <TR> <TD ALIGN=left>21.3 <TD ALIGN=left COLSPAN=2> Two Paradigms For Building Distributed Programs &nbsp;&nbsp 272 <TR> <TD ALIGN=left>21.4 <TD ALIGN=left COLSPAN=2> A Conceptual Model For Conventional Procedure Calls &nbsp;&nbsp 273 <TR> <TD ALIGN=left>21.5 <TD ALIGN=left COLSPAN=2> An Extension Of the Procedural Model &nbsp;&nbsp 274 <TR> <TD ALIGN=left>21.6 <TD ALIGN=left COLSPAN=2> Execution Of Conventional Procedure Call And Return &nbsp;&nbsp 274 <TR> <TD ALIGN=left>21.7 <TD ALIGN=left COLSPAN=2> The Procedural Model In Distributed Systems &nbsp;&nbsp 275 <TR> <TD ALIGN=left>21.8 <TD ALIGN=left COLSPAN=2> Analogy Between Client-Server And RPC &nbsp;&nbsp 276 <TR> <TD ALIGN=left>21.9 <TD ALIGN=left COLSPAN=2> Distributed Computation As A Program &nbsp;&nbsp 277 <TR> <TD ALIGN=left>21.10 <TD ALIGN=left COLSPAN=2> Sun Microsystems' Remote Procedure Call Definition &nbsp;&nbsp 278 <TR> <TD ALIGN=left>21.11 <TD ALIGN=left COLSPAN=2> Remote Programs And Procedures &nbsp;&nbsp 278 <TR> <TD ALIGN=left>21.12 <TD ALIGN=left COLSPAN=2> Reducing The Number Of Arguments &nbsp;&nbsp 279 <TR> <TD ALIGN=left>21.13 <TD ALIGN=left COLSPAN=2> Identifying Remote Programs And Procedures &nbsp;&nbsp 279 <TR> <TD ALIGN=left>21.14 <TD ALIGN=left COLSPAN=2> Accommodating Multiple Versions Of A Remote Program &nbsp;&nbsp 280 <TR> <TD ALIGN=left>21.15 <TD ALIGN=left COLSPAN=2> Mutual Exclusion For Procedures In A Remote Program &nbsp;&nbsp 281 <TR> <TD ALIGN=left>21.16 <TD ALIGN=left COLSPAN=2> Communication Semantics &nbsp;&nbsp 282 <TR> <TD ALIGN=left>21.17 <TD ALIGN=left COLSPAN=2> At Least Once Semantics &nbsp;&nbsp 282 <TR> <TD ALIGN=left>21.18 <TD ALIGN=left COLSPAN=2> RPC Retransmission &nbsp;&nbsp 283 <TR> <TD ALIGN=left>21.19 <TD ALIGN=left COLSPAN=2> Mapping A Remote Program To A Protocol Port &nbsp;&nbsp 283 <TR> <TD ALIGN=left>21.20 <TD ALIGN=left COLSPAN=2> Dynamic Port Mapping &nbsp;&nbsp 284 <TR> <TD ALIGN=left>21.21 <TD ALIGN=left COLSPAN=2> RPC Port Mapper Algorithm &nbsp;&nbsp 285 <TR> <TD ALIGN=left>21.22 <TD ALIGN=left COLSPAN=2> ONC RPC Message Format &nbsp;&nbsp 287 <TR> <TD ALIGN=left>21.23 <TD ALIGN=left COLSPAN=2> Marshaling Arguments For A Remote Procedure &nbsp;&nbsp 288 <TR> <TD ALIGN=left>21.24 <TD ALIGN=left COLSPAN=2> Authentication &nbsp;&nbsp 288 <TR> <TD ALIGN=left>21.25 <TD ALIGN=left COLSPAN=2> An Example Of RPC Message Representation &nbsp;&nbsp 290 <TR> <TD ALIGN=left>21.26 <TD ALIGN=left COLSPAN=2> An Example Of The UNIX Authentication Field &nbsp;&nbsp 290 <TR> <TD ALIGN=left>21.27 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 291 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 292<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 292<BR> </TABLE> <BR> <BR> <H3>Chapter 22 &nbsp; Distributed Program Generation (Rpcgen Concept) &nbsp;&nbsp; 295</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>22.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 295 <TR> <TD ALIGN=left>22.2 <TD ALIGN=left COLSPAN=2> Using Remote Procedure Calls &nbsp;&nbsp 296 <TR> <TD ALIGN=left>22.3 <TD ALIGN=left COLSPAN=2> Programming Mechanisms To Support RPC &nbsp;&nbsp 297 <TR> <TD ALIGN=left>22.4 <TD ALIGN=left COLSPAN=2> Dividing A Program Into Local And Remote Procedures &nbsp;&nbsp 298 <TR> <TD ALIGN=left>22.5 <TD ALIGN=left COLSPAN=2> Adding Code For RPC &nbsp;&nbsp 299 <TR> <TD ALIGN=left>22.6 <TD ALIGN=left COLSPAN=2> Stub Procedures &nbsp;&nbsp 299 <TR> <TD ALIGN=left>22.7 <TD ALIGN=left COLSPAN=2> Multiple Remote Procedures And Dispatching &nbsp;&nbsp 300 <TR> <TD ALIGN=left>22.8 <TD ALIGN=left COLSPAN=2> Name Of The Client-Side Stub Procedure &nbsp;&nbsp 301 <TR> <TD ALIGN=left>22.9 <TD ALIGN=left COLSPAN=2> Using Rpcgen To Generate Distributed Programs &nbsp;&nbsp 302 <TR> <TD ALIGN=left>22.10 <TD ALIGN=left COLSPAN=2> Rpcgen Output And Interface Procedures &nbsp;&nbsp 302 <TR> <TD ALIGN=left>22.11 <TD ALIGN=left COLSPAN=2> Rpcgen Input And Output &nbsp;&nbsp 304 <TR> <TD ALIGN=left>22.12 <TD ALIGN=left COLSPAN=2> Using Rpcgen To Build A Client And Server &nbsp;&nbsp 304 <TR> <TD ALIGN=left>22.13 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 305 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 306<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 306<BR> </TABLE> <BR> <BR> <H3>Chapter 23 &nbsp; Distributed Program Generation (Rpcgen Example) &nbsp;&nbsp; 307</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>23.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 307 <TR> <TD ALIGN=left>23.2 <TD ALIGN=left COLSPAN=2> An Example To Illustrate Rpcgen &nbsp;&nbsp 308 <TR> <TD ALIGN=left>23.3 <TD ALIGN=left COLSPAN=2> Dictionary Operations &nbsp;&nbsp 308 <TR> <TD ALIGN=left>23.4 <TD ALIGN=left COLSPAN=2> Eight Steps To A Distributed Application &nbsp;&nbsp 309 <TR> <TD ALIGN=left>23.5 <TD ALIGN=left COLSPAN=2> Step 1: Build A Conventional Application Program &nbsp;&nbsp 310 <TR> <TD ALIGN=left>23.6 <TD ALIGN=left COLSPAN=2> Step 2: Divide The Program Into Two Parts &nbsp;&nbsp 314 <TR> <TD ALIGN=left>23.7 <TD ALIGN=left COLSPAN=2> Step 3: Create An Rpcgen Specification &nbsp;&nbsp 320 <TR> <TD ALIGN=left>23.8 <TD ALIGN=left COLSPAN=2> Step 4: Run Rpcgen &nbsp;&nbsp 322 <TR> <TD ALIGN=left>23.9 <TD ALIGN=left COLSPAN=2> The .h File Produced By Rpcgen &nbsp;&nbsp 322 <TR> <TD ALIGN=left>23.10 <TD ALIGN=left COLSPAN=2> The XDR Conversion File Produced By Rpcgen &nbsp;&nbsp 325 <TR> <TD ALIGN=left>23.11 <TD ALIGN=left COLSPAN=2> The Client Code Produced By Rpcgen &nbsp;&nbsp 326 <TR> <TD ALIGN=left>23.12 <TD ALIGN=left COLSPAN=2> The Server Code Produced By Rpcgen &nbsp;&nbsp 328 <TR> <TD ALIGN=left>23.13 <TD ALIGN=left COLSPAN=2> Step 5: Write Stub Interface Procedures &nbsp;&nbsp 331 <TR> <TD ALIGN=left> <TD ALIGN=left>23.13.1 <TD ALIGN=left> Client-Side Interface Routines &nbsp;&nbsp 331 <TR> <TD ALIGN=left> <TD ALIGN=left>23.13.2 <TD ALIGN=left> Server-Side Interface Routines &nbsp;&nbsp 333 <TR> <TD ALIGN=left>23.14 <TD ALIGN=left COLSPAN=2> Step 6: Compile And Link The Client Program &nbsp;&nbsp 335 <TR> <TD ALIGN=left>23.15 <TD ALIGN=left COLSPAN=2> Step 7: Compile And Link The Server Program &nbsp;&nbsp 339 <TR> <TD ALIGN=left>23.16 <TD ALIGN=left COLSPAN=2> Step 8: Start The Server And Execute The Client &nbsp;&nbsp 341 <TR> <TD ALIGN=left>23.17 <TD ALIGN=left COLSPAN=2> Using The Make Utility &nbsp;&nbsp 341 <TR> <TD ALIGN=left>23.18 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 344 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 345<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 345<BR> </TABLE> <BR> <BR> <H3>Chapter 24 &nbsp; Network File System Concepts (NFS) &nbsp;&nbsp; 347</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>24.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 347 <TR> <TD ALIGN=left>24.2 <TD ALIGN=left COLSPAN=2> Remote File Access Vs. Transfer &nbsp;&nbsp 347 <TR> <TD ALIGN=left>24.3 <TD ALIGN=left COLSPAN=2> Operations On Remote Files &nbsp;&nbsp 348 <TR> <TD ALIGN=left>24.4 <TD ALIGN=left COLSPAN=2> File Access Among Heterogeneous Computers &nbsp;&nbsp 348 <TR> <TD ALIGN=left>24.5 <TD ALIGN=left COLSPAN=2> Stateless Servers &nbsp;&nbsp 349 <TR> <TD ALIGN=left>24.6 <TD ALIGN=left COLSPAN=2> NFS And UNIX File Semantics &nbsp;&nbsp 349 <TR> <TD ALIGN=left>24.7 <TD ALIGN=left COLSPAN=2> Review Of The UNIX File System &nbsp;&nbsp 349 <TR> <TD ALIGN=left> <TD ALIGN=left>24.7.1 <TD ALIGN=left> Basic Definitions &nbsp;&nbsp 350 <TR> <TD ALIGN=left> <TD ALIGN=left>24.7.2 <TD ALIGN=left> A Byte Sequence Without Record Boundaries &nbsp;&nbsp 350 <TR> <TD ALIGN=left> <TD ALIGN=left>24.7.3 <TD ALIGN=left> A File's Owner And Group Identifiers &nbsp;&nbsp 350 <TR> <TD ALIGN=left> <TD ALIGN=left>24.7.4 <TD ALIGN=left> Protection And Access &nbsp;&nbsp 351 <TR> <TD ALIGN=left> <TD ALIGN=left>24.7.5 <TD ALIGN=left> The Open-Read-Write-Close Paradigm &nbsp;&nbsp 352 <TR> <TD ALIGN=left> <TD ALIGN=left>24.7.6 <TD ALIGN=left> Data Transfer &nbsp;&nbsp 353 <TR> <TD ALIGN=left> <TD ALIGN=left>24.7.7 <TD ALIGN=left> Permission To Search A Directory &nbsp;&nbsp 353 <TR> <TD ALIGN=left> <TD ALIGN=left>24.7.8 <TD ALIGN=left> Random Access &nbsp;&nbsp 354 <TR> <TD ALIGN=left> <TD ALIGN=left>24.7.9 <TD ALIGN=left> Seeking Beyond The End Of File &nbsp;&nbsp 354 <TR> <TD ALIGN=left> <TD ALIGN=left>24.7.10 <TD ALIGN=left> File Position And Concurrent Access &nbsp;&nbsp 355 <TR> <TD ALIGN=left> <TD ALIGN=left>24.7.11 <TD ALIGN=left> Semantics Of Write During Concurrent Access &nbsp;&nbsp 356 <TR> <TD ALIGN=left> <TD ALIGN=left>24.7.12 <TD ALIGN=left> File Names And Paths &nbsp;&nbsp 356 <TR> <TD ALIGN=left> <TD ALIGN=left>24.7.13 <TD ALIGN=left> Inode: Information Stored With A File &nbsp;&nbsp 357 <TR> <TD ALIGN=left> <TD ALIGN=left>24.7.14 <TD ALIGN=left> Stat Operation &nbsp;&nbsp 358 <TR> <TD ALIGN=left> <TD ALIGN=left>24.7.15 <TD ALIGN=left> The File Naming Mechanism &nbsp;&nbsp 359 <TR> <TD ALIGN=left> <TD ALIGN=left>24.7.16 <TD ALIGN=left> File System Mounts &nbsp;&nbsp 360 <TR> <TD ALIGN=left> <TD ALIGN=left>24.7.17 <TD ALIGN=left> File Name Resolution &nbsp;&nbsp 362 <TR> <TD ALIGN=left> <TD ALIGN=left>24.7.18 <TD ALIGN=left> Symbolic Links &nbsp;&nbsp 363 <TR> <TD ALIGN=left>24.8 <TD ALIGN=left COLSPAN=2> Files Under NFS &nbsp;&nbsp 363 <TR> <TD ALIGN=left>24.9 <TD ALIGN=left COLSPAN=2> NFS File Types &nbsp;&nbsp 364 <TR> <TD ALIGN=left>24.10 <TD ALIGN=left COLSPAN=2> NFS File Modes &nbsp;&nbsp 364 <TR> <TD ALIGN=left>24.11 <TD ALIGN=left COLSPAN=2> NFS File Attributes &nbsp;&nbsp 365 <TR> <TD ALIGN=left>24.12 <TD ALIGN=left COLSPAN=2> NFS Client And Server &nbsp;&nbsp 366 <TR> <TD ALIGN=left>24.13 <TD ALIGN=left COLSPAN=2> NFS Client Operation &nbsp;&nbsp 367 <TR> <TD ALIGN=left>24.14 <TD ALIGN=left COLSPAN=2> NFS Client And UNIX Systems &nbsp;&nbsp 368 <TR> <TD ALIGN=left>24.15 <TD ALIGN=left COLSPAN=2> NFS Mounts &nbsp;&nbsp 369 <TR> <TD ALIGN=left>24.16 <TD ALIGN=left COLSPAN=2> File Handle &nbsp;&nbsp 370 <TR> <TD ALIGN=left>24.17 <TD ALIGN=left COLSPAN=2> Handles Replace Path Names &nbsp;&nbsp 370 <TR> <TD ALIGN=left>24.18 <TD ALIGN=left COLSPAN=2> File Positioning With A Stateless Server &nbsp;&nbsp 372 <TR> <TD ALIGN=left>24.19 <TD ALIGN=left COLSPAN=2> Operations On Directories &nbsp;&nbsp 372 <TR> <TD ALIGN=left>24.20 <TD ALIGN=left COLSPAN=2> Reading A Directory Statelessly &nbsp;&nbsp 372 <TR> <TD ALIGN=left>24.21 <TD ALIGN=left COLSPAN=2> Multiple Hierarchies In An NFS Server &nbsp;&nbsp 373 <TR> <TD ALIGN=left>24.22 <TD ALIGN=left COLSPAN=2> The Mount Protocol &nbsp;&nbsp 374 <TR> <TD ALIGN=left>24.23 <TD ALIGN=left COLSPAN=2> Transport Protocols For NFS &nbsp;&nbsp 374 <TR> <TD ALIGN=left>24.24 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 375 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 375<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 376<BR> </TABLE> <BR> <BR> <H3>Chapter 25 &nbsp; Network File System Protocols (NFS, Mount) &nbsp;&nbsp; 377</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>25.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 377 <TR> <TD ALIGN=left>25.2 <TD ALIGN=left COLSPAN=2> Using RPC To Define A Protocol &nbsp;&nbsp 377 <TR> <TD ALIGN=left>25.3 <TD ALIGN=left COLSPAN=2> Defining A Protocol With Data Structures And Procedures &nbsp;&nbsp 378 <TR> <TD ALIGN=left>25.4 <TD ALIGN=left COLSPAN=2> NFS Constant, Type, And Data Declarations &nbsp;&nbsp 379 <TR> <TD ALIGN=left> <TD ALIGN=left>25.4.1 <TD ALIGN=left> NFS Constants &nbsp;&nbsp 379 <TR> <TD ALIGN=left> <TD ALIGN=left>25.4.2 <TD ALIGN=left> NFS Typedef Declarations &nbsp;&nbsp 380 <TR> <TD ALIGN=left> <TD ALIGN=left>25.4.3 <TD ALIGN=left> NFS Data Structures &nbsp;&nbsp 380 <TR> <TD ALIGN=left>25.5 <TD ALIGN=left COLSPAN=2> NFS Procedures &nbsp;&nbsp 383 <TR> <TD ALIGN=left>25.6 <TD ALIGN=left COLSPAN=2> Semantics Of NFS Operations &nbsp;&nbsp 385 <TR> <TD ALIGN=left> <TD ALIGN=left>25.6.1 <TD ALIGN=left> NFSPROC3_NULL (Procedure 0) &nbsp;&nbsp 385 <TR> <TD ALIGN=left> <TD ALIGN=left>25.6.2 <TD ALIGN=left> NFSPROC3_GETATTR (Procedure 1) &nbsp;&nbsp 385 <TR> <TD ALIGN=left> <TD ALIGN=left>25.6.3 <TD ALIGN=left> NFSPROC3_SETATTR (Procedure 2) &nbsp;&nbsp 385 <TR> <TD ALIGN=left> <TD ALIGN=left>25.6.4 <TD ALIGN=left> NFSPROC3_LOOKUP (Procedure 3) &nbsp;&nbsp 385 <TR> <TD ALIGN=left> <TD ALIGN=left>25.6.5 <TD ALIGN=left> NFSPROC3_ACCESS (Procedure 4) &nbsp;&nbsp 385 <TR> <TD ALIGN=left> <TD ALIGN=left>25.6.6 <TD ALIGN=left> NFSPROC3_READLINK (Procedure 5) &nbsp;&nbsp 385 <TR> <TD ALIGN=left> <TD ALIGN=left>25.6.7 <TD ALIGN=left> NFSPROC3_READ (Procedure 6) &nbsp;&nbsp 386 <TR> <TD ALIGN=left> <TD ALIGN=left>25.6.8 <TD ALIGN=left> NFSPROC3_WRITE (Procedure 7) &nbsp;&nbsp 386 <TR> <TD ALIGN=left> <TD ALIGN=left>25.6.9 <TD ALIGN=left> NFSPROC3_CREATE (Procedure 8) &nbsp;&nbsp 386 <TR> <TD ALIGN=left> <TD ALIGN=left>25.6.10 <TD ALIGN=left> NFSPROC3_MKDIR (Procedure 9) &nbsp;&nbsp 386 <TR> <TD ALIGN=left> <TD ALIGN=left>25.6.11 <TD ALIGN=left> NFSPROC3_SYMLINK (Procedure 10) &nbsp;&nbsp 386 <TR> <TD ALIGN=left> <TD ALIGN=left>25.6.12 <TD ALIGN=left> NFSPROC3_MKNOD (Procedure 11) &nbsp;&nbsp 386 <TR> <TD ALIGN=left> <TD ALIGN=left>25.6.13 <TD ALIGN=left> NFSPROC3_REMOVE (Procedure 12) &nbsp;&nbsp 387 <TR> <TD ALIGN=left> <TD ALIGN=left>25.6.14 <TD ALIGN=left> NFSPROC3_RMDIR (Procedure 13) &nbsp;&nbsp 387 <TR> <TD ALIGN=left> <TD ALIGN=left>25.6.15 <TD ALIGN=left> NFSPROC3_RENAME (Procedure 14) &nbsp;&nbsp 387 <TR> <TD ALIGN=left> <TD ALIGN=left>25.6.16 <TD ALIGN=left> NFSPROC3_LINK (Procedure 15) &nbsp;&nbsp 387 <TR> <TD ALIGN=left> <TD ALIGN=left>25.6.17 <TD ALIGN=left> NFSPROC3_READDIR (Procedure 16) &nbsp;&nbsp 387 <TR> <TD ALIGN=left> <TD ALIGN=left>25.6.18 <TD ALIGN=left> NFSPROC3_READDIRPLUS (procedure 17) &nbsp;&nbsp 388 <TR> <TD ALIGN=left> <TD ALIGN=left>25.6.19 <TD ALIGN=left> NFSPROC3_FSSTAT (Procedure 18) &nbsp;&nbsp 388 <TR> <TD ALIGN=left> <TD ALIGN=left>25.6.20 <TD ALIGN=left> NFSPROC3_FSINFO (Procedure 19) &nbsp;&nbsp 388 <TR> <TD ALIGN=left> <TD ALIGN=left>25.6.21 <TD ALIGN=left> NFSPROC3_PATHCONF (Procedure 20) &nbsp;&nbsp 388 <TR> <TD ALIGN=left> <TD ALIGN=left>25.6.22 <TD ALIGN=left> NFSPROC3_COMMIT (Procedure 21) &nbsp;&nbsp 389 <TR> <TD ALIGN=left>25.7 <TD ALIGN=left COLSPAN=2> The Mount Protocol &nbsp;&nbsp 389 <TR> <TD ALIGN=left> <TD ALIGN=left>25.7.1 <TD ALIGN=left> Mount Constant Definitions &nbsp;&nbsp 389 <TR> <TD ALIGN=left> <TD ALIGN=left>25.7.2 <TD ALIGN=left> Mount Type Definitions &nbsp;&nbsp 389 <TR> <TD ALIGN=left> <TD ALIGN=left>25.7.3 <TD ALIGN=left> Mount Data Structures &nbsp;&nbsp 390 <TR> <TD ALIGN=left>25.8 <TD ALIGN=left COLSPAN=2> Procedures In The Mount Protocol &nbsp;&nbsp 391 <TR> <TD ALIGN=left>25.9 <TD ALIGN=left COLSPAN=2> Semantics of Mount Operations &nbsp;&nbsp 391 <TR> <TD ALIGN=left> <TD ALIGN=left>25.9.1 <TD ALIGN=left> MOUNTPROC3_NULL (Procedure 0) &nbsp;&nbsp 392 <TR> <TD ALIGN=left> <TD ALIGN=left>25.9.2 <TD ALIGN=left> MOUNTPROC3_MNT (Procedure 1) &nbsp;&nbsp 392 <TR> <TD ALIGN=left> <TD ALIGN=left>25.9.3 <TD ALIGN=left> MOUNTPROC3_DUMP (Procedure 2) &nbsp;&nbsp 392 <TR> <TD ALIGN=left> <TD ALIGN=left>25.9.4 <TD ALIGN=left> MOUNTPROC3_UMNT (Procedure 3) &nbsp;&nbsp 392 <TR> <TD ALIGN=left> <TD ALIGN=left>25.9.5 <TD ALIGN=left> MOUNTPROC3_UMNTALL (Procedure 4) &nbsp;&nbsp 392 <TR> <TD ALIGN=left> <TD ALIGN=left>25.9.6 <TD ALIGN=left> MOUNTPROC3_EXPORT (Procedure 5) &nbsp;&nbsp 392 <TR> <TD ALIGN=left>25.10 <TD ALIGN=left COLSPAN=2> NFS And Mount Authentication &nbsp;&nbsp 393 <TR> <TD ALIGN=left>25.11 <TD ALIGN=left COLSPAN=2> File Locking &nbsp;&nbsp 394 <TR> <TD ALIGN=left>25.12 <TD ALIGN=left COLSPAN=2> Changes In NFS Between Versions 3 And 4 &nbsp;&nbsp 394 <TR> <TD ALIGN=left>25.13 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 395 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 395<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 396<BR> </TABLE> <BR> <BR> <H3>Chapter 26 &nbsp; A TELNET Client (Program Structure) &nbsp;&nbsp; 397</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>26.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 397 <TR> <TD ALIGN=left>26.2 <TD ALIGN=left COLSPAN=2> Overview &nbsp;&nbsp 398 <TR> <TD ALIGN=left> <TD ALIGN=left>26.2.1 <TD ALIGN=left> The User's Terminal &nbsp;&nbsp 398 <TR> <TD ALIGN=left> <TD ALIGN=left>26.2.2 <TD ALIGN=left> Command And Control Information &nbsp;&nbsp 398 <TR> <TD ALIGN=left> <TD ALIGN=left>26.2.3 <TD ALIGN=left> Terminals, Windows, and Files &nbsp;&nbsp 398 <TR> <TD ALIGN=left> <TD ALIGN=left>26.2.4 <TD ALIGN=left> The Need For Concurrency &nbsp;&nbsp 399 <TR> <TD ALIGN=left> <TD ALIGN=left>26.2.5 <TD ALIGN=left> A Process Model For A TELNET Client &nbsp;&nbsp 400 <TR> <TD ALIGN=left>26.3 <TD ALIGN=left COLSPAN=2> A TELNET Client Algorithm &nbsp;&nbsp 400 <TR> <TD ALIGN=left>26.4 <TD ALIGN=left COLSPAN=2> Terminal I/O In Linux &nbsp;&nbsp 401 <TR> <TD ALIGN=left> <TD ALIGN=left>26.4.1 <TD ALIGN=left> Controlling A Device Driver &nbsp;&nbsp 402 <TR> <TD ALIGN=left>26.5 <TD ALIGN=left COLSPAN=2> Establishing Terminal Modes &nbsp;&nbsp 403 <TR> <TD ALIGN=left>26.6 <TD ALIGN=left COLSPAN=2> Global Variable Used For Stored State &nbsp;&nbsp 405 <TR> <TD ALIGN=left>26.7 <TD ALIGN=left COLSPAN=2> Restoring Terminal Modes Before Exit &nbsp;&nbsp 406 <TR> <TD ALIGN=left>26.8 <TD ALIGN=left COLSPAN=2> Client Suspension And Resumption &nbsp;&nbsp 407 <TR> <TD ALIGN=left>26.9 <TD ALIGN=left COLSPAN=2> Finite State Machine Specification &nbsp;&nbsp 408 <TR> <TD ALIGN=left>26.10 <TD ALIGN=left COLSPAN=2> Embedding Commands In A TELNET Data Stream &nbsp;&nbsp 409 <TR> <TD ALIGN=left>26.11 <TD ALIGN=left COLSPAN=2> Option Negotiation &nbsp;&nbsp 410 <TR> <TD ALIGN=left>26.12 <TD ALIGN=left COLSPAN=2> Request/Offer Symmetry &nbsp;&nbsp 410 <TR> <TD ALIGN=left>26.13 <TD ALIGN=left COLSPAN=2> TELNET Character Definitions &nbsp;&nbsp 411 <TR> <TD ALIGN=left>26.14 <TD ALIGN=left COLSPAN=2> A Finite State Machine For Data From The Server &nbsp;&nbsp 412 <TR> <TD ALIGN=left>26.15 <TD ALIGN=left COLSPAN=2> Transitions Among States &nbsp;&nbsp 413 <TR> <TD ALIGN=left>26.16 <TD ALIGN=left COLSPAN=2> A Finite State Machine Implementation &nbsp;&nbsp 415 <TR> <TD ALIGN=left>26.17 <TD ALIGN=left COLSPAN=2> A Compact FSM Representation &nbsp;&nbsp 415 <TR> <TD ALIGN=left>26.18 <TD ALIGN=left COLSPAN=2> Keeping The Compact Representation At Run-Time &nbsp;&nbsp 417 <TR> <TD ALIGN=left>26.19 <TD ALIGN=left COLSPAN=2> Implementation Of A Compact Representation &nbsp;&nbsp 417 <TR> <TD ALIGN=left>26.20 <TD ALIGN=left COLSPAN=2> Building An FSM Transition Matrix &nbsp;&nbsp 419 <TR> <TD ALIGN=left>26.21 <TD ALIGN=left COLSPAN=2> The Socket Output Finite State Machine &nbsp;&nbsp 421 <TR> <TD ALIGN=left>26.22 <TD ALIGN=left COLSPAN=2> Definitions For The Socket Output FSM &nbsp;&nbsp 423 <TR> <TD ALIGN=left>26.23 <TD ALIGN=left COLSPAN=2> The Option Subnegotiation Finite State Machine &nbsp;&nbsp 424 <TR> <TD ALIGN=left>26.24 <TD ALIGN=left COLSPAN=2> Definitions For The Option Subnegotiation FSM &nbsp;&nbsp 425 <TR> <TD ALIGN=left>26.25 <TD ALIGN=left COLSPAN=2> FSM Initialization &nbsp;&nbsp 426 <TR> <TD ALIGN=left>26.26 <TD ALIGN=left COLSPAN=2> Arguments For The TELNET Client &nbsp;&nbsp 427 <TR> <TD ALIGN=left>26.27 <TD ALIGN=left COLSPAN=2> The Heart Of The TELNET Client &nbsp;&nbsp 428 <TR> <TD ALIGN=left>26.28 <TD ALIGN=left COLSPAN=2> Implementation Of The Main FSM &nbsp;&nbsp 432 <TR> <TD ALIGN=left>26.29 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 433 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 433<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 434<BR> </TABLE> <BR> <BR> <H3>Chapter 27 &nbsp; A TELNET Client (Implementation Details) &nbsp;&nbsp; 435</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>27.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 435 <TR> <TD ALIGN=left>27.2 <TD ALIGN=left COLSPAN=2> The FSM Action Procedures &nbsp;&nbsp 435 <TR> <TD ALIGN=left>27.3 <TD ALIGN=left COLSPAN=2> Recording The Type Of An Option Request &nbsp;&nbsp 436 <TR> <TD ALIGN=left>27.4 <TD ALIGN=left COLSPAN=2> Performing No Operation &nbsp;&nbsp 437 <TR> <TD ALIGN=left>27.5 <TD ALIGN=left COLSPAN=2> Responding To WILL/WONT For The Echo Option &nbsp;&nbsp 437 <TR> <TD ALIGN=left>27.6 <TD ALIGN=left COLSPAN=2> Responding To WILL/WONT For Unsupported Options &nbsp;&nbsp 439 <TR> <TD ALIGN=left>27.7 <TD ALIGN=left COLSPAN=2> Responding To WILL/WONT For The No Go-Ahead Option &nbsp;&nbsp 439 <TR> <TD ALIGN=left>27.8 <TD ALIGN=left COLSPAN=2> Generating DO/DONT For Binary Transmission &nbsp;&nbsp 441 <TR> <TD ALIGN=left>27.9 <TD ALIGN=left COLSPAN=2> Responding To DO/DONT For Unsupported Options &nbsp;&nbsp 442 <TR> <TD ALIGN=left>27.10 <TD ALIGN=left COLSPAN=2> Responding To DO/DONT For Transmit Binary Option &nbsp;&nbsp 442 <TR> <TD ALIGN=left>27.11 <TD ALIGN=left COLSPAN=2> Responding To DO/DONT For The Terminal Type Option &nbsp;&nbsp 444 <TR> <TD ALIGN=left>27.12 <TD ALIGN=left COLSPAN=2> Option Subnegotiation &nbsp;&nbsp 445 <TR> <TD ALIGN=left>27.13 <TD ALIGN=left COLSPAN=2> Sending Terminal Type Information &nbsp;&nbsp 446 <TR> <TD ALIGN=left>27.14 <TD ALIGN=left COLSPAN=2> Terminating Subnegotiation &nbsp;&nbsp 448 <TR> <TD ALIGN=left>27.15 <TD ALIGN=left COLSPAN=2> Sending A Character To The Server &nbsp;&nbsp 448 <TR> <TD ALIGN=left>27.16 <TD ALIGN=left COLSPAN=2> Displaying Incoming Data On The User's Terminal &nbsp;&nbsp 450 <TR> <TD ALIGN=left>27.17 <TD ALIGN=left COLSPAN=2> Using Termcap To Control The User's Terminal &nbsp;&nbsp 453 <TR> <TD ALIGN=left>27.18 <TD ALIGN=left COLSPAN=2> Writing A Block Of Data To The Server &nbsp;&nbsp 455 <TR> <TD ALIGN=left>27.19 <TD ALIGN=left COLSPAN=2> Interacting With The Client Process &nbsp;&nbsp 456 <TR> <TD ALIGN=left>27.20 <TD ALIGN=left COLSPAN=2> Responding To Illegal Commands &nbsp;&nbsp 456 <TR> <TD ALIGN=left>27.21 <TD ALIGN=left COLSPAN=2> Scripting To A File &nbsp;&nbsp 457 <TR> <TD ALIGN=left>27.22 <TD ALIGN=left COLSPAN=2> Implementation Of Scripting &nbsp;&nbsp 457 <TR> <TD ALIGN=left>27.23 <TD ALIGN=left COLSPAN=2> Initialization Of Scripting &nbsp;&nbsp 458 <TR> <TD ALIGN=left>27.24 <TD ALIGN=left COLSPAN=2> Collecting Characters Of The Script File Name &nbsp;&nbsp 459 <TR> <TD ALIGN=left>27.25 <TD ALIGN=left COLSPAN=2> Opening A Script File &nbsp;&nbsp 460 <TR> <TD ALIGN=left>27.26 <TD ALIGN=left COLSPAN=2> Terminating Scripting &nbsp;&nbsp 462 <TR> <TD ALIGN=left>27.27 <TD ALIGN=left COLSPAN=2> Printing Status Information &nbsp;&nbsp 463 <TR> <TD ALIGN=left>27.28 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 464 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 464<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 465<BR> </TABLE> <BR> <BR> <H3>Chapter 28 &nbsp; Streaming Audio And Video Transport (RTP Concept And Design) &nbsp;&nbsp; 467</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>28.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 467 <TR> <TD ALIGN=left>28.2 <TD ALIGN=left COLSPAN=2> Streaming Service &nbsp;&nbsp 467 <TR> <TD ALIGN=left>28.3 <TD ALIGN=left COLSPAN=2> Real-Time Delivery &nbsp;&nbsp 468 <TR> <TD ALIGN=left>28.4 <TD ALIGN=left COLSPAN=2> Protocol Compensation For Jitter &nbsp;&nbsp 468 <TR> <TD ALIGN=left>28.5 <TD ALIGN=left COLSPAN=2> Retransmission, Loss, And Recovery &nbsp;&nbsp 469 <TR> <TD ALIGN=left>28.6 <TD ALIGN=left COLSPAN=2> Real-Time Transport Protocol &nbsp;&nbsp 470 <TR> <TD ALIGN=left>28.7 <TD ALIGN=left COLSPAN=2> Stream Translation And Mixing &nbsp;&nbsp 471 <TR> <TD ALIGN=left>28.8 <TD ALIGN=left COLSPAN=2> Delayed Playback And Jitter Buffers &nbsp;&nbsp 471 <TR> <TD ALIGN=left>28.9 <TD ALIGN=left COLSPAN=2> RTP Control Protocol (RTCP) &nbsp;&nbsp 472 <TR> <TD ALIGN=left>28.10 <TD ALIGN=left COLSPAN=2> Synchronizing Multiple Streams &nbsp;&nbsp 474 <TR> <TD ALIGN=left>28.11 <TD ALIGN=left COLSPAN=2> RTP Transport And Many-To-Many Transmission &nbsp;&nbsp 475 <TR> <TD ALIGN=left>28.12 <TD ALIGN=left COLSPAN=2> Sessions, Streams, Protocol Ports, And Demultiplexing &nbsp;&nbsp 476 <TR> <TD ALIGN=left>28.13 <TD ALIGN=left COLSPAN=2> Basic Approaches To Encoding &nbsp;&nbsp 477 <TR> <TD ALIGN=left>28.14 <TD ALIGN=left COLSPAN=2> Conceptual Organization Of RTP Software &nbsp;&nbsp 478 <TR> <TD ALIGN=left>28.15 <TD ALIGN=left COLSPAN=2> Process|/|Thread Structure &nbsp;&nbsp 479 <TR> <TD ALIGN=left>28.16 <TD ALIGN=left COLSPAN=2> Semantics Of The API &nbsp;&nbsp 481 <TR> <TD ALIGN=left>28.17 <TD ALIGN=left COLSPAN=2> Jitter Buffer Design And Rebuffering &nbsp;&nbsp 482 <TR> <TD ALIGN=left>28.18 <TD ALIGN=left COLSPAN=2> Event Handling &nbsp;&nbsp 483 <TR> <TD ALIGN=left>28.19 <TD ALIGN=left COLSPAN=2> Playback Anomaly And Timestamp Complications &nbsp;&nbsp 483 <TR> <TD ALIGN=left>28.20 <TD ALIGN=left COLSPAN=2> Size of An Example Real-Time Library &nbsp;&nbsp 484 <TR> <TD ALIGN=left>28.21 <TD ALIGN=left COLSPAN=2> An Example MP3 Player &nbsp;&nbsp 484 <TR> <TD ALIGN=left>28.22 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 485 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 486<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 486<BR> </TABLE> <BR> <BR> <H3>Chapter 29 &nbsp; Streaming Audio And Video Transport (Example RTP Implementation) &nbsp;&nbsp; 487</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>29.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 487 <TR> <TD ALIGN=left>29.2 <TD ALIGN=left COLSPAN=2> An Integrated Implementation &nbsp;&nbsp 487 <TR> <TD ALIGN=left>29.3 <TD ALIGN=left COLSPAN=2> Program Architecture &nbsp;&nbsp 488 <TR> <TD ALIGN=left>29.4 <TD ALIGN=left COLSPAN=2> RTP Definitions &nbsp;&nbsp 488 <TR> <TD ALIGN=left>29.5 <TD ALIGN=left COLSPAN=2> Manipulation Of Time Values &nbsp;&nbsp 492 <TR> <TD ALIGN=left>29.6 <TD ALIGN=left COLSPAN=2> RTP Sequence Space Processing &nbsp;&nbsp 493 <TR> <TD ALIGN=left>29.7 <TD ALIGN=left COLSPAN=2> RTP Packet Queue Manipulation &nbsp;&nbsp 494 <TR> <TD ALIGN=left>29.8 <TD ALIGN=left COLSPAN=2> RTP Input Processing &nbsp;&nbsp 496 <TR> <TD ALIGN=left>29.9 <TD ALIGN=left COLSPAN=2> Keeping Statistics For RTCP &nbsp;&nbsp 499 <TR> <TD ALIGN=left>29.10 <TD ALIGN=left COLSPAN=2> RTP Initialization &nbsp;&nbsp 500 <TR> <TD ALIGN=left>29.11 <TD ALIGN=left COLSPAN=2> RTCP Definitions &nbsp;&nbsp 504 <TR> <TD ALIGN=left>29.12 <TD ALIGN=left COLSPAN=2> Receiving RTCP Sender Reports &nbsp;&nbsp 506 <TR> <TD ALIGN=left>29.13 <TD ALIGN=left COLSPAN=2> Generating RTCP Receiver Reports &nbsp;&nbsp 507 <TR> <TD ALIGN=left>29.14 <TD ALIGN=left COLSPAN=2> RTCP Header Creation &nbsp;&nbsp 509 <TR> <TD ALIGN=left>29.15 <TD ALIGN=left COLSPAN=2> RTCP Delay Computation &nbsp;&nbsp 510 <TR> <TD ALIGN=left>29.16 <TD ALIGN=left COLSPAN=2> Generation Of An RTCP Bye Message &nbsp;&nbsp 511 <TR> <TD ALIGN=left>29.17 <TD ALIGN=left COLSPAN=2> Size Of An Integrated Implementation &nbsp;&nbsp 511 <TR> <TD ALIGN=left>29.18 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 512 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 512<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 513<BR> </TABLE> <BR> <BR> <H3>Chapter 30 &nbsp; Practical Hints And Techniques For Linux Servers &nbsp;&nbsp; 515</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>30.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 515 <TR> <TD ALIGN=left>30.2 <TD ALIGN=left COLSPAN=2> Operating In Background &nbsp;&nbsp 515 <TR> <TD ALIGN=left>30.3 <TD ALIGN=left COLSPAN=2> Programming A Server To Operate In Background &nbsp;&nbsp 516 <TR> <TD ALIGN=left>30.4 <TD ALIGN=left COLSPAN=2> Open Descriptors And Inheritance &nbsp;&nbsp 517 <TR> <TD ALIGN=left>30.5 <TD ALIGN=left COLSPAN=2> Programming A Server To Close Inherited Descriptors &nbsp;&nbsp 518 <TR> <TD ALIGN=left>30.6 <TD ALIGN=left COLSPAN=2> Signals From The Controlling TTY &nbsp;&nbsp 518 <TR> <TD ALIGN=left>30.7 <TD ALIGN=left COLSPAN=2> Programming A Server To Change Its Controlling TTY &nbsp;&nbsp 519 <TR> <TD ALIGN=left>30.8 <TD ALIGN=left COLSPAN=2> Moving To A Safe And Known Directory &nbsp;&nbsp 519 <TR> <TD ALIGN=left>30.9 <TD ALIGN=left COLSPAN=2> Programming A Server To Change Directories &nbsp;&nbsp 520 <TR> <TD ALIGN=left>30.10 <TD ALIGN=left COLSPAN=2> The Linux Umask &nbsp;&nbsp 520 <TR> <TD ALIGN=left>30.11 <TD ALIGN=left COLSPAN=2> Programming A Server To Set Its Umask &nbsp;&nbsp 521 <TR> <TD ALIGN=left>30.12 <TD ALIGN=left COLSPAN=2> Process Groups &nbsp;&nbsp 521 <TR> <TD ALIGN=left>30.13 <TD ALIGN=left COLSPAN=2> Programming A Server To Set Its Process Group &nbsp;&nbsp 521 <TR> <TD ALIGN=left>30.14 <TD ALIGN=left COLSPAN=2> Descriptors For Standard I/O &nbsp;&nbsp 522 <TR> <TD ALIGN=left>30.15 <TD ALIGN=left COLSPAN=2> Programming A Server To Open Standard Descriptors &nbsp;&nbsp 522 <TR> <TD ALIGN=left>30.16 <TD ALIGN=left COLSPAN=2> Mutual Exclusion For The Server &nbsp;&nbsp 522 <TR> <TD ALIGN=left>30.17 <TD ALIGN=left COLSPAN=2> Programming A Server To Avoid Multiple Copies &nbsp;&nbsp 523 <TR> <TD ALIGN=left>30.18 <TD ALIGN=left COLSPAN=2> Recording A Server's Process ID &nbsp;&nbsp 524 <TR> <TD ALIGN=left>30.19 <TD ALIGN=left COLSPAN=2> Programming A Server To Record Its Process ID &nbsp;&nbsp 524 <TR> <TD ALIGN=left>30.20 <TD ALIGN=left COLSPAN=2> Waiting For A Child Process To Exit &nbsp;&nbsp 524 <TR> <TD ALIGN=left>30.21 <TD ALIGN=left COLSPAN=2> Programming A Server To Wait For Each Child To Exit &nbsp;&nbsp 525 <TR> <TD ALIGN=left>30.22 <TD ALIGN=left COLSPAN=2> Extraneous Signals &nbsp;&nbsp 525 <TR> <TD ALIGN=left>30.23 <TD ALIGN=left COLSPAN=2> Programming A Server To Ignore Extraneous Signals &nbsp;&nbsp 525 <TR> <TD ALIGN=left>30.24 <TD ALIGN=left COLSPAN=2> Using A System Log Facility &nbsp;&nbsp 525 <TR> <TD ALIGN=left> <TD ALIGN=left>30.24.1 <TD ALIGN=left> Generating Log Messages &nbsp;&nbsp 525 <TR> <TD ALIGN=left> <TD ALIGN=left>30.24.2 <TD ALIGN=left> The Advantage Of Indirection And Standard Error &nbsp;&nbsp 526 <TR> <TD ALIGN=left> <TD ALIGN=left>30.24.3 <TD ALIGN=left> Limitations Of I/O Redirection &nbsp;&nbsp 527 <TR> <TD ALIGN=left> <TD ALIGN=left>30.24.4 <TD ALIGN=left> A Client-Server Solution &nbsp;&nbsp 527 <TR> <TD ALIGN=left> <TD ALIGN=left>30.24.5 <TD ALIGN=left> The Syslog Mechanism &nbsp;&nbsp 528 <TR> <TD ALIGN=left> <TD ALIGN=left>30.24.6 <TD ALIGN=left> Syslog Message Classes &nbsp;&nbsp 528 <TR> <TD ALIGN=left> <TD ALIGN=left>30.24.7 <TD ALIGN=left> Syslog Facilities &nbsp;&nbsp 528 <TR> <TD ALIGN=left> <TD ALIGN=left>30.24.8 <TD ALIGN=left> Syslog Priority Levels &nbsp;&nbsp 529 <TR> <TD ALIGN=left> <TD ALIGN=left>30.24.9 <TD ALIGN=left> Using Syslog &nbsp;&nbsp 529 <TR> <TD ALIGN=left> <TD ALIGN=left>30.24.10 <TD ALIGN=left> An Example Syslog Configuration File &nbsp;&nbsp 530 <TR> <TD ALIGN=left>30.25 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 531 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 531<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 532<BR> </TABLE> <BR> <BR> <H3>Chapter 31 &nbsp; Deadlock And Starvation In Client-Server Systems &nbsp;&nbsp; 533</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>31.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 533 <TR> <TD ALIGN=left>31.2 <TD ALIGN=left COLSPAN=2> Definition Of Deadlock &nbsp;&nbsp 534 <TR> <TD ALIGN=left>31.3 <TD ALIGN=left COLSPAN=2> Difficulty Of Deadlock Detection &nbsp;&nbsp 534 <TR> <TD ALIGN=left>31.4 <TD ALIGN=left COLSPAN=2> Deadlock Avoidance &nbsp;&nbsp 535 <TR> <TD ALIGN=left>31.5 <TD ALIGN=left COLSPAN=2> Deadlock Between A Client And Server &nbsp;&nbsp 535 <TR> <TD ALIGN=left>31.6 <TD ALIGN=left COLSPAN=2> Avoiding Deadlock In A Single Interaction &nbsp;&nbsp 536 <TR> <TD ALIGN=left>31.7 <TD ALIGN=left COLSPAN=2> Starvation Among A Set Of Clients And A Server &nbsp;&nbsp 536 <TR> <TD ALIGN=left>31.8 <TD ALIGN=left COLSPAN=2> Busy Connections And Starvation &nbsp;&nbsp 537 <TR> <TD ALIGN=left>31.9 <TD ALIGN=left COLSPAN=2> Avoiding Blocking Operations &nbsp;&nbsp 538 <TR> <TD ALIGN=left>31.10 <TD ALIGN=left COLSPAN=2> Processes, Connections, And Other Limits &nbsp;&nbsp 538 <TR> <TD ALIGN=left>31.11 <TD ALIGN=left COLSPAN=2> Cycles Of Clients And Servers &nbsp;&nbsp 539 <TR> <TD ALIGN=left>31.12 <TD ALIGN=left COLSPAN=2> Documenting Dependencies &nbsp;&nbsp 540 <TR> <TD ALIGN=left>31.13 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 540 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 541<BR> </TABLE> <BR> <BR><H3> Appendix 1 &nbsp; System Calls And Library Routines Used With Sockets &nbsp;&nbsp; 543</H3> <BR><H3> Appendix 2 &nbsp; Manipulation Of Linux File And Socket Descriptors &nbsp;&nbsp; 573</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 576<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 576<BR> </TABLE> <BR><H3> Bibliography &nbsp;&nbsp;577</H3> <BR><H3> Index &nbsp;&nbsp;585</H3> </UL></UL> </BODY> </BODY>
</DOC>
