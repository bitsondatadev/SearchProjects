<DOC>
<DOCNO> http://www.cs.purdue.edu/homes/dec/tcpip3s.cont.html </DOCNO>
<HTML> <H2> Table of Contents: Internetworking With TCP/IP Volume 3 <UL><UL>BSD socket version</UL></UL></H2> <BR> <H3> Foreword </H3> <H3> Preface </H3> <H3> Chapter 1 Introduction And Overview </H3> <DL> <DT> 1.1 Use Of TCP/IP 1 <DT> 1.2 Designing Applications For A Distributed Environment 2 <DT> 1.3 Standard And Nonstandard Application Protocols 2 <DT> 1.4 An Example Of Standard Application Protocol Use 2 <DT> 1.5 An Example Connection 3 <DT> 1.6 Using TELNET To Access An Alternative Service 4 <DT> 1.7 Application Protocols And Software Flexibility 6 <DT> 1.8 Viewing Services From The Provider's Perspective 6 <DT> 1.9 The Remainder Of This Text 7 <DT> 1.10 Summary 7 <DT> For Further Study 8 <DT> Exercises 8 </DL> <H3> Chapter 2 The Client Server Model And Software Design </H3> <DL> <DT> 2.1 Introduction 9 <DT> 2.2 Motivation 10 <DT> 2.3 Terminology And Concepts 10 <DT> 2.3.1 Clients And Servers 10 <DT> 2.3.2 Privilege And Complexity 11 <DT> 2.3.3 Standard Vs. Nonstandard Client Software 11 <DT> 2.3.4 Parameterization Of Clients 12 <DT> 2.3.5 Connectionless Vs. Connection-Oriented Servers 13 <DT> 2.3.6 Stateless Vs. Stateful Servers 14 <DT> 2.3.7 A Stateful File Server Example 14 <DT> 2.3.8 Statelessness Is A Protocol Issue 16 <DT> 2.3.9 Servers As Clients 17 <DT> 2.4 Summary 18 <DT> For Further Study 18 <DT> Exercises 18 </DL> <H3> Chapter 3 Concurrent Processing In Client-Server Software </H3> <DL> <DT> 3.1 Introduction 21 <DT> 3.2 Concurrency In Networks 21 <DT> 3.3 Concurrency In Servers 23 <DT> 3.4 Terminology And Concepts 24 <DT> 3.4.1 The Process Concept 25 <DT> 3.4.2 Programs vs. Processes 25 <DT> 3.4.3 Procedure Calls 26 <DT> 3.5 An Example Of Concurrent Process Creation 26 <DT> 3.5.1 A Sequential C Example 26 <DT> 3.5.2 A Concurrent Version 27 <DT> 3.5.3 Timeslicing 29 <DT> 3.5.4 Making Processes Diverge 30 <DT> 3.6 Executing New Code 31 <DT> 3.7 Context Switching And Protocol Software Design 32 <DT> 3.8 Concurrency And Asynchronous I/O 32 <DT> 3.9 Summary 33 <DT> For Further Study 33 <DT> Exercises 33 </DL> <H3> Chapter 4 Program Interface To Protocols </H3> <DL> <DT> 4.1 Introduction 35 <DT> 4.2 Loosely Specified Protocol Software Interface 35 <DT> 4.2.1 Advantages And Disadvantages 36 <DT> 4.3 Interface Functionality 36 <DT> 4.4 Conceptual Interface Specification 37 <DT> 4.5 System Calls 37 <DT> 4.6 Two Basic Approaches To Network Communication 38 <DT> 4.7 The Basic I/O Functions Available In UNIX 39 <DT> 4.8 Using UNIX I/O With TCP/IP 40 <DT> 4.9 Summary 40 <DT> For Further Study 41 <DT> Exercises 41 </DL> <H3> Chapter 5 The Socket Interface </H3> <DL> <DT> 5.1 Introduction 43 <DT> 5.2 Berkeley Sockets 43 <DT> 5.3 Specifying A Protocol Interface 44 <DT> 5.4 The Socket Abstraction 45 <DT> 5.4.1 Socket Descriptors And File Descriptors 45 <DT> 5.4.2 System Data Structures For Sockets 46 <DT> 5.4.3 Using Sockets 47 <DT> 5.5 Specifying An Endpoint Address 47 <DT> 5.6 A Generic Address Structure 48 <DT> 5.7 Major System Calls Used With Sockets 49 <DT> 5.7.1 The Socket Call 49 <DT> 5.7.2 The Connect Call 50 <DT> 5.7.3 The Write Call 50 <DT> 5.7.4 The Read Call 50 <DT> 5.7.5 The Close Call 50 <DT> 5.7.6 The Bind Call 51 <DT> 5.7.7 The Listen Call 51 <DT> 5.7.8 The Accept Call 51 <DT> 5.7.9 Summary Of Socket Calls Used With TCP 51 <DT> 5.8 Utility Routines For Integer Conversion 52 <DT> 5.9 Using Socket Calls In A Program 53 <DT> 5.10 Symbolic Constants For Socket Call Parameters 54 <DT> 5.11 Summary 54 <DT> For Further Study 55 <DT> Exercises 55 </DL> <H3> Chapter 6 Algorithms And Issues In Client Software Design </H3> <DL> <DT> 6.1 Introduction 57 <DT> 6.2 Learning Algorithms Instead Of Details 57 <DT> 6.3 Client Architecture 58 <DT> 6.4 Identifying The Location Of A Server 58 <DT> 6.5 Parsing An Address Argument 60 <DT> 6.6 Looking Up A Domain Name 61 <DT> 6.7 Looking Up A Well-Known Port By Name 62 <DT> 6.8 Port Numbers And Network Byte Order 62 <DT> 6.9 Looking Up A Protocol By Name 63 <DT> 6.10 The TCP Client Algorithm 63 <DT> 6.11 Allocating A Socket 64 <DT> 6.12 Choosing A Local Protocol Port Number 65 <DT> 6.13 A Fundamental Problem In Choosing A Local IP Address 65 <DT> 6.14 Connecting A TCP Socket To A Server 66 <DT> 6.15 Communicating With The Server Using TCP 66 <DT> 6.16 Reading A Response From A TCP Connection 67 <DT> 6.17 Closing A TCP Connection 68 <DT> 6.17.1 The Need For Partial Close 68 <DT> 6.17.2 A Partial Close Operation 68 <DT> 6.18 Programming A UDP Client 69 <DT> 6.19 Connected And Unconnected UDP Sockets 69 <DT> 6.20 Using Connect With UDP 70 <DT> 6.21 Communicating With A Server Using UDP 70 <DT> 6.22 Closing A Socket That Uses UDP 70 <DT> 6.23 Partial Close For UDP 71 <DT> 6.24 A Warning About UDP Unreliability 71 <DT> 6.25 Summary 71 <DT> For Further Study 72 <DT> Exercises 72 </DL> <H3> Chapter 7 Example Client Software </H3> <DL> <DT> 7.1 Introduction 75 <DT> 7.2 The Importance Of Small Examples 75 <DT> 7.3 Hiding Details 76 <DT> 7.4 An Example Procedure Library For Client Programs 76 <DT> 7.5 Implementation Of ConnectTCP 77 <DT> 7.6 Implementation Of ConnectUDP 78 <DT> 7.7 A Procedure That Forms Connections 79 <DT> 7.8 Using The Example Library 81 <DT> 7.9 The DAYTIME Service 82 <DT> 7.10 Implementation Of A TCP Client For DAYTIME 82 <DT> 7.11 Reading From A TCP Connection 84 <DT> 7.12 The TIME Service 84 <DT> 7.13 Accessing The TIME Service 85 <DT> 7.14 Accurate Times And Network Delays 85 <DT> 7.15 A UDP Client For The TIME Service 86 <DT> 7.16 The ECHO Service 88 <DT> 7.17 A TCP Client For The ECHO Service 88 <DT> 7.18 A UDP Client For The ECHO Service 90 <DT> 7.19 Summary 92 <DT> For Further Study 92 <DT> Exercises 92 </DL> <H3> Chapter 8 Algorithms And Issues In Server Software Design </H3> <DL> <DT> 8.1 Introduction 95 <DT> 8.2 The Conceptual Server Algorithm 95 <DT> 8.3 Concurrent Vs. Iterative Servers 96 <DT> 8.4 Connection-Oriented Vs. Connectionless Access 96 <DT> 8.5 Connection-Oriented Servers 97 <DT> 8.6 Connectionless Servers 97 <DT> 8.7 Failure, Reliability, And Statelessness 98 <DT> 8.8 Optimizing Stateless Servers 99 <DT> 8.9 Four Basic Types Of Servers 101 <DT> 8.10 Request Processing Time 102 <DT> 8.11 Iterative Server Algorithms 102 <DT> 8.12 An Iterative, Connection-Oriented Server Algorithm 103 <DT> 8.13 Binding To A Well-Known Address Using INADDR_ANY 103 <DT> 8.14 Placing The Socket In Passive Mode 104 <DT> 8.15 Accepting Connections And Using Them 104 <DT> 8.16 An Iterative, Connectionless Server Algorithm 104 <DT> 8.17 Forming A Reply Address In A Connectionless Server 105 <DT> 8.18 Concurrent Server Algorithms 106 <DT> 8.19 Master And Slave Processes 106 <DT> 8.20 A Concurrent, Connectionless Server Algorithm 107 <DT> 8.21 A Concurrent, Connection-Oriented Server Algorithm 107 <DT> 8.22 Using Separate Programs As Slaves 108 <DT> 8.23 Apparent Concurrency Using A Single Process 109 <DT> 8.24 When To Use Each Server Type 110 <DT> 8.25 A Summary of Server Types 111 <DT> 8.26 The Important Problem Of Server Deadlock 112 <DT> 8.27 Alternative Implementations 112 <DT> 8.28 Summary 113 <DT> For Further Study 113 <DT> Exercises 113 </DL> <H3> Chapter 9 Iterative, Connectionless Servers (UDP) </H3> <DL> <DT> 9.1 Introduction 115 <DT> 9.2 Creating A Passive Socket 115 <DT> 9.3 Process Structure 119 <DT> 9.4 An Example TIME Server 119 <DT> 9.5 Summary 121 <DT> For Further Study 122 <DT> Exercises 122 </DL> <H3> Chapter 10 Iterative, Connection-Oriented Servers (TCP) </H3> <DL> <DT> 10.1 Introduction 123 <DT> 10.2 Allocating A Passive TCP Socket 123 <DT> 10.3 A Server For The DAYTIME Service 124 <DT> 10.4 Process Structure 124 <DT> 10.5 An Example DAYTIME Server 125 <DT> 10.6 Closing Connections 128 <DT> 10.7 Connection Termination And Server Vulnerability 128 <DT> 10.8 Summary 129 <DT> For Further Study 129 <DT> Exercises 129 </DL> <H3> Chapter 11 Concurrent, Connection-Oriented Servers (TCP) </H3> <DL> <DT> 11.1 Introduction 131 <DT> 11.2 Concurrent ECHO 131 <DT> 11.3 Iterative Vs. Concurrent Implementations 132 <DT> 11.4 Process Structure 132 <DT> 11.5 An Example Concurrent ECHO Server 133 <DT> 11.6 Cleaning Up Errant Processes 137 <DT> 11.7 Summary 138 <DT> For Further Study 138 <DT> Exercises 138 </DL> <H3> Chapter 12 Single-Process, Concurrent Servers (TCP) </H3> <DL> <DT> 12.1 Introduction 139 <DT> 12.2 Data-driven Processing In A Server 139 <DT> 12.3 Data-Driven Processing With A Single Process 140 <DT> 12.4 Process Structure Of A Single-Process Server 141 <DT> 12.5 An Example Single-Process ECHO Server 142 <DT> 12.6 Summary 144 <DT> For Further Study 145 <DT> Exercises 145 </DL> <H3> Chapter 13 Multiprotocol Servers (TCP, UDP) </H3> <DL> <DT> 13.1 Introduction 147 <DT> 13.2 The Motivation For Reducing The Number Of Servers 147 <DT> 13.3 Multiprotocol Server Design 148 <DT> 13.4 Process Structure 148 <DT> 13.5 An Example Multiprotocol DAYTIME Server 149 <DT> 13.6 The Concept Of Shared Code 153 <DT> 13.7 Concurrent Multiprotocol Servers 153 <DT> 13.8 Summary 153 <DT> For Further Study 154 <DT> Exercises 154 </DL> <H3> Chapter 14 Multiservice Servers (TCP, UDP) </H3> <DL> <DT> 14.1 Introduction 155 <DT> 14.2 Consolidating Servers 155 <DT> 14.3 A Connectionless, Multiservice Server Design 156 <DT> 14.4 A Connection-Oriented, Multiservice Server Design 157 <DT> 14.5 A Concurrent, Connection-Oriented, Multiservice Server 158 <DT> 14.6 A Single-Process, Multiservice Server Implementation 158 <DT> 14.7 Invoking Separate Programs From A Multiservice Server 159 <DT> 14.8 Multiservice, Multiprotocol Designs 160 <DT> 14.9 An Example Multiservice Server 161 <DT> 14.10 Static and Dynamic Server Configuration 168 <DT> 14.11 The UNIX Super Server, Inetd 169 <DT> 14.12 An Example Inetd Server 171 <DT> 14.13 Summary 173 <DT> For Further Study 173 <DT> Exercises 173 </DL> <H3> Chapter 15 Uniform, Efficient Management Of Server Concurrency </H3> <DL> <DT> 15.1 Introduction 175 <DT> 15.2 Choosing Between An Iterative And A Concurrent Design 175 <DT> 15.3 Level Of Concurrency 176 <DT> 15.4 Demand-Driven Concurrency 177 <DT> 15.5 The Cost Of Concurrency 177 <DT> 15.6 Overhead And Delay 177 <DT> 15.7 Small Delays Can Matter 178 <DT> 15.8 Process Preallocation 179 <DT> 15.8.1 Preallocation In UNIX 180 <DT> 15.8.2 Preallocation In A Connection-Oriented Server 180 <DT> 15.8.3 Preallocation In A Connectionless Server 181 <DT> 15.8.4 Preallocation, Bursty Traffic, And NFS 182 <DT> 15.8.5 Process Preallocation On A Multiprocessor 183 <DT> 15.9 Delayed Process Allocation 183 <DT> 15.10 The Uniform Basis For Both Techniques 184 <DT> 15.11 Combining Techniques 185 <DT> 15.12 Summary 185 <DT> For Further Study 186 <DT> Exercises 186 </DL> <H3> Chapter 16 Concurrency In Clients </H3> <DL> <DT> 16.1 Introduction 187 <DT> 16.2 The Advantages Of Concurrency 187 <DT> 16.3 The Motivation For Exercising Control 188 <DT> 16.4 Concurrent Contact With Multiple Servers 189 <DT> 16.5 Implementing Concurrent Clients 189 <DT> 16.6 Single-Process Implementations 191 <DT> 16.7 An Example Concurrent Client That Uses ECHO 192 <DT> 16.8 Execution Of The Concurrent Client 196 <DT> 16.9 Concurrency In The Example Code 197 <DT> 16.10 Summary 198 <DT> Exercises 198 </DL> <H3> Chapter 17 Tunneling At The Transport And Application Levels </H3> <DL> <DT> 17.1 Introduction 199 <DT> 17.2 Multiprotocol Environments 199 <DT> 17.3 Mixing Network Technologies 201 <DT> 17.4 Dynamic Circuit Allocation 202 <DT> 17.5 Encapsulation And Tunneling 203 <DT> 17.6 Tunneling Through An IP Internet 203 <DT> 17.7 Application-Level Tunneling Between Clients And Servers 204 <DT> 17.8 Tunneling, Encapsulation, And Dialup Phone Lines 205 <DT> 17.9 Summary 206 <DT> For Further Study 206 <DT> Exercises 206 </DL> <H3> Chapter 18 Application Level Gateways </H3> <DL> <DT> 18.1 Introduction 209 <DT> 18.2 Clients And Servers In Constrained Environments 209 <DT> 18.2.1 The Reality Of Multiple Technologies 209 <DT> 18.2.2 Computers With Limited Functionality 210 <DT> 18.2.3 Connectivity Constraints That Arise From Security 210 <DT> 18.3 Using Application Gateways 211 <DT> 18.4 Interoperability Through A Mail Gateway 212 <DT> 18.5 Implementation Of A Mail Gateway 213 <DT> 18.6 A Comparison Of Application Gateways And Tunneling 213 <DT> 18.7 Application Gateways And Limited Functionality Systems 215 <DT> 18.8 Application Gateways Used For Security 216 <DT> 18.9 Application Gateways And The Extra Hop Problem 217 <DT> 18.10 An Example Application Gateway 219 <DT> 18.11 Implementation Of An Application Gateway 220 <DT> 18.12 Code For The Application Gateway 221 <DT> 18.13 An Example Gateway Exchange 223 <DT> 18.14 Using Rfcd With UNIX's .forward 223 <DT> 18.15 A General-Purpose Application Gateway 224 <DT> 18.16 Operation Of SLIRP 224 <DT> 18.17 How SLIRP Handles Connections 225 <DT> 18.18 IP Addressing And SLIRP 225 <DT> 18.19 Summary 226 <DT> For Further Study 227 <DT> Exercises 227 </DL> <H3> Chapter 19 External Data Representation (XDR) </H3> <DL> <DT> 19.1 Introduction 229 <DT> 19.2 Representations For Data In Computers 229 <DT> 19.3 The N-Squared Conversion Problem 230 <DT> 19.4 Network Standard Byte Order 231 <DT> 19.5 A De Facto Standard External Data Representation 232 <DT> 19.6 XDR Data Types 233 <DT> 19.7 Implicit Types 234 <DT> 19.8 Software Support For Using XDR 234 <DT> 19.9 XDR Library Routines 234 <DT> 19.10 Building A Message One Piece At A Time 234 <DT> 19.11 Conversion Routines In The XDR Library 236 <DT> 19.12 XDR Streams, I/O, and TCP 238 <DT> 19.13 Records, Record Boundaries, And Datagram I/O 239 <DT> 19.14 Summary 239 <DT> For Further Study 240 <DT> Exercises 240 </DL> <H3> Chapter 20 Remote Procedure Call Concept (RPC) </H3> <DL> <DT> 20.1 Introduction 241 <DT> 20.2 Remote Procedure Call Model 241 <DT> 20.3 Two Paradigms For Building Distributed Programs 242 <DT> 20.4 A Conceptual Model For Conventional Procedure Calls 243 <DT> 20.5 An Extension Of the Procedural Model 243 <DT> 20.6 Execution Of Conventional Procedure Call And Return 244 <DT> 20.7 The Procedural Model In Distributed Systems 245 <DT> 20.8 Analogy Between Client-Server And RPC 246 <DT> 20.9 Distributed Computation As A Program 247 <DT> 20.10 Sun Microsystems' Remote Procedure Call Definition 248 <DT> 20.11 Remote Programs And Procedures 248 <DT> 20.12 Reducing The Number Of Arguments 249 <DT> 20.13 Identifying Remote Programs And Procedures 249 <DT> 20.14 Accommodating Multiple Versions Of A Remote Program 250 <DT> 20.15 Mutual Exclusion For Procedures In A Remote Program 251 <DT> 20.16 Communication Semantics 252 <DT> 20.17 At Least Once Semantics 252 <DT> 20.18 RPC Retransmission 253 <DT> 20.19 Mapping A Remote Program To A Protocol Port 253 <DT> 20.20 Dynamic Port Mapping 254 <DT> 20.21 RPC Port Mapper Algorithm 255 <DT> 20.22 ONC RPC Message Format 257 <DT> 20.23 Marshaling Arguments For A Remote Procedure 258 <DT> 20.24 Authentication 258 <DT> 20.25 An Example Of RPC Message Representation 259 <DT> 20.26 An Example Of The UNIX Authentication Field 260 <DT> 20.27 Summary 261 <DT> For Further Study 262 <DT> Exercises 262 </DL> <H3> Chapter 21 Distributed Program Generation (Rpcgen Concept) </H3> <DL> <DT> 21.1 Introduction 265 <DT> 21.2 Using Remote Procedure Calls 266 <DT> 21.3 Programming Mechanisms To Support RPC 267 <DT> 21.4 Dividing A Program Into Local And Remote Procedures 268 <DT> 21.5 Adding Code For RPC 269 <DT> 21.6 Stub Procedures 269 <DT> 21.7 Multiple Remote Procedures And Dispatching 270 <DT> 21.8 Name Of The Client-Side Stub Procedure 271 <DT> 21.9 Using Rpcgen To Generate Distributed Programs 272 <DT> 21.10 Rpcgen Output And Interface Procedures 272 <DT> 21.11 Rpcgen Input And Output 273 <DT> 21.12 Using Rpcgen To Build A Client And Server 274 <DT> 21.13 Summary 274 <DT> For Further Study 276 <DT> Exercises 276 </DL> <H3> Chapter 22 Distributed Program Generation (Rpcgen Example) </H3> <DL> <DT> 22.1 Introduction 277 <DT> 22.2 An Example To Illustrate Rpcgen 278 <DT> 22.3 Dictionary Look Up 278 <DT> 22.4 Eight Steps To A Distributed Application 279 <DT> 22.5 Step 1: Build A Conventional Application Program 280 <DT> 22.6 Step 2: Divide The Program Into Two Parts 284 <DT> 22.7 Step 3: Create An Rpcgen Specification 290 <DT> 22.8 Step 4: Run Rpcgen 292 <DT> 22.9 The .h File Produced By Rpcgen 292 <DT> 22.10 The XDR Conversion File Produced By Rpcgen 293 <DT> 22.11 The Client Code Produced By Rpcgen 294 <DT> 22.12 The Server Code Produced By Rpcgen 296 <DT> 22.13 Step 5: Write Stub Interface Procedures 299 <DT> 22.13.1 Client-Side Interface Routines 299 <DT> 22.13.2 Server-Side Interface Routines 301 <DT> 22.14 Step 6: Compile And Link The Client Program 303 <DT> 22.15 Step 7: Compile And Link The Server Program 307 <DT> 22.16 Step 8: Start The Server And Execute The Client 309 <DT> 22.17 Using The UNIX Make Utility 309 <DT> 22.18 Summary 311 <DT> For Further Study 312 <DT> Exercises 312 </DL> <H3> Chapter 23 Network File System Concepts (NFS) </H3> <DL> <DT> 23.1 Introduction 315 <DT> 23.2 Remote File Access Vs. Transfer 315 <DT> 23.3 Operations On Remote Files 316 <DT> 23.4 File Access Among Heterogeneous Computers 316 <DT> 23.5 Stateless Servers 317 <DT> 23.6 NFS And UNIX File Semantics 317 <DT> 23.7 Review Of The UNIX File System 317 <DT> 23.7.1 Basic Definitions 317 <DT> 23.7.2 A Byte Sequence Without Record Boundaries 318 <DT> 23.7.3 A File's Owner And Group Identifiers 318 <DT> 23.7.4 Protection And Access 318 <DT> 23.7.5 The Open-Read-Write-Close Paradigm 320 <DT> 23.7.6 Data Transfer 321 <DT> 23.7.7 Permission To Search A Directory 321 <DT> 23.7.8 Random Access 321 <DT> 23.7.9 Seeking Beyond The End Of File 322 <DT> 23.7.10 File Position And Concurrent Access 323 <DT> 23.7.11 Semantics Of Write During Concurrent Access 324 <DT> 23.7.12 File Names And Paths 324 <DT> 23.7.13 Inode: Information Stored With A File 325 <DT> 23.7.14 Stat Operation 326 <DT> 23.7.15 The File Naming Mechanism 327 <DT> 23.7.16 File System Mounts 328 <DT> 23.7.17 UNIX File Name Resolution 330 <DT> 23.7.18 Symbolic Links 331 <DT> 23.8 Files Under NFS 331 <DT> 23.9 NFS File Types 332 <DT> 23.10 NFS File Modes 332 <DT> 23.11 NFS File Attributes 333 <DT> 23.12 NFS Client And Server 334 <DT> 23.13 NFS Client Operation 335 <DT> 23.14 NFS Client And UNIX 336 <DT> 23.15 NFS Mounts 337 <DT> 23.16 File Handle 338 <DT> 23.17 Handles Replace Path Names 338 <DT> 23.18 An NFS Client In UNIX 340 <DT> 23.19 File Positioning With A Stateless Server 340 <DT> 23.20 Operations On Directories 341 <DT> 23.21 Reading A Directory Statelessly 341 <DT> 23.22 Multiple Hierarchies In An NFS Server 342 <DT> 23.23 The Mount Protocol 342 <DT> 23.24 Summary 343 <DT> For Further Study 343 <DT> Exercises 343 </DL> <H3> Chapter 24 Network File System Protocol (NFS, Mount) </H3> <DL> <DT> 24.1 Introduction 345 <DT> 24.2 Using RPC To Define A Protocol 345 <DT> 24.3 Defining A Protocol With Data Structures And Procedures 346 <DT> 24.4 NFS Constant, Type, And Data Declarations 347 <DT> 24.4.1 NFS Constants 347 <DT> 24.4.2 NFS Typedef Declarations 348 <DT> 24.4.3 NFS Data Structures 348 <DT> 24.5 NFS Procedures 350 <DT> 24.6 Semantics Of NFS Operations 351 <DT> 24.6.1 NFSPROC_NULL (Procedure 0) 352 <DT> 24.6.2 NFSPROC_GETATTR (Procedure 1) 352 <DT> 24.6.3 NFSPROC_SETATTR (Procedure 2) 352 <DT> 24.6.4 NFSPROC_ROOT (Procedure 3) [Obsolete in NFS3] 352 <DT> 24.6.5 NFSPROC_LOOKUP (Procedure 4) 352 <DT> 24.6.6 NFSPROC_READLINK (Procedure 5) 352 <DT> 24.6.7 NFSPROC_READ (Procedure 6) 352 <DT> 24.6.8 NFSPROC_WRITECACHE (Procedure 7) [Obsolete in NFS3] 352 <DT> 24.6.9 NFSPROC_WRITE (Procedure 8) 353 <DT> 24.6.10 NFSPROC_CREATE (Procedure 9) 353 <DT> 24.6.11 NFSPROC_REMOVE (Procedure 10) 353 <DT> 24.6.12 NFSPROC_RENAME (Procedure 11) 353 <DT> 24.6.13 NFSPROC_LINK (Procedure 12) 353 <DT> 24.6.14 NFSPROC_SYMLINK (Procedure 13) 353 <DT> 24.6.15 NFSPROC_MKDIR (Procedure 14) 354 <DT> 24.6.16 NFSPROC_RMDIR (Procedure 15) 354 <DT> 24.6.17 NFSPROC_READDIR (Procedure 16) 354 <DT> 24.6.18 NFSPROC_STATFS (Procedure 17) 354 <DT> 24.7 The Mount Protocol 355 <DT> 24.7.1 Mount Constant Definitions 355 <DT> 24.7.2 Mount Type Definitions 355 <DT> 24.7.3 Mount Data Structures 356 <DT> 24.8 Procedures In The Mount Protocol 357 <DT> 24.9 Semantics of Mount Operations 357 <DT> 24.9.1 MNTPROC_NULL (Procedure 0) 357 <DT> 24.9.2 MNTPROC_MNT (Procedure 1) 357 <DT> 24.9.3 MNTPROC_DUMP (Procedure 2) 358 <DT> 24.9.4 MNTPROC_UMNT (Procedure 3) 358 <DT> 24.9.5 MNTPROC_UMNTALL (Procedure 4) 358 <DT> 24.9.6 MNTPROC_EXPORT (Procedure 5) 358 <DT> 24.10 NFS And Mount Authentication 358 <DT> 24.11 Changes In NFS Version 3 360 <DT> 24.12 Summary 361 <DT> For Further Study 361 <DT> Exercises 362 </DL> <H3> Chapter 25 A TELNET Client (Program Structure) </H3> <DL> <DT> 25.1 Introduction 363 <DT> 25.2 Overview 364 <DT> 25.2.1 The User's Terminal 364 <DT> 25.2.2 Command And Control Information 364 <DT> 25.2.3 Terminals, Windows, and Files 364 <DT> 25.2.4 The Need For Concurrency 365 <DT> 25.2.5 A Process Model For A TELNET Client 366 <DT> 25.3 A TELNET Client Algorithm 366 <DT> 25.4 Terminal I/O In UNIX 367 <DT> 25.4.1 Controlling A Device Driver 368 <DT> 25.5 Establishing Terminal Modes 369 <DT> 25.6 Global Variable Used For Stored State 371 <DT> 25.7 Restoring Terminal Modes Before Exit 372 <DT> 25.8 Client Suspension And Resumption 373 <DT> 25.9 Finite State Machine Specification 374 <DT> 25.10 Embedding Commands In A TELNET Data Stream 375 <DT> 25.11 Option Negotiation 376 <DT> 25.12 Request/Offer Symmetry 376 <DT> 25.13 TELNET Character Definitions 376 <DT> 25.14 A Finite State Machine For Data From The Server 378 <DT> 25.15 Transitions Among States 379 <DT> 25.16 A Finite State Machine Implementation 381 <DT> 25.17 A Compact FSM Representation 381 <DT> 25.18 Keeping The Compact Representation At Run-Time 383 <DT> 25.19 Implementation Of A Compact Representation 383 <DT> 25.20 Building An FSM Transition Matrix 385 <DT> 25.21 The Socket Output Finite State Machine 387 <DT> 25.22 Definitions For The Socket Output FSM 390 <DT> 25.23 The Option Subnegotiation Finite State Machine 391 <DT> 25.24 Definitions For The Option Subnegotiation FSM 392 <DT> 25.25 FSM Initialization 393 <DT> 25.26 Arguments For The TELNET Client 394 <DT> 25.27 The Heart Of The TELNET Client 395 <DT> 25.28 Implementation Of The Main FSM 399 <DT> 25.29 Summary 401 <DT> For Further Study 401 <DT> Exercises 401 </DL> <H3> Chapter 26 A TELNET Client (Implementation Details) </H3> <DL> <DT> 26.1 Introduction 403 <DT> 26.2 The FSM Action Procedures 403 <DT> 26.3 Recording The Type Of An Option Request 404 <DT> 26.4 Performing No Operation 405 <DT> 26.5 Responding To WILL/WONT For The Echo Option 405 <DT> 26.6 Responding To WILL/WONT For Unsupported Options 407 <DT> 26.7 Responding To WILL/WONT For The No Go-Ahead Option 407 <DT> 26.8 Generating DO/DONT For Binary Transmission 409 <DT> 26.9 Responding To DO/DONT For Unsupported Options 410 <DT> 26.10 Responding To DO/DONT For Transmit Binary Option 410 <DT> 26.11 Responding To DO/DONT For The Terminal Type Option 412 <DT> 26.12 Option Subnegotiation 413 <DT> 26.13 Sending Terminal Type Information 414 <DT> 26.14 Terminating Subnegotiation 416 <DT> 26.15 Sending A Character To The Server 416 <DT> 26.16 Displaying Incoming Data On The User's Terminal 418 <DT> 26.17 Using Termcap To Control The User's Terminal 421 <DT> 26.18 Writing A Block Of Data To The Server 422 <DT> 26.19 Interacting With The Client Process 424 <DT> 26.20 Responding To Illegal Commands 424 <DT> 26.21 Scripting To A File 425 <DT> 26.22 Implementation Of Scripting 425 <DT> 26.23 Initialization Of Scripting 426 <DT> 26.24 Collecting Characters Of The Script File Name 427 <DT> 26.25 Opening A Script File 428 <DT> 26.26 Terminating Scripting 430 <DT> 26.27 Printing Status Information 431 <DT> 26.28 Summary 432 <DT> For Further Study 432 <DT> Exercises 433 </DL> <H3> Chapter 27 Practical Hints And Techniques For UNIX Servers </H3> <DL> <DT> 27.1 Introduction 435 <DT> 27.2 Operating In Background 435 <DT> 27.3 Programming A Server To Operate In Background 436 <DT> 27.4 Open Descriptors And Inheritance 437 <DT> 27.5 Programming A Server To Close Inherited Descriptors 438 <DT> 27.6 Signals From The Controlling TTY 438 <DT> 27.7 Programming A Server To Change Its Controlling TTY 438 <DT> 27.8 Moving To A Safe And Known Directory 439 <DT> 27.9 Programming A Server To Change Directories 439 <DT> 27.10 The UNIX Umask 440 <DT> 27.11 Programming A Server To Set Its Umask 440 <DT> 27.12 Process Groups 440 <DT> 27.13 Programming A Server To Set Its Process Group 441 <DT> 27.14 Descriptors For Standard I/O 441 <DT> 27.15 Programming A Server To Open Standard Descriptors 441 <DT> 27.16 Mutual Exclusion For The Server 442 <DT> 27.17 Programming A Server To Avoid Multiple Copies 442 <DT> 27.18 Recording A Server's Process ID 443 <DT> 27.19 Programming A Server To Record Its Process ID 443 <DT> 27.20 Waiting For A Child Process To Exit 444 <DT> 27.21 Programming A Server To Wait For Each Child To Exit 444 <DT> 27.22 Extraneous Signals 444 <DT> 27.23 Programming A Server To Ignore Extraneous Signals 445 <DT> 27.24 Using A System Log Facility 445 <DT> 27.24.1 Generating Log Messages 445 <DT> 27.24.2 The Advantage Of Indirection And Standard Error 445 <DT> 27.24.3 Limitations Of I/O Redirection 446 <DT> 27.24.4 A Client-Server Solution 446 <DT> 27.24.5 The Syslog Mechanism 447 <DT> 27.24.6 Syslog Message Classes 447 <DT> 27.24.7 Syslog Facilities 447 <DT> 27.24.8 Syslog Priority Levels 448 <DT> 27.24.9 Using Syslog 448 <DT> 27.24.10 An Example Syslog Configuration File 449 <DT> 27.25 Summary 450 <DT> For Further Study 450 <DT> Exercises 451 </DL> <H3> Chapter 28 Deadlock And Starvation In Client-Server Systems </H3> <DL> <DT> 28.1 Introduction 453 <DT> 28.2 Definition Of Deadlock 454 <DT> 28.3 Difficulty Of Deadlock Detection 454 <DT> 28.4 Deadlock Avoidance 455 <DT> 28.5 Deadlock Between A Client And Server 455 <DT> 28.6 Avoiding Deadlock In A Single Interaction 456 <DT> 28.7 Starvation Among A Set Of Clients And A Server 456 <DT> 28.8 Busy Connections And Starvation 457 <DT> 28.9 Avoiding Blocking Operations 458 <DT> 28.10 Processes, Connections, And Other Limits 458 <DT> 28.11 Cycles Of Clients And Servers 459 <DT> 28.12 Documenting Dependencies 459 <DT> 28.13 Summary 460 <DT> Exercises 461 <DT> For Further Study 496 <DT> Exercises 496 </DL> <H3> Bibliography </H3> <H3> Index </H3> <BR> <BR> <H4><A HREF="netbooks.html#vol3.bsd">Return to list of Comer's networking books</A></H4> <BR> <BR> <H4><A HREF="http://www.cs.purdue.edu/people/comer">Return to Comer's homepage</A></H4> </HTML> </HTML>
</DOC>
