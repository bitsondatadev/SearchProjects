<DOC>
<DOCNO> http://www.cs.purdue.edu/homes/dec/xinu1.mac.cont.html </DOCNO>
<HTML> <H2> Table of Contents: Macintosh version of Operating System Design</H2> <BR> <H3> Preface </H3> <H3> Foreword To The First Edition </H3> <H3> Chapter 1 Introduction and Overview </H3> <DL> <DT> 1.1 Operating Systems 1 <DT> 1.2 Our Approach 2 <DT> 1.3 What An Operating System Is Not 3 <DT> 1.4 An Operating System Viewed From The Outside 4 <DT> 1.4.1 The Xinu Small Machine Environment 4 <DT> 1.4.2 Xinu Services 4 <DT> 1.4.3 Concurrent Processing 6 <DT> 1.4.4 The Distinction Between Programs And Processes 6 <DT> 1.4.5 Process Exit 11 <DT> 1.4.6 Shared Memory 12 <DT> 1.4.7 Synchronization 13 <DT> 1.4.8 Mutual Exclusion 15 <DT> 1.5 An Operating System Viewed From The Inside 16 <DT> 1.6 Summary 18 <DT> For Further Study 19 <DT> Exercises 19 </DL> <H3> Chapter 2 An Overview of the Machine and Run-Time Environment </H3> <DL> <DT> 2.1 The Machine 21 <DT> 2.1.1 Physical Organization Of The Macintosh 22 <DT> 2.1.2 Logical Organization Of The Macintosh 23 <DT> 2.1.3 Registers In The MC68000 24 <DT> 2.1.4 The Address Space 24 <DT> 2.1.5 Processor Status Register 27 <DT> 2.1.6 Vectored Interrupts 28 <DT> 2.1.7 Exceptional Conditions 30 <DT> 2.2 Bit-Mapped Screen Display 30 <DT> 2.3 Windows 31 <DT> 2.4 The Mouse Interface 32 <DT> 2.5 Interrupts and Events 32 <DT> 2.6 Disk Storage Organization 33 <DT> 2.6.1 Disk Interface And Control Hardware 34 <DT> 2.6.2 The Pieces Of Disk Hardware 35 <DT> 2.7 The C Run-Time Environment 35 <DT> 2.8 Summary 37 <DT> For Further Study 38 <DT> Exercises 38 </DL> <H3> Chapter 3 List and Queue Manipulation </H3> <DL> <DT> 3.1 Linked Lists Of Processes 41 <DT> 3.2 Implementation Of The Q Structure 43 <DT> 3.2.1 In-Line Q Functions 45 <DT> 3.2.2 FIFO Queue Manipulation 45 <DT> 3.3 Priority Queue Manipulation 47 <DT> 3.4 List Initialization 49 <DT> 3.5 Summary 51 <DT> For Further Study 51 <DT> Exercises 51 </DL> <H3> Chapter 4 Scheduling and Context Switching </H3> <DL> <DT> 4.1 The Process Table 53 <DT> 4.2 Process States 56 <DT> 4.3 Selecting A Ready Process 56 <DT> 4.4 The Null Process 61 <DT> 4.5 Making A Process Ready 61 <DT> 4.6 Summary 63 <DT> For Further Study 63 <DT> Exercises 63 </DL> <H3> Chapter 5 More Process Management </H3> <DL> <DT> 5.1 Process Suspension And Resumption 65 <DT> 5.1.1 Implementation Of Resume 66 <DT> 5.1.2 The Return Values SYSERR And OK 68 <DT> 5.2 System Calls 68 <DT> 5.2.1 Implementation of Suspend 68 <DT> 5.2.2 Suspending The Current Process 69 <DT> 5.3 Process Termination 70 <DT> 5.4 Kernel Declarations 72 <DT> 5.5 Process Creation 74 <DT> 5.6 Utility Procedures 77 <DT> 5.7 Summary 80 <DT> For Further Study 80 <DT> Exercises 80 </DL> <H3> Chapter 6 Process Coordination </H3> <DL> <DT> 6.1 Low-Level Coordination Techniques 84 <DT> 6.2 Implementation Of High-Level Coordination Primitives 84 <DT> 6.2.1 Semaphore Data Structures 85 <DT> 6.3 Semaphore Creation and Deletion 89 <DT> 6.4 Summary 92 <DT> For Further Study 92 <DT> Exercises 92 </DL> <H3> Chapter 7 Memory Management </H3> <DL> <DT> 7.1 Memory Management On The Macintosh 96 <DT> 7.2 Dynamic Memory Requirements In Xinu 96 <DT> 7.3 Low-Level Memory Management Procedures 97 <DT> 7.4 The Location Of Allocated Storage 98 <DT> 7.5 The Implementation Of Xinu Memory Management 98 <DT> 7.5.1 Allocating Heap Storage 99 <DT> 7.5.2 Allocating Stack Storage 101 <DT> 7.5.3 Releasing Storage 102 <DT> 7.6 Summary 104 <DT> For Further Study 104 <DT> Exercises 105 </DL> <H3> Chapter 8 Interrupt Processing </H3> <DL> <DT> 8.1 Dispatching Interrupts 107 <DT> 8.2 Interrupt Dispatchers 108 <DT> 8.3 The Rules For Interrupt Processing 111 <DT> 8.4 Rescheduling While Processing An Interrupt 112 <DT> 8.5 Macintosh Interrupts And Hardware Events 113 <DT> 8.6 Summary 114 <DT> For Further Study 114 <DT> Exercises 115 </DL> <H3> Chapter 9 Real-Time Clock Management </H3> <DL> <DT> 9.1 The Real-Time Clock Mechanism 117 <DT> 9.2 Optimization Of Clock Interrupt Processing 118 <DT> 9.3 The Use Of A Real-Time Clock 119 <DT> 9.4 Delta List Processing 120 <DT> 9.5 Putting A Process To Sleep 121 <DT> 9.6 Delays Measured In Seconds 124 <DT> 9.7 Awakening Sleeping Processes 125 <DT> 9.8 Removing An Entry From The Clock Queue 126 <DT> 9.9 Deferred Clock Processing 127 <DT> 9.9.1 Procedures For Changing To And From Deferred Mode 127 <DT> 9.10 Clock Interrupt Dispatching 129 <DT> 9.11 Clock Initialization 131 <DT> 9.12 Summary 133 <DT> For Further Study 133 <DT> Exercises 133 </DL> <H3> Chapter 10 Message Passing </H3> <DL> <DT> 10.1 Illustration Of Message Passing Using Xinu 136 <DT> 10.2 Implementation Of Send 138 <DT> 10.3 Implementation Of Receive 139 <DT> 10.4 Summary 143 <DT> For Further Study 143 <DT> Exercises 143 </DL> <H3> Chapter 11 Process-Based Hardware Event Handling </H3> <DL> <DT> 11.1 Introduction 145 <DT> 11.2 A Process To Handle Firmware Events 146 <DT> 11.3 Mutual Exclusion In Event Handling 151 <DT> 11.4 Invocation Of Eventd 152 <DT> 11.5 Summary 153 <DT> For Further Study 153 <DT> Exercises 153 </DL> <H3> Chapter 12 Device Independent Input and Output </H3> <DL> <DT> 12.1 Properties Of The Input And Output Interface 156 <DT> 12.2 Abstract Operations 156 <DT> 12.3 Binding Abstract Operations To Real Devices 157 <DT> 12.4 Binding I/O Calls To Device Drivers At Run-Time 157 <DT> 12.5 The Implementation Of High-Level I/O Operations 161 <DT> 12.6 Opening And Closing Devices 166 <DT> 12.7 Null And Error Entries In Devtab 167 <DT> 12.8 Initialization Of The I/O System 168 <DT> 12.9 Summary 174 <DT> For Further Study 175 <DT> Exercises 175 </DL> <H3> Chapter 13 An Example Device Driver </H3> <DL> <DT> 13.1 The Device Type Con 177 <DT> 13.2 Upper And Lower Halves Of The Device Driver 179 <DT> 13.3 Synchronization Of The Upper And Lower Halves 180 <DT> 13.4 Control Block And Buffer Declarations 180 <DT> 13.5 Upper-Half Con Input Routines 184 <DT> 13.6 Upper-Half Con Output Routines 188 <DT> 13.7 Upper-Half Utility Routines 191 <DT> 13.8 Lower-Half Con Driver Routine 193 <DT> 13.9 Cooked Mode And Cbreak Mode Processing 198 <DT> 13.10 Console Control Block Initialization 198 <DT> 13.11 Device Driver Control 200 <DT> 13.12 Opening The Console Device 202 <DT> 13.13 Summary 203 <DT> For Further Study 203 <DT> Exercises 203 </DL> <H3> Chapter 14 Window Management Using Devices </H3> <DL> <DT> 14.1 Introduction 205 <DT> 14.2 The Macintosh Window Paradigm 206 <DT> 14.3 A Text Window Model 206 <DT> 14.4 Windows As Devices 207 <DT> 14.5 The Pseudo-Device Concept 207 <DT> 14.6 The Master Window Pseudo-Device 207 <DT> 14.7 Window Pseudo-Device 208 <DT> 14.8 Window Device Control 214 <DT> 14.9 Closing A Window Pseudo-Device 226 <DT> 14.10 Initializing A Window Pseudo-Device 228 <DT> 14.11 Window Master Pseudo-Device 229 <DT> 14.12 Driver Configuration 237 <DT> 14.13 Summary 237 <DT> For Further Study 238 <DT> Exercises 238 </DL> <H3> Chapter 15 System Initialization </H3> <DL> <DT> 15.1 Starting From Scratch 239 <DT> 15.2 Booting Xinu 240 <DT> 15.3 Operating System Startup 241 <DT> 15.4 Initializing System Data Structures 241 <DT> 15.5 Transforming The Program Into A Process 246 <DT> 15.6 Macintosh-Dependent Initialization 246 <DT> 15.7 Summary 253 <DT> For Further Study 253 <DT> Exercises 253 </DL> <H3> Chapter 16 High-Level Memory Management and Message Passing </H3> <DL> <DT> 16.1 Self-Initializing Modules 256 <DT> 16.1.1 Specifying Initialization 256 <DT> 16.1.2 Automatic Initialization 256 <DT> 16.2 Memory Marking 257 <DT> 16.3 Implementation Of Memory Marking 257 <DT> 16.4 Partitioned Space Allocation 259 <DT> 16.5 Buffer Pools 260 <DT> 16.6 Returning Buffers To The Buffer Pool 263 <DT> 16.7 Creating A Buffer Pool 264 <DT> 16.8 Initializing The Buffer Pool Table 265 <DT> 16.9 Communication Ports 266 <DT> 16.10 The Implementation Of Ports 267 <DT> 16.11 Other Operations On Ports 275 <DT> 16.12 Summary 279 <DT> For Further Study 279 <DT> Exercises 279 </DL> <H3> Chapter 17 A Disk Driver </H3> <DL> <DT> 17.1 Operations Supplied By The Disk Driver 281 <DT> 17.2 The List Of Pending Disk Requests 282 <DT> 17.3 Enqueuing Disk Requests 284 <DT> 17.4 Optimizing the Request Queue 287 <DT> 17.5 The Block Copy Utility 289 <DT> 17.6 Starting A Disk Operation 289 <DT> 17.7 Driver Initialization 292 <DT> 17.8 The Upper-Half Disk Read Routine 293 <DT> 17.9 The Upper-Half Disk Output Routine 295 <DT> 17.10 Implementation Of The Upper-Half Output Routine 297 <DT> 17.11 The Lower-Half Of The Disk Driver 298 <DT> 17.12 Flushing Pending Requests 299 <DT> 17.13 Disk Ejection 302 <DT> 17.14 Summary 303 <DT> For Further Study 304 <DT> Exercises 304 </DL> <H3> Chapter 18 File Systems </H3> <DL> <DT> 18.1 What Is A File System? 305 <DT> 18.2 Layers Of The File System 306 <DT> 18.3 Semantics Of File Manipulation 307 <DT> 18.4 Disk And File Servers 308 <DT> 18.5 Local File System Interface 308 <DT> 18.6 Data Structures For The File System 309 <DT> 18.7 The Directory Layer 310 <DT> 18.8 A Macintosh File System Interface 311 <DT> 18.9 Using The Device Switch Table For Files 311 <DT> 18.10 Establishing A Pseudo-Device 313 <DT> 18.10.1 The Pseudo-Device Seek Routine 317 <DT> 18.10.2 The Pseudo-Device Read Routine 318 <DT> 18.10.3 The Pseudo-Device Write Routine 319 <DT> 18.10.4 The Pseudo-Device Getc Routine 320 <DT> 18.10.5 The Pseudo-Device Putc Routine 320 <DT> 18.10.6 The Pseudo-Device Close Routine 321 <DT> 18.10.7 The Pseudo-Device Control Routine 322 <DT> 18.10.8 The Pseudo-Device Initialization Routine 325 <DT> 18.10.9 Lower-Half Routine For The Pseudo-Device 326 <DT> 18.10.10 Firmware File Manipulation Interface 327 <DT> 18.11 Summary 329 <DT> For Further Study 329 <DT> Exercises 330 </DL> <H3> Chapter 19 A Syntactic Namespace </H3> <DL> <DT> 19.1 Introduction 331 <DT> 19.2 The Problem With File Names 332 <DT> 19.2.1 MS-DOS 332 <DT> 19.2.2 UNIX 332 <DT> 19.2.3 V System 332 <DT> 19.2.4 Newcastle Connection 333 <DT> 19.2.5 IBIS 333 <DT> 19.2.6 TILDE 333 <DT> 19.3 Naming System Design Alternatives 333 <DT> 19.4 A Syntactic Namespace 334 <DT> 19.5 Patterns And Replacements 334 <DT> 19.6 Prefix Patterns 334 <DT> 19.7 Implementation Of A Simple Syntactic Namespace 335 <DT> 19.7.1 The Pseudo-Device NAMESPACE 335 <DT> 19.7.2 Definitions Of Data Structures And Constants 335 <DT> 19.7.3 Adding Mappings To The Prefix Table 336 <DT> 19.7.4 Removing A Name Mapping 338 <DT> 19.7.5 Mapping Names With The Prefix Table 339 <DT> 19.7.6 Iterative Resolution Of Recursive Mappings 341 <DT> 19.7.7 Opening A Named File 342 <DT> 19.7.8 Namespace Initialization 342 <DT> 19.8 Choosing Initial Prefix Mappings 344 <DT> 19.8.1 Default Hierarchy And The Null Prefix 344 <DT> 19.8.2 A Common Name Syntax 345 <DT> 19.9 Additional File Manipulation Commands 346 <DT> 19.9.1 Removing A File 346 <DT> 19.9.2 Renaming A File 347 <DT> 19.9.3 Testing File Accessibility 348 <DT> 19.10 Advantages Of The Namespace Approach 349 <DT> 19.11 The Limits Of Fixed Prefix Patterns 350 <DT> 19.12 Generalized Patterns 350 <DT> 19.13 Configuring The Namespace Pseudo-Device 351 <DT> 19.14 Summary 351 <DT> For Further Study 352 <DT> Exercises 352 </DL> <H3> Chapter 20 User Interface Design </H3> <DL> <DT> 20.1 Introduction 355 <DT> 20.2 What Is A User Interface? 355 <DT> 20.3 The Definition Of Goodness 356 <DT> 20.4 What We Seek 356 <DT> 20.5 Interface Hardware 357 <DT> 20.5.1 Keyboard Input Hardware 357 <DT> 20.5.2 Display Hardware 358 <DT> 20.5.3 Pointing Device 359 <DT> 20.6 The Two-Tier Interface Model 359 <DT> 20.7 Syntactic Flexibility 360 <DT> 20.8 Semantic Features And Issues 361 <DT> 20.8.1 Command Set 361 <DT> 20.8.2 Design Principles 361 <DT> 20.8.3 Concurrent Processing 362 <DT> 20.8.4 Interprocess Communication 362 <DT> 20.8.5 I/O And File Specification 363 <DT> 20.8.6 Response To Requests 363 <DT> 20.9 Syntactic Features And Issues 363 <DT> 20.9.1 Lexical Conventions And Quoting 364 <DT> 20.9.2 Command History And Editing 364 <DT> 20.9.3 Abbreviations And Command Aliases 364 <DT> 20.9.4 Command Name Expansion 365 <DT> 20.9.5 Typed Vs. Untyped Arguments 365 <DT> 20.9.6 Programming Language Constructs 366 <DT> 20.9.7 Windows 366 <DT> 20.10 Modifying The Syntactic Interface 368 <DT> 20.10.1 Parameterization Vs. Extensibility 368 <DT> 20.10.2 Multiple Syntactic Interfaces 369 <DT> 20.11 Summary 369 <DT> For Further Study 370 <DT> Exercises 370 </DL> <H3> Chapter 21 An Example User Interface: The Xinu Shell </H3> <DL> <DT> 21.1 Introduction 371 <DT> 21.2 The Assumed Interface Hardware 371 <DT> 21.3 A Basic Design Decision 372 <DT> 21.4 Overview Of Shell Organization And Operation 372 <DT> 21.4.1 Input Form 372 <DT> 21.5 Imperative Vs. Interrogative Interaction Form 372 <DT> 21.5.1 Processes Vs. Procedures 373 <DT> 21.5.2 File Name Independence 373 <DT> 21.6 Command Syntax 373 <DT> 21.6.1 The Definition Of Lexical Tokens 373 <DT> 21.6.2 Lexical Details and Quoting 374 <DT> 21.6.3 The Definition Of Command-Line Syntax 375 <DT> 21.7 Shell Semantics 376 <DT> 21.8 Implementation Of The Example Shell 377 <DT> 21.8.1 Shell Definitions 377 <DT> 21.8.2 Declaration Of Commands 379 <DT> 21.8.3 Dividing The Command Line Into Tokens 381 <DT> 21.8.4 The Heart Of The Command Interpreter 384 <DT> 21.8.5 Command Lookup And Invocation Of Builtins 389 <DT> 21.8.6 I/O Redirection 390 <DT> 21.8.7 Passing Arguments To The Command Process 391 <DT> 21.8.8 Starting A Command In Background 394 <DT> 21.8.9 Foreground And Background Processing 395 <DT> 21.8.10 Moving A Command To Background 396 <DT> 21.8.11 User Login 397 <DT> 21.9 Summary 399 <DT> For Further Study 399 <DT> Exercises 400 </DL> <H3> Chapter 22 An Example Set Of Shell Commands </H3> <DL> <DT> 22.1 Introduction 403 <DT> 22.2 Command And Procedure Names 403 <DT> 22.2.1 Choosing Command Names 403 <DT> 22.2.2 Choosing Procedure Names 404 <DT> 22.3 Types Of Commands 404 <DT> 22.4 Command Implementation 405 <DT> 22.5 General Information Commands 405 <DT> 22.5.1 Time And Date Command 405 <DT> 22.5.2 Help Command 409 <DT> 22.6 System Information Commands 410 <DT> 22.6.1 Bpool Command 410 <DT> 22.6.2 Devs Command 411 <DT> 22.6.3 Mem Command 412 <DT> 22.6.4 Ps Command 415 <DT> 22.6.5 Who Command 417 <DT> 22.7 Computational Commands 419 <DT> 22.7.1 Cat Command 419 <DT> 22.7.2 Close Command 421 <DT> 22.7.3 Cp Command 422 <DT> 22.7.4 Echo Command 423 <DT> 22.7.5 Exit And Logout Commands 424 <DT> 22.7.6 Kill Command 425 <DT> 22.7.7 Mount Command 426 <DT> 22.7.8 Mv Command 428 <DT> 22.7.9 Rm Command 429 <DT> 22.7.10 Shutdown Command 430 <DT> 22.7.11 Sleep Command 431 <DT> 22.7.12 Unmount Command 432 <DT> 22.8 Summary 433 <DT> For Further Study 433 <DT> Exercises 433 </DL> <H3> Chapter 23 Exception Handling and Support Routines </H3> <DL> <DT> 23.1 Exceptions, Traps, And Illegal Interrupts 437 <DT> 23.2 Interrupt Vector Initialization 438 <DT> 23.3 Implementation Of Panic 441 <DT> 23.4 Formatted Output 451 <DT> 23.4.1 Printf And Fprintf 459 <DT> 23.4.2 Kprintf 460 <DT> 23.5 Summary 463 <DT> For Further Study 463 <DT> Exercises 463 </DL> <H3> Chapter 24 System Configuration </H3> <DL> <DT> 24.1 The Need For Multiple Configurations 465 <DT> 24.2 Static vs. Dynamic Configuration 466 <DT> 24.3 The Details Of Configuration In Xinu 466 <DT> 24.3.1 Input To Config 470 <DT> 24.3.2 Computation Of Minor Device Numbers 471 <DT> 24.4 Configuring A Xinu System 472 <DT> 24.4.1 Counting Devices 472 <DT> 24.5 System Calls And Procedures 473 <DT> 24.6 Summary 474 <DT> For Further Study 474 <DT> Exercises 474 <DT> Xinu Shell Commands 489 <DT> System Calls 521 <DT> Library Procedures 577 <DT> Device Descriptions 598 </DL> <H3> Index </H3> <BR> <BR> <H4><A HREF="osbooks.html">Return to list of Comer's OS books</A></H4> <BR> <BR> <H4><A HREF="http://www.cs.purdue.edu/people/comer">Return to Comer's homepage</A></H4> </HTML> </HTML>
</DOC>
