<DOC>
<DOCNO> http://www.cs.purdue.edu/homes/hosking/352/119/hw2.html </DOCNO>
<!doctype html public "-//w3c//dtd html 4.0 transitional//en"> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> <meta name="GENERATOR" content="Mozilla/4.72 [en] (X11; U; OSF1 V5.0 alpha) [Netscape]"> <meta name="Author" content="Antony Hosking"> <title>CS352: Homework 3</title> </head> <body text="#333333" bgcolor="#FFFFFF" link="#006699" vlink="#999900" alink="#999900"> <h1>Homework 2</h1> <h2>Due in class Wednesday November 16th</h2> <p> <ol> <li> Using the C compiler (<tt>gcc</tt>) installed on the lab machines, compile some small test functions into assembly language (<tt>gcc -S</tt>). Turn on optimizations (<tt>gcc -O -S</tt>). Then evaluate the compiled programs by these criteria: <ol type="i"> <li>Are local variables kept in registers?</li> <li>If local variable <tt>b</tt> is live across more that one procedure call, is it kept in a callee-save register? Explain how doing this would speed up the following program: <pre> void g(void); void h(int); int f(int a) { int b = a+1; g(); h(b); return b+2; } </pre> </li> <li> If local variable <tt>x</tt> is never live across a procedure call, is it properly kept in a caller-save register? Explain how doing this would speed up the following program: <pre> void f(int); void h(int y) { int x = y+1; f(y); f(2); } </li> </ol> <li> Generate assembly language for this program: <pre> void h(int, int); void m(int x, int y) { h(y,y); h(x,x); } </pre> Clearly, if arguments to <tt>m(x,y)</tt> arrive in registers <tt>r1</tt> and <tt>r2</tt>, and arguments to <tt>h</tt> must be passed in <tt>r1</tt> and <tt>r2</tt>, then <tt>x</tt> cannot stay in <tt>r1</tt> during the marshaling of arguments to <tt>h(y,y)</tt>. Explain when and how the C compiler moves <tt>x</tt> out of <tt>r1</tt> so as to call <tt>h(y,y)</tt>. </li> <li> For each of the variables <tt>a</tt>, <tt>b</tt>, <tt>c</tt>, <tt>d</tt>, <tt>e</tt> in the following C program, say whether the compiler allocates it in memory or a register, and why. <pre> int g(int, int *); int f(int a, int b) { int c[3], d, e; d = a+1; e = g(c, &b); return e+c[1]+b; } </pre> </li> <li> Compile the following program to assembly language: <pre> int leaf(int a, int b, int c, int d, int e, int f, int g, int h) { return a+b+c+d+e+f+g+h; } int foo(void); int nonleaf (int a, int b, int c, int d, int e, int f, int g, int h) { int x = foo(); return a + b + c + d + e + f + g + h + x; } </pre> Then identify all the components of the calling sequence and explain what each line of assembly language does (including the pseudo-instructions). </li> </ol> </body> </html> </html>
</DOC>
