<DOC>
<DOCNO> http://www.cs.purdue.edu/homes/xyzhang/debugging.html </DOCNO>
<!dOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"> <HTML><HEAD><TITLE>Xiangyu's Projects</TITLE> <META http-equiv=Content-Type content="text/html; charset=iso-8859-1"> <META content=xxx name=Author> <META content="MSHTML 6.00.2800.1264" name=GENERATOR></HEAD> <BODY text=#000000 vLink=#cc0000 aLink=#cc0000 link=#cc0000 background="figures/yellowbg.jpg"> <STYLE type=text/css>A { TEXT-DECORATION: none } </STYLE> <h2> Execution Indexing and Its Application in Debugging </h2> <img border=0 width=800 height=5 src="figures/line.bmp"> <p> <font size=4><b>Execution indexing</b></font> (EI) <a href="Comp/pldi08.pdf">[PLDI'08]</a> is a dynamic analysis primitive that facilitates comparison across executions. These executions could be those induced by different inputs on the same program, those with the same inputs but different schedules, or even those induced by the same input on different program versions, depending on the scenarios. It canonicalizes the control flow of the executions and allows them to be properly aligned before comparison, to the precision level of individual executed instructions. This is particularly necessary in the presence of loops, recursions and control flow divergence. Note that the <em>n</em>th instance of an instruction in one run unlikely corresponds to that in the other run. <!-- technique that aligns different executions such that they can be rigorously and precisely compared. This is particularly meaningful in comparison based automated debugging in which one execution is passing and the other is failing, and failure explanation is achieved by comparing the two executions and reasoning about the differences. In EI, alignments are achieved by providing canonical representations of executions called execution indices. </p> <p> EI aims to achieve alignment with the finest precsion. It aligns execution control flow to the level of individual executed instructions. For instance, given an instruction instance in one execution, it identifies the corresponding instruction instance in the other execution. The alignment should tolerate the differences in the two control flows, such as those caused by different predicate outcomes, different loop iterations, different numbers of recursions, different function pointers, and their arbitrary combinations. </p> --!> <p> Aligning along the control flow dimension is not sufficient in many applications, we developed <font size=4><b>memory indexing</b></font> (MI) <a href="Comp/fse10.pdf">[FSE'10]</a> to align along the memory dimension. In particular, given a memory location in one run, it identifies the semantically corresponding memory location in the other run. Note that due to execution differences, different amounts of memory may be allocated, and the same object may be allocated in different locations in the two runs. MI tolerates such differences by canonicalizing memory addresses. </p> <p> The two primitives give rise to new opportunities for many applications. In particular, it allows advance in automated debugging. In scenarios when both the failing execution and a reference execution (e.g. a passing run with a slightly different input) are available, effective automated debugging can be achieved by comparing the two runs to <font size=4><b>identify the failure causal path</b></font> (<a href="Comp/fse10.pdf">[FSE'10]</a> and <a href="Comp/fase09.pdf">[FASE'09]</a>), which is the path leading from the root cause to the failure with each step causally connected. It is key to understanding and fixing the fault. EI and MI are leveraged to compare program states at aligned execution points. We reason about if a subset of state differences is critical to the failure by copying such differences from the failing run to the passing run and observing if such state mutation can induce the failure in the passing run. Robust state replacement can not be achieved without indexing. For instance, copying the absoluate value of a pointer variable from one run to the run is problematic. </p> <h3>Funding</h3> <table> <tr height="40"> <td valign="top" height="40"><img align="left" width="42" height="35" BORDER=0 src="figures/nsf.gif" alt=""></a></td> <td height="40" valign="top"><a href="https://www.fastlane.nsf.gov/servlet/showaward?award=0917007"> <font face="Arial" size="2"> <i> Automated Software Failure Causal Path Computation</i></a> NSF-CCF-0917007, 2009-2012.</td> </tr> <tr height="40"> <td valign="top" height="40"><img align="left" width="42" height="35" BORDER=0 src="figures/nsf.gif" alt=""></a></td> <td height="40" valign="top"><a href="https://www.fastlane.nsf.gov/servlet/showaward?award=0845870"> <font face="Arial" size="2"> <i> NSF Career: Scalable Dynamic Program Reasoning</i></a> NSF-CCF-0845870, 2008-2013.</td> </tr> </table> <h3><a href="http://www.youtube.com/watch?v=36cXwVqMo30">A demo for the debugging technique</a><h3> <h3>Students</h3> <ul> <li> <a href="http://www.cs.purdue.edu/homes/wsumner">William N. Sumner</a><br> </li> <li> Dasarath Weeratunge </li> <li> <a href="http://www.cs.purdue.edu/homes/zheng16">Yunhui Zheng</a><br> </li> <li> <a href="http://www.cs.purdue.edu/homes/kim1051">Dohyeong Kim</a><br> </li> </ul> <h3>Publications</h3> <h4><u>Fundamentals</u></h4> <table> <tr> <td align="left" valign="top"> <font color="#660000" > <b>FSE</b></font></td> <td align="left" valign="top"> <b>W. N. Sumner and X. Zhang</b>. Memory Indexing: Canonicalizing Addresses Across Executions <em>,<br> the 18th ACM SIGSOFT Symposium on Foundations of Software, 2010. </em><br> [<a href="http://portal.acm.org/citation.cfm?id=1882324&preflayout=flat#abstract">abstract</a>][<a href="Comp/fse10.pdf">pdf</a>] </font> </td> </tr> <tr> <td align="left" valign="top"> <font color="#660000" > <b>PLDI</b></font></td> <td align="left" valign="top"> <b>B. Xin, W. N. Sumner, and X. Zhang</b>. Efficient Program Execution Indexing,<br> <em>ACM SIGPLAN Conference on Programming Language Design and Implementation</em>, 2008.<br> [<a href="http://portal.acm.org/citation.cfm?id=1375611&CFID=18721242&CFTOKEN=74393333#abstract">abstract</a>][<a href="Comp/pldi08.pdf">pdf</a>] </font> </font></td> </tr> </table> <h4><u>Applications</u></h4> <table> <tr> <td align="left" valign="top"> <font color="#660000" > <b>OOPSLA</b></font></td> <td align="left" valign="top"> <b>D. Weeratunge, X. Zhang, and S. Jagannathan</b> Accentuating the Positive: Atomicity Inference and Enforcement Using Correct Executions</a> <em>,<br> Object Oriented Programming, Systems, Languages and Applications, 2011. </em><br> [<a href="Comp/oopsla11.pdf">abstract</a>][<a href="Comp/oopsla11.pdf">pdf</a>] </font> </td> </tr> <tr> <td align="left" valign="top"> <font color="#660000" > <b>ISSTA</b></font></td> <td align="left" valign="top"> <b>W. N. Sumner and X. Zhang</b>. Selecting Peers for Execution Comparison <em>,<br> International Symposium on Software Testing and Analysis, 2011. </em><br> [<a href="Comp/issta11.pdf">abstract</a>][<a href="Comp/issta11.pdf">pdf</a>] </font> </td> </tr> <tr> <td align="left" valign="top"> <font color="#660000" > <b>ISSTA</b></font></td> <td align="left" valign="top"> <b>D. Weeratunge, X. Zhang, W. N. Sumner, and S. Jagannathan</b>. Analyzing Concurrency Bugs using Dual Slicing <em>,<br> International Symposium on Software Testing and Analysis, 2010. </em><br> [<a href="http://portal.acm.org/citation.cfm?id=1831708.1831740&coll=DL&dl=ACM&CFID=18721242&CFTOKEN=74393333#abstract">abstract</a>][<a href="Comp/issta085a-weeratunge.pdf">pdf</a>] </font> </td> </tr> <tr> <td align="left" valign="top"> <font color="#660000" > <b>ASPLOS</b></font></td> <td align="left" valign="top"> <b>D. Weeratunge, X. Zhang, and S. Jagannathan</b>. Analyzing Multicore Dumps to Facilitate Concurrency Bug Reproduction <em>,<br> the 15th International Conference on Architectural Support for Programming Languages and Operating Systems, 2010. </em><br> [<a href="http://portal.acm.org/citation.cfm?id=1736020.1736039&coll=DL&dl=ACM&CFID=18721242&CFTOKEN=74393333#abstract">abstract</a>][<a href="Comp/asplos10.pdf">pdf</a>] </font> </td> </tr> <tr> <td align="left" valign="top"> <font color="#660000" > <b>CGO</b></font></td> <td align="left" valign="top"> <b> X. Zhang, A. Navabi, and S. Jagannathan </b>. Alchemist: A Transparent Dependence Distance Profling Infrastructure <em>,<br> The International Symposium on Code Generation and Optimization, 2009. </em><br> [<a href="http://portal.acm.org/citation.cfm?id=1545006.1545052&coll=DL&dl=ACM&CFID=18721242&CFTOKEN=74393333#abstract">abstract</a>][<a href="Comp/cgo09.pdf">pdf</a>] </font> </td> </tr> <tr> <td align="left" valign="top"> <font color="#660000" > <b>FASE</b></font></td> <td align="left" valign="top"> <b> W. N. Sumner and X. Zhang </b>. Algorithms for Automatically Computing the Causal Paths of Failures <em>,<br> Fundamental Approaches to Software Engineering, 2009. </em><br> [<a href="http://portal.acm.org/citation.cfm?id=1533046#abstract">abstract</a>][<a href="Comp/fase09.pdf">pdf</a>] </font> </td> </tr> </BODY></HTML> </BODY></HTML>
</DOC>
