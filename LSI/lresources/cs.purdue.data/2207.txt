<DOC>
<DOCNO> http://www.cs.purdue.edu/homes/dec/xinu1.pc.cont.html </DOCNO>
<HTML> <H2> Table of Contents: PC version of Operating System Design</H2> <BR> <H3> Preface To The PC Edition </H3> <H3> Foreword To The First Edition </H3> <H3> Preface To The First Edition </H3> <H3> Chapter 1 Introduction and Overview </H3> <DL> <DT> 1.1 Operating Systems 1 <DT> 1.2 Our Approach 2 <DT> 1.3 What An Operating System Is Not 3 <DT> 1.4 An Operating System Viewed From The Outside 4 <DT> 1.4.1 The PC-Xinu Small Machine Environment 4 <DT> 1.4.2 PC-Xinu Services 4 <DT> 1.4.3 Concurrent Processing 5 <DT> 1.4.4 The Distinction Between Programs And Processes 6 <DT> 1.4.5 Process Exit 10 <DT> 1.4.6 Shared Memory 10 <DT> 1.4.7 Synchronization 12 <DT> 1.4.8 Mutual Exclusion 14 <DT> 1.5 An Operating System Viewed From The Inside 15 <DT> 1.6 Summary 17 <DT> For Further Study 18 <DT> Exercises 18 </DL> <H3> Chapter 2 An Overview of the Machine and Run-Time Environment </H3> <DL> <DT> 2.1 The Machine 19 <DT> 2.2 Physical Organization Of The PC 20 <DT> 2.3 Logical Organization Of The PC 21 <DT> 2.3.1 The Address Space 21 <DT> 2.3.2 Registers In The 8088 23 <DT> 2.3.3 FLAGS Word 24 <DT> 2.3.4 Vectored Interrupts 25 <DT> 2.3.5 Exceptional Conditions 26 <DT> 2.3.6 Software Interrupts 27 <DT> 2.3.7 The ROM BIOS 27 <DT> 2.3.8 BIOS Interrupt Service Routines 28 <DT> 2.3.9 Pseudo-device interrupts 29 <DT> 2.3.10 Interrupt Vector Summary 29 <DT> 2.4 Standard PC I/O Devices 29 <DT> 2.4.1 Keyboard 30 <DT> 2.4.2 Video Display 31 <DT> 2.4.3 Floppy Disk 32 <DT> 2.4.4 The Pieces Of Disk Hardware 34 <DT> 2.4.5 Logical sector numbers 35 <DT> 2.4.6 Real-Time Clock 36 <DT> 2.5 The C Run-Time Environment 37 <DT> 2.6 Assembly Language Interface 39 <DT> 2.6.1 Low-Level Keyboard Input 40 <DT> 2.6.2 Low-Level Video Display 44 <DT> 2.6.3 Low-Level Disk Services 47 <DT> 2.7 Summary 51 <DT> For Further Study 52 <DT> Exercises 52 </DL> <H3> Chapter 3 List and Queue Manipulation </H3> <DL> <DT> 3.1 Linked Lists Of Processes 55 <DT> 3.2 Implementation Of The Q Structure 57 <DT> 3.2.1 In-Line Q Functions 59 <DT> 3.2.2 FIFO Queue Manipulation 59 <DT> 3.3 Priority Queue Manipulation 61 <DT> 3.4 List Initialization 63 <DT> 3.5 Summary 65 <DT> For Further Study 65 <DT> Exercises 65 </DL> <H3> Chapter 4 Scheduling and Context Switching </H3> <DL> <DT> 4.1 The Process Table 67 <DT> 4.2 Process States 69 <DT> 4.3 Selecting A Ready Process 70 <DT> 4.4 The Null Process 75 <DT> 4.5 Making A Process Ready 76 <DT> 4.6 Summary 77 <DT> For Further Study 77 <DT> Exercises 77 </DL> <H3> Chapter 5 More Process Management </H3> <DL> <DT> 5.1 Process Suspension And Resumption 79 <DT> 5.1.1 Implementation Of Resume 80 <DT> 5.1.2 The Return Values SYSERR And OK 82 <DT> 5.2 System Calls 82 <DT> 5.2.1 Disable and Restore 82 <DT> 5.2.2 Implementation of Suspend 84 <DT> 5.2.3 Suspending The Current Process 85 <DT> 5.3 Process Termination 86 <DT> 5.4 Kernel Declarations 88 <DT> 5.5 Process Creation 90 <DT> 5.6 Utility Procedures 94 <DT> 5.7 Summary 96 <DT> For Further Study 97 <DT> Exercises 97 </DL> <H3> Chapter 6 Process Coordination </H3> <DL> <DT> 6.1 Low-Level Coordination Techniques 100 <DT> 6.2 Implementation Of High-Level Coordination Primitives 100 <DT> 6.2.1 Semaphore Data Structures 101 <DT> 6.3 Semaphore Creation and Deletion 105 <DT> 6.4 Returning The Semaphore Count 108 <DT> 6.5 Other Semaphore Utilities 109 <DT> 6.6 Summary 110 <DT> For Further Study 111 <DT> Exercises 111 </DL> <H3> Chapter 7 Message Passing </H3> <DL> <DT> 7.1 Message Passing In PC-Xinu 113 <DT> 7.2 Implementation Of Send 114 <DT> 7.3 Implementation Of Receive 118 <DT> 7.4 Summary 120 <DT> For Further Study 120 <DT> Exercises 121 </DL> <H3> Chapter 8 Memory Management </H3> <DL> <DT> 8.1 Memory Management On The 8088 124 <DT> 8.2 Dynamic Memory Requirements In PC-Xinu 124 <DT> 8.3 Low-Level Memory Management Procedures 125 <DT> 8.4 The Location Of Allocated Storage 125 <DT> 8.5 The Implementation Of PC-Xinu Memory Management 126 <DT> 8.5.1 Allocating Storage 127 <DT> 8.5.2 Releasing Storage 129 <DT> 8.6 Summary 131 <DT> For Further Study 131 <DT> Exercises 132 </DL> <H3> Chapter 9 Interrupt Processing </H3> <DL> <DT> 9.1 Dispatching Interrupts 133 <DT> 9.2 The Interrupt Dispatcher 134 <DT> 9.2.1 The Intmap table 134 <DT> 9.2.2 Implementation of the Interrupt Dispatcher 140 <DT> 9.2.3 Deferred Rescheduling 140 <DT> 9.2.4 To BIOS or Not to BIOS 141 <DT> 9.3 Process Control Of Deferred Rescheduling 141 <DT> 9.4 The Rules For Interrupt Processing 144 <DT> 9.5 Rescheduling While Processing An Interrupt 145 <DT> 9.6 PC Interrupt Vectors 146 <DT> 9.7 Summary 147 <DT> For Further Study 147 <DT> Exercises 148 </DL> <H3> Chapter 10 Real-Time Clock Management </H3> <DL> <DT> 10.1 The Real-Time Clock Mechanism 149 <DT> 10.2 PC Real-Time Clock Interrupts 150 <DT> 10.3 The Use Of A Real-Time Clock 151 <DT> 10.4 Delta List Processing 152 <DT> 10.5 Putting A Process To Sleep 154 <DT> 10.6 Delays Measured In Seconds 156 <DT> 10.7 Clock Interrupt Processing 158 <DT> 10.8 Awakening Sleeping Processes 159 <DT> 10.9 Deferred Clock Processing 160 <DT> 10.9.1 Procedures For Changing To And From Deferred Mode 160 <DT> 10.10 Clock Initialization 161 <DT> 10.11 Summary 162 <DT> For Further Study 162 <DT> Exercises 163 </DL> <H3> Chapter 11 Device Independent Input and Output </H3> <DL> <DT> 11.1 Properties Of The Input And Output Interface 166 <DT> 11.2 Abstract Operations 166 <DT> 11.3 Binding Abstract Operations To Real Devices 167 <DT> 11.4 Binding I/O Calls To Device Drivers At Run-Time 168 <DT> 11.5 The Implementation Of High-Level I/O Operations 171 <DT> 11.6 Translating Device Names Into Descriptors 175 <DT> 11.7 Opening And Closing Devices 175 <DT> 11.8 Null And Error Entries In Devtab 177 <DT> 11.9 Initialization Of The I/O System 178 <DT> 11.10 Interrupt Vector Initialization 182 <DT> 11.11 Summary 184 <DT> For Further Study 184 <DT> Exercises 185 </DL> <H3> Chapter 12 An Example Device Driver </H3> <DL> <DT> 12.1 The Device Type Tty 187 <DT> 12.2 Upper And Lower Halves Of The Device Driver 188 <DT> 12.3 Synchronization Of The Upper And Lower Halves 190 <DT> 12.4 Control Block And Buffer Declarations 190 <DT> 12.5 Upper-Half Tty Input Routines 194 <DT> 12.6 Upper-Half Tty Output Routines 198 <DT> 12.7 Lower-Half Tty Driver Routines 202 <DT> 12.7.1 Watermarks And Delayed Signals 205 <DT> 12.7.2 Lower-Half Input Processing 205 <DT> 12.7.3 Cooked Mode And Cbreak Mode Processing 211 <DT> 12.8 Keyboard Interrupt Handling 212 <DT> 12.9 Tty Control Block Initialization 212 <DT> 12.10 Device Driver Control 214 <DT> 12.11 Summary 216 <DT> For Further Study 216 <DT> Exercises 216 </DL> <H3> Chapter 13 System Initialization </H3> <DL> <DT> 13.1 Starting From Scratch 219 <DT> 13.2 Booting PC-Xinu 220 <DT> 13.3 System Startup 221 <DT> 13.4 Transforming The Program Into A Process 228 <DT> 13.5 Summary 231 <DT> For Further Study 231 <DT> Exercises 231 </DL> <H3> Chapter 14 Window Management </H3> <DL> <DT> 14.1 Windows As Pseudo-Devices 233 <DT> 14.2 Window-Specific Fields In The tty Structure 234 <DT> 14.2.1 The CURSOR Type 234 <DT> 14.2.2 Relative Cursor Positions 235 <DT> 14.2.3 Window Borders And Character Attributes 235 <DT> 14.3 Opening A Window 236 <DT> 14.4 Upper-Level Window Driver Routines 245 <DT> 14.4.1 Window Output Operations 245 <DT> 14.4.2 Window Input And Control Operations 249 <DT> 14.4.3 Closing A Window 253 <DT> 14.5 The Lower-Half Window Output Server Process 255 <DT> 14.6 Low-Level PC Screen Operations 260 <DT> 14.7 Window Keyboard Input 262 <DT> 14.8 Window Driver Initialization 263 <DT> 14.9 Summary 264 <DT> For Further Study 265 <DT> Exercises 265 </DL> <H3> Chapter 15 High-Level Memory Management and Message Passing </H3> <DL> <DT> 15.1 Self-Initializing Modules 268 <DT> 15.1.1 Specifying Initialization 268 <DT> 15.1.2 Automatic Initialization 268 <DT> 15.2 Memory Marking 269 <DT> 15.3 Implementation Of Memory Marking 269 <DT> 15.4 Partitioned Space Allocation 271 <DT> 15.5 Buffer Pools 272 <DT> 15.6 Returning Buffers To The Buffer Pool 275 <DT> 15.7 Creating A Buffer Pool 277 <DT> 15.8 Initializing The Buffer Pool Table 278 <DT> 15.9 Communication Ports 279 <DT> 15.10 The Implementation Of Ports 279 <DT> 15.10.1 Ports Initialization 281 <DT> 15.10.2 Port Creation 283 <DT> 15.10.3 Sending To Ports 285 <DT> 15.10.4 Receiving From Ports 288 <DT> 15.11 Other Operations On Ports 289 <DT> 15.12 Summary 294 <DT> For Further Study 294 <DT> Exercises 294 </DL> <H3> Chapter 16 A Disk Driver </H3> <DL> <DT> 16.1 Operations Supplied By The Disk Driver 297 <DT> 16.2 The List Of Pending Disk Requests 298 <DT> 16.3 Enqueuing Disk Requests 300 <DT> 16.4 Optimizing The Request Queue 303 <DT> 16.5 Driver Initialization 305 <DT> 16.6 The Upper-Half Read Routine 307 <DT> 16.7 The Upper-Half Write Routine 309 <DT> 16.8 Implementation Of The Upper-Half Write Routine 310 <DT> 16.9 The Upper-Half Seek Routine 311 <DT> 16.10 The Lower-Half Of The Disk Driver 313 <DT> 16.11 Flushing Pending Requests 315 <DT> 16.12 Summary 318 <DT> For Further Study 318 <DT> Exercises 319 </DL> <H3> Chapter 17 File Systems </H3> <DL> <DT> 17.1 What Is A File System? 321 <DT> 17.2 Disk And File Servers 323 <DT> 17.3 A Local File System 323 <DT> 17.4 Data Structures For The File System 324 <DT> 17.5 Implementation Of The Index Manager 325 <DT> 17.6 Operations On I-Blocks 327 <DT> 17.6.1 Clearing An I-Block 327 <DT> 17.6.2 Reading An I-Block 327 <DT> 17.6.3 Writing An I-Block 328 <DT> 17.6.4 Allocating I-Blocks From The Free List 330 <DT> 17.6.5 Returning I-Blocks To The Free List 331 <DT> 17.7 The Directory Structure 333 <DT> 17.8 Using The Device Switch Table For Files 334 <DT> 17.9 Establishing A Pseudo-Device 337 <DT> 17.10 Pseudo-Device Driver Routines 343 <DT> 17.10.1 Index Management Routines 346 <DT> 17.10.2 The Pseudo-Device Seek Routine 349 <DT> 17.10.3 The Pseudo-Device Getc Routine 350 <DT> 17.10.4 The Pseudo-Device Putc Routine 352 <DT> 17.10.5 The Pseudo-Device Read Routine 353 <DT> 17.10.6 The Pseudo-Device Write Routine 354 <DT> 17.10.7 The Pseudo-Device Close Routine 355 <DT> 17.10.8 The Pseudo-Device Initialization Routine 357 <DT> 17.11 Summary 358 <DT> For Further Study 358 <DT> Exercises 358 </DL> <H3> Chapter 18 MS-DOS File Interface </H3> <DL> <DT> 18.1 File Operations Available Through MS-DOS 361 <DT> 18.2 Using The Device Switch Table For MS-DOS Files 367 <DT> 18.3 Establishing A Pseudo-Device 369 <DT> 18.4 MS-DOS Pseudo-Device Driver Routines 373 <DT> 18.4.1 MS-DOS File Input/Output And Seek Operations 375 <DT> 18.4.2 Closing The Pseudo-Device 380 <DT> 18.4.3 MS-DOS Pseudo-Device Initialization 381 <DT> 18.5 MS-DOS File System Control Operations 382 <DT> 18.6 Summary 383 <DT> For Further Study 383 <DT> Exercises 383 </DL> <H3> Chapter 19 Exception Handling and Support Routines </H3> <DL> <DT> 19.1 Exceptions, Traps, And Illegal Interrupts 385 <DT> 19.2 Initialization Of Interrupt Vectors 386 <DT> 19.3 Implementation Of Panic 386 <DT> 19.4 Formatted Output 389 <DT> 19.4.1 Printf And Fprintf 397 <DT> 19.4.2 Kprintf 398 <DT> 19.5 The Butler Process 399 <DT> 19.5.1 The Ctrl-Break Event 401 <DT> 19.5.2 System Snapshots 402 <DT> 19.6 Summary 409 <DT> For Further Study 409 <DT> Exercises 410 </DL> <H3> Chapter 20 System Configuration </H3> <DL> <DT> 20.1 The Need For Multiple Configurations 411 <DT> 20.2 Static vs. Dynamic Configuration 412 <DT> 20.3 The Details Of Configuration In PC-Xinu 412 <DT> 20.3.1 Input To Config 414 <DT> 20.3.2 Computation Of Minor Device Numbers 416 <DT> 20.4 Configuring A PC-Xinu System 417 <DT> 20.4.1 Counting Devices 418 <DT> 20.5 System Calls And Procedures 418 <DT> 20.6 Summary 419 <DT> For Further Study 419 <DT> Exercises 419 </DL> <H3> Bibliography </H3> <H3> Index </H3> <BR> <BR> <H4><A HREF="osbooks.html">Return to list of Comer's OS books</A></H4> <BR> <BR> <H4><A HREF="http://www.cs.purdue.edu/people/comer">Return to Comer's homepage</A></H4> </HTML> </HTML>
</DOC>
