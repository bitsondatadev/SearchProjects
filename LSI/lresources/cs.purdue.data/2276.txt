<DOC>
<DOCNO> http://www.cs.purdue.edu/homes/dec/tcpip3t.cont.html </DOCNO>
<HTML> <H2> Table of Contents: Internetworking With TCP/IP Volume 3 <UL><UL>TLI version (System V UNIX)</UL></UL></H2> <BR> <H3> Foreword </H3> <H3> Preface </H3> <H3> Chapter 1 Introduction And Overview </H3> <DL> <DT> 1.1 Use Of TCP/IP 1 <DT> 1.2 Designing Applications For A Distributed Environment 2 <DT> 1.3 Standard And Nonstandard Application Protocols 2 <DT> 1.4 An Example Of Standard Application Protocol Use 2 <DT> 1.5 An Example Connection 3 <DT> 1.6 Using TELNET To Access An Alternative Service 4 <DT> 1.7 Application Protocols And Software Flexibility 5 <DT> 1.8 Viewing Services From The Provider's Perspective 6 <DT> 1.9 The Remainder Of This Text 7 <DT> 1.10 Summary 7 <DT> For Further Study 7 <DT> Exercises 8 </DL> <H3> Chapter 2 The Client-Server Model And Software Design </H3> <DL> <DT> 2.1 Introduction 9 <DT> 2.2 Motivation 10 <DT> 2.3 Terminology And Concepts 10 <DT> 2.3.1 Clients And Servers 10 <DT> 2.3.2 Privilege And Complexity 11 <DT> 2.3.3 Standard Vs. Nonstandard Client Software 11 <DT> 2.3.4 Parameterization Of Clients 12 <DT> 2.3.5 Connectionless Vs. Connection-Oriented Servers 13 <DT> 2.3.6 Stateless Vs. Stateful Servers 14 <DT> 2.3.7 A Stateful File Server Example 14 <DT> 2.3.8 Statelessness Is A Protocol Issue 16 <DT> 2.3.9 Servers As Clients 17 <DT> 2.4 Summary 18 <DT> For Further Study 18 <DT> Exercises 18 </DL> <H3> Chapter 3 Concurrent Processing In Client-Server Software </H3> <DL> <DT> 3.1 Introduction 21 <DT> 3.2 Concurrency In Networks 21 <DT> 3.3 Concurrency In Servers 23 <DT> 3.4 Terminology And Concepts 24 <DT> 3.4.1 The Process Concept 25 <DT> 3.4.2 Programs vs. Processes 25 <DT> 3.4.3 Procedure Calls 26 <DT> 3.5 An Example Of Concurrent Process Creation 26 <DT> 3.5.1 A Sequential C Example 26 <DT> 3.5.2 A Concurrent Version 27 <DT> 3.5.3 Timeslicing 29 <DT> 3.5.4 Making Processes Diverge 30 <DT> 3.6 Executing New Code 31 <DT> 3.7 Context Switching And Protocol Software Design 31 <DT> 3.8 Concurrency And Asynchronous I/O 32 <DT> 3.9 Summary 32 <DT> For Further Study 33 <DT> Exercises 33 </DL> <H3> Chapter 4 Program Interface To Protocols </H3> <DL> <DT> 4.1 Introduction 35 <DT> 4.2 Loosely Specified Protocol Software Interface 35 <DT> 4.2.1 Advantages And Disadvantages 36 <DT> 4.3 Interface Functionality 36 <DT> 4.4 Conceptual Interface Specification 37 <DT> 4.5 System Calls 37 <DT> 4.6 Two Basic Approaches To Network Communication 38 <DT> 4.7 The Basic I/O Functions Available In UNIX 39 <DT> 4.8 Using UNIX I/O With TCP/IP 40 <DT> 4.9 Summary 40 <DT> For Further Study 41 <DT> Exercises 41 </DL> <H3> Chapter 5 The Transport Layer Interface (TLI) </H3> <DL> <DT> 5.1 Introduction 43 <DT> 5.2 Background 43 <DT> 5.3 Specifying A Protocol Interface 44 <DT> 5.4 The Basic TLI Abstractions 45 <DT> 5.5 Practical Limitations On Portability 46 <DT> 5.6 Programs, Linking, And Shared Libraries 46 <DT> 5.7 TLI Communication Descriptors 47 <DT> 5.8 Using A File Path To Specify Protocol Software 48 <DT> 5.9 Specifying An Endpoint Address 48 <DT> 5.10 An Address Structure For TCP/IP 49 <DT> 5.11 Principle Function Calls Used With TLI 50 <DT> 5.11.1 The T_open Function 51 <DT> 5.11.2 The T_bind Function 51 <DT> 5.11.3 The T_alloc Function 52 <DT> 5.11.4 The T_listen Function 52 <DT> 5.11.5 The T_accept Function 53 <DT> 5.11.6 The T_connect Function 53 <DT> 5.11.7 The T_snd Function 53 <DT> 5.11.8 The T_rcv Function 54 <DT> 5.11.9 The T_sndudata Function 54 <DT> 5.11.10 The T_rcvudata Function 54 <DT> 5.11.11 The T_close Function 55 <DT> 5.12 Summary Of TLI Functions Used With TCP/IP 55 <DT> 5.13 Utility Routines For Integer Conversion 56 <DT> 5.14 Using TLI Functions In A Program 56 <DT> 5.15 Predefined Structures And Symbolic Constants 57 <DT> 5.16 Summary 58 <DT> For Further Study 58 <DT> Exercises 59 </DL> <H3> Chapter 6 Algorithms And Issues In Client Software Design </H3> <DL> <DT> 6.1 Introduction 61 <DT> 6.2 Learning Algorithms Instead Of Details 61 <DT> 6.3 Client Architecture 62 <DT> 6.4 Identifying The Location Of A Server 62 <DT> 6.5 Parsing An Address Argument 64 <DT> 6.6 Looking Up A Domain Name 65 <DT> 6.7 Looking Up A Well-Known Port By Name 66 <DT> 6.8 Port Numbers And Network Byte Order 66 <DT> 6.9 The TCP Client Algorithm 67 <DT> 6.10 Allocating A Descriptor 67 <DT> 6.11 Choosing A Local Protocol Port Number 68 <DT> 6.12 A Fundamental Problem In Choosing A Local IP Address 68 <DT> 6.13 Connecting To A Server With TCP 69 <DT> 6.14 Communicating With The Server Using TCP 69 <DT> 6.15 Reading A Response From A TCP Connection 70 <DT> 6.16 Terminating A TCP Connection 71 <DT> 6.16.1 The Need For Partial Release 71 <DT> 6.16.2 A Partial Close Operation 71 <DT> 6.17 Programming A UDP Client 72 <DT> 6.18 Communicating With A Server Using UDP 73 <DT> 6.19 Deallocating A Descriptor That Uses UDP 73 <DT> 6.20 A Warning About UDP Unreliability 73 <DT> 6.21 Summary 74 <DT> For Further Study 74 <DT> Exercises 74 </DL> <H3> Chapter 7 Example Client Software </H3> <DL> <DT> 7.1 Introduction 77 <DT> 7.2 The Importance Of Small Examples 77 <DT> 7.3 Hiding Details 78 <DT> 7.4 An Example Procedure Library For Client Programs 78 <DT> 7.5 Implementation Of ClientTCP 79 <DT> 7.6 Implementation Of ClientUDP 81 <DT> 7.7 A Procedure That Forms Connections 82 <DT> 7.8 Using The Example Library 84 <DT> 7.9 The DAYTIME Service 85 <DT> 7.10 Implementation Of A TCP Client For DAYTIME 85 <DT> 7.11 Reading From A TCP Connection 87 <DT> 7.12 The TIME Service 88 <DT> 7.13 Accessing The TIME Service 88 <DT> 7.14 Accurate Times And Network Delays 89 <DT> 7.15 A UDP Client For The TIME Service 89 <DT> 7.16 The ECHO Service 92 <DT> 7.17 A TCP Client For The ECHO Service 92 <DT> 7.18 A UDP Client For The ECHO Service 94 <DT> 7.19 Summary 96 <DT> For Further Study 96 <DT> Exercises 96 </DL> <H3> Chapter 8 Algorithms And Issues In Server Software Design </H3> <DL> <DT> 8.1 Introduction 99 <DT> 8.2 The Conceptual Server Algorithm 99 <DT> 8.3 Concurrent Vs. Iterative Servers 100 <DT> 8.4 Connection-Oriented Vs. Connectionless Access 100 <DT> 8.5 Connection-Oriented Servers 101 <DT> 8.6 Connectionless Servers 101 <DT> 8.7 Failure, Reliability, And Statelessness 102 <DT> 8.8 Optimizing Stateless Servers 103 <DT> 8.9 Four Basic Types Of Servers 105 <DT> 8.10 Request Processing Time 106 <DT> 8.11 Iterative Server Algorithms 106 <DT> 8.12 An Iterative, Connection-Oriented Server Algorithm 107 <DT> 8.13 Binding To A Well-Known Address Using INADDR_ANY 107 <DT> 8.14 Waiting For A Connection Request 108 <DT> 8.15 Accepting Connections And Using Them 108 <DT> 8.16 An Iterative, Connectionless Server Algorithm 108 <DT> 8.17 Forming A Reply Address In A Connectionless Server 109 <DT> 8.18 Concurrent Server Algorithms 109 <DT> 8.19 Master And Slave Processes 110 <DT> 8.20 A Concurrent, Connectionless Server Algorithm 110 <DT> 8.21 A Concurrent, Connection-Oriented Server Algorithm 111 <DT> 8.22 Using Separate Programs As Slaves 112 <DT> 8.23 Apparent Concurrency Using A Single Process 112 <DT> 8.24 When To Use Each Server Type 113 <DT> 8.25 A Summary of Server Types 114 <DT> 8.26 The Important Problem Of Server Deadlock 115 <DT> 8.27 Alternative Implementations 116 <DT> 8.28 Summary 116 <DT> For Further Study 116 <DT> Exercises 116 </DL> <H3> Chapter 9 Iterative, Connectionless Servers (UDP) </H3> <DL> <DT> 9.1 Introduction 119 <DT> 9.2 Creating A Passive Descriptor 119 <DT> 9.3 Process Structure 123 <DT> 9.4 An Example TIME Server 123 <DT> 9.5 Summary 126 <DT> For Further Study 126 <DT> Exercises 126 </DL> <H3> Chapter 10 Iterative, Connection-Oriented Servers (TCP) </H3> <DL> <DT> 10.1 Introduction 129 <DT> 10.2 Allocating A Passive TCP Descriptor 129 <DT> 10.3 A Server For The DAYTIME Service 130 <DT> 10.4 Process Structure 130 <DT> 10.5 An Example DAYTIME Server 131 <DT> 10.6 Closing Connections 135 <DT> 10.7 Connection Termination And Server Vulnerability 136 <DT> 10.8 Summary 136 <DT> For Further Study 137 <DT> Exercises 137 </DL> <H3> Chapter 11 Concurrent, Connection-Oriented Servers (TCP) </H3> <DL> <DT> 11.1 Introduction 139 <DT> 11.2 Concurrent ECHO 139 <DT> 11.3 Iterative Vs. Concurrent Implementations 140 <DT> 11.4 Process Structure 140 <DT> 11.5 An Example Concurrent ECHO Server 141 <DT> 11.6 Notification Of Child Exit 144 <DT> 11.7 Summary 144 <DT> For Further Study 145 <DT> Exercises 145 </DL> <H3> Chapter 12 Single-Process, Concurrent Servers (TCP) </H3> <DL> <DT> 12.1 Introduction 147 <DT> 12.2 Data-Driven Processing In A Server 147 <DT> 12.3 Data-Driven Processing With A Single Process 148 <DT> 12.4 Process Structure Of A Single-Process Server 149 <DT> 12.5 An Example Single-Process ECHO Server 150 <DT> 12.6 Summary 152 <DT> For Further Study 152 <DT> Exercises 153 </DL> <H3> Chapter 13 Multiprotocol Servers (TCP, UDP) </H3> <DL> <DT> 13.1 Introduction 155 <DT> 13.2 The Motivation For Reducing The Number Of Servers 155 <DT> 13.3 Multiprotocol Server Design 156 <DT> 13.4 Process Structure 156 <DT> 13.5 An Example Multiprotocol DAYTIME Server 157 <DT> 13.6 The Concept Of Shared Code 161 <DT> 13.7 Concurrent Multiprotocol Servers 161 <DT> 13.8 Summary 162 <DT> For Further Study 162 <DT> Exercises 162 </DL> <H3> Chapter 14 Multiservice Servers (TCP, UDP) </H3> <DL> <DT> 14.1 Introduction 163 <DT> 14.2 Consolidating Servers 163 <DT> 14.3 A Connectionless, Multiservice Server Design 164 <DT> 14.4 A Connection-Oriented, Multiservice Server Design 165 <DT> 14.5 A Concurrent, Connection-Oriented, Multiservice Server 166 <DT> 14.6 A Single-Process, Multiservice Server Implementation 166 <DT> 14.7 Invoking Separate Programs From A Multiservice Server 167 <DT> 14.8 Multiservice, Multiprotocol Designs 168 <DT> 14.9 An Example Multiservice Server 169 <DT> 14.10 The UNIX Super Server, Inetd 175 <DT> 14.11 Summary 176 <DT> For Further Study 176 <DT> Exercises 176 </DL> <H3> Chapter 15 Uniform, Efficient Management Of Server Concurrency </H3> <DL> <DT> 15.1 Introduction 179 <DT> 15.2 Choosing Between An Iterative And A Concurrent Design 179 <DT> 15.3 Level Of Concurrency 180 <DT> 15.4 Demand-Driven Concurrency 181 <DT> 15.5 The Cost Of Concurrency 181 <DT> 15.6 Overhead And Delay 181 <DT> 15.7 Small Delays Can Matter 182 <DT> 15.8 Process Preallocation 183 <DT> 15.8.1 Preallocation In UNIX 184 <DT> 15.8.2 Preallocation In A Connection-Oriented Server 184 <DT> 15.8.3 Preallocation In A Connectionless Server 185 <DT> 15.8.4 Preallocation, Bursty Traffic, And NFS 186 <DT> 15.8.5 Process Preallocation On A Multiprocessor 187 <DT> 15.9 Delayed Process Allocation 187 <DT> 15.10 The Uniform Basis For Both Techniques 188 <DT> 15.11 Combining Techniques 189 <DT> 15.12 Summary 189 <DT> For Further Study 190 <DT> Exercises 190 </DL> <H3> Chapter 16 Concurrency In Clients </H3> <DL> <DT> 16.1 Introduction 191 <DT> 16.2 The Advantages Of Concurrency 191 <DT> 16.3 The Motivation For Exercising Control 192 <DT> 16.4 Concurrent Contact With Multiple Servers 193 <DT> 16.5 Implementing Concurrent Clients 193 <DT> 16.6 Single-Process Implementations 195 <DT> 16.7 An Example Concurrent Client That Uses ECHO 196 <DT> 16.8 Execution Of The Concurrent Client 200 <DT> 16.9 Concurrency In The Example Code 202 <DT> 16.10 Summary 202 <DT> Exercises 202 </DL> <H3> Chapter 17 Tunneling At The Transport And Application Levels </H3> <DL> <DT> 17.1 Introduction 205 <DT> 17.2 Multiprotocol Environments 205 <DT> 17.3 Mixing Network Technologies 207 <DT> 17.4 Dynamic Circuit Allocation 208 <DT> 17.5 Encapsulation And Tunneling 209 <DT> 17.6 Tunneling Through An IP Internet 209 <DT> 17.7 Application-Level Tunneling Between Clients And Servers 210 <DT> 17.8 Summary 211 <DT> For Further Study 212 <DT> Exercises 212 </DL> <H3> Chapter 18 Application Level Gateways </H3> <DL> <DT> 18.1 Introduction 213 <DT> 18.2 Clients And Servers In Constrained Environments 213 <DT> 18.2.1 The Reality Of Multiple Technologies 213 <DT> 18.2.2 Computers With Limited Functionality 214 <DT> 18.2.3 Connectivity Constraints That Arise From Security 214 <DT> 18.3 Using Application Gateways 215 <DT> 18.4 Interoperability Through A Mail Gateway 216 <DT> 18.5 Implementation Of A Mail Gateway 217 <DT> 18.6 A Comparison Of Application Gateways And Tunneling 217 <DT> 18.7 Application Gateways And Limited Functionality Systems 219 <DT> 18.8 Application Gateways Used For Security 220 <DT> 18.9 Application Gateways And The Extra Hop Problem 221 <DT> 18.10 An Example Application Gateway 223 <DT> 18.11 Implementation Of An Application Gateway 224 <DT> 18.12 Code For The Application Gateway 226 <DT> 18.13 An Example Gateway Exchange 227 <DT> 18.14 Using Rfcd With UNIX's .forward 228 <DT> 18.15 Summary 228 <DT> For Further Study 229 <DT> Exercises 229 </DL> <H3> Chapter 19 External Data Representation (XDR) </H3> <DL> <DT> 19.1 Introduction 231 <DT> 19.2 Representations For Data In Computers 231 <DT> 19.3 The N-Squared Conversion Problem 232 <DT> 19.4 Network Standard Byte Order 233 <DT> 19.5 A De Facto Standard External Data Representation 234 <DT> 19.6 XDR Data Types 235 <DT> 19.7 Implicit Types 236 <DT> 19.8 Software Support For Using XDR 236 <DT> 19.9 XDR Library Routines 236 <DT> 19.10 Building A Message One Piece At A Time 236 <DT> 19.11 Conversion Routines In The XDR Library 238 <DT> 19.12 XDR Streams, I/O, and TCP 240 <DT> 19.13 Records, Record Boundaries, And Datagram I/O 241 <DT> 19.14 Summary 241 <DT> For Further Study 242 <DT> Exercises 242 </DL> <H3> Chapter 20 Remote Procedure Call Concept (RPC) </H3> <DL> <DT> 20.1 Introduction 243 <DT> 20.2 Remote Procedure Call Model 243 <DT> 20.3 Two Paradigms For Building Distributed Programs 244 <DT> 20.4 A Conceptual Model For Conventional Procedure Calls 245 <DT> 20.5 An Extension Of the Procedural Model 245 <DT> 20.6 Execution Of Conventional Procedure Call And Return 246 <DT> 20.7 The Procedural Model In Distributed Systems 247 <DT> 20.8 Analogy Between Client-Server And RPC 248 <DT> 20.9 Distributed Computation As A Program 249 <DT> 20.10 Sun Microsystems' Remote Procedure Call Definition 250 <DT> 20.11 Remote Programs And Procedures 250 <DT> 20.12 Reducing The Number Of Arguments 251 <DT> 20.13 Identifying Remote Programs And Procedures 251 <DT> 20.14 Accommodating Multiple Versions Of A Remote Program 252 <DT> 20.15 Mutual Exclusion For Procedures In A Remote Program 253 <DT> 20.16 Communication Semantics 254 <DT> 20.17 At Least Once Semantics 254 <DT> 20.18 RPC Retransmission 255 <DT> 20.19 Mapping A Remote Program To A Protocol Port 255 <DT> 20.20 Dynamic Port Mapping 256 <DT> 20.21 RPC Port Mapper Algorithm 257 <DT> 20.22 Sun RPC Message Format 259 <DT> 20.23 Marshaling Arguments For A Remote Procedure 260 <DT> 20.24 Authentication 260 <DT> 20.25 An Example Of RPC Message Representation 261 <DT> 20.26 An Example Of The UNIX Authentication Field 262 <DT> 20.27 Summary 263 <DT> For Further Study 264 <DT> Exercises 264 </DL> <H3> Chapter 21 Distributed Program Generation (Rpcgen Concept) </H3> <DL> <DT> 21.1 Introduction 265 <DT> 21.2 Using Remote Procedure Calls 266 <DT> 21.3 Programming Mechanisms To Support RPC 267 <DT> 21.4 Dividing A Program Into Local And Remote Procedures 268 <DT> 21.5 Adding Code For RPC 269 <DT> 21.6 Stub Procedures 269 <DT> 21.7 Multiple Remote Procedures And Dispatching 270 <DT> 21.8 Name Of The Client-Side Stub Procedure 271 <DT> 21.9 Using Rpcgen To Generate Distributed Programs 272 <DT> 21.10 Rpcgen Output And Interface Procedures 272 <DT> 21.11 Rpcgen Input And Output 273 <DT> 21.12 Using Rpcgen To Build A Client And Server 274 <DT> 21.13 Summary 274 <DT> For Further Study 276 <DT> Exercises 276 </DL> <H3> Chapter 22 Distributed Program Generation (Rpcgen Example) </H3> <DL> <DT> 22.1 Introduction 277 <DT> 22.2 An Example To Illustrate Rpcgen 278 <DT> 22.3 Dictionary Lookup 278 <DT> 22.4 Eight Steps To A Distributed Application 279 <DT> 22.5 Step 1: Build A Conventional Application Program 280 <DT> 22.6 Step 2: Divide The Program Into Two Parts 284 <DT> 22.7 Step 3: Create An Rpcgen Specification 290 <DT> 22.8 Step 4: Run Rpcgen 292 <DT> 22.9 The .h File Produced By Rpcgen 292 <DT> 22.10 The XDR Conversion File Produced By Rpcgen 294 <DT> 22.11 The Client Code Produced By Rpcgen 295 <DT> 22.12 The Server Code Produced By Rpcgen 297 <DT> 22.13 Step 5: Write Stub Interface Procedures 302 <DT> 22.13.1 Client-Side Interface Routines 302 <DT> 22.13.2 Server-Side Interface Routines 304 <DT> 22.14 Step 6: Compile And Link The Client Program 306 <DT> 22.15 Step 7: Compile And Link The Server Program 309 <DT> 22.16 Step 8: Start The Server And Execute The Client 312 <DT> 22.17 Using The UNIX Make Utility 312 <DT> 22.18 Summary 315 <DT> For Further Study 315 <DT> Exercises 315 </DL> <H3> Chapter 23 Network File System Concepts (NFS) </H3> <DL> <DT> 23.1 Introduction 317 <DT> 23.2 Remote File Access Vs. Transfer 317 <DT> 23.3 Operations On Remote Files 318 <DT> 23.4 File Access Among Heterogeneous Computers 318 <DT> 23.5 Stateless Servers 319 <DT> 23.6 NFS And UNIX File Semantics 319 <DT> 23.7 Review Of The UNIX File System 319 <DT> 23.7.1 Basic Definitions 319 <DT> 23.7.2 A Byte Sequence Without Record Boundaries 320 <DT> 23.7.3 A File's Owner And Group Identifiers 320 <DT> 23.7.4 Protection And Access 320 <DT> 23.7.5 The Open-Read-Write-Close Paradigm 322 <DT> 23.7.6 Data Transfer 323 <DT> 23.7.7 Permission To Search A Directory 323 <DT> 23.7.8 Random Access 323 <DT> 23.7.9 Seeking Beyond The End Of File 324 <DT> 23.7.10 File Position And Concurrent Access 325 <DT> 23.7.11 Semantics Of Write During Concurrent Access 326 <DT> 23.7.12 File Names And Paths 326 <DT> 23.7.13 Inode: Information Stored With A File 327 <DT> 23.7.14 Stat Operation 329 <DT> 23.7.15 The File Naming Mechanism 329 <DT> 23.7.16 File System Mounts 330 <DT> 23.7.17 UNIX File Name Resolution 332 <DT> 23.7.18 Symbolic Links 333 <DT> 23.8 Files Under NFS 333 <DT> 23.9 NFS File Types 334 <DT> 23.10 NFS File Modes 334 <DT> 23.11 NFS File Attributes 335 <DT> 23.12 NFS Client And Server 336 <DT> 23.13 NFS Client Operation 337 <DT> 23.14 NFS Client And UNIX 338 <DT> 23.15 NFS Mounts 339 <DT> 23.16 File Handle 340 <DT> 23.17 Handles Replace Path Names 340 <DT> 23.18 An NFS Client In UNIX 342 <DT> 23.19 File Positioning With A Stateless Server 342 <DT> 23.20 Operations On Directories 343 <DT> 23.21 Reading A Directory Statelessly 343 <DT> 23.22 Multiple Hierarchies In An NFS Server 344 <DT> 23.23 The Mount Protocol 344 <DT> 23.24 Summary 345 <DT> For Further Study 345 <DT> Exercises 345 </DL> <H3> Chapter 24 Network File System Protocol (NFS, Mount) </H3> <DL> <DT> 24.1 Introduction 347 <DT> 24.2 Using RPC To Define A Protocol 347 <DT> 24.3 Defining A Protocol With Data Structures And Procedures 348 <DT> 24.4 NFS Constant, Type, And Data Declarations 349 <DT> 24.4.1 NFS Constants 349 <DT> 24.4.2 NFS Typedef Declarations 350 <DT> 24.4.3 NFS Data Structures 350 <DT> 24.5 NFS Procedures 352 <DT> 24.6 Semantics Of NFS Operations 353 <DT> 24.6.1 NFSPROC_NULL (Procedure 0) 354 <DT> 24.6.2 NFSPROC_GETATTR (Procedure 1) 354 <DT> 24.6.3 NFSPROC_SETATTR (Procedure 2) 354 <DT> 24.6.4 NFSPROC_ROOT (Procedure 3) 354 <DT> 24.6.5 NFSPROC_LOOKUP (Procedure 4) 354 <DT> 24.6.6 NFSPROC_READLINK (Procedure 5) 354 <DT> 24.6.7 NFSPROC_READ (Procedure 6) 354 <DT> 24.6.8 NFSPROC_WRITECACHE (Procedure 7) 354 <DT> 24.6.9 NFSPROC_WRITE (Procedure 8) 355 <DT> 24.6.10 NFSPROC_CREATE (Procedure 9) 355 <DT> 24.6.11 NFSPROC_REMOVE (Procedure 10) 355 <DT> 24.6.12 NFSPROC_RENAME (Procedure 11) 355 <DT> 24.6.13 NFSPROC_LINK (Procedure 12) 355 <DT> 24.6.14 NFSPROC_SYMLINK (Procedure 13) 355 <DT> 24.6.15 NFSPROC_MKDIR (Procedure 14) 356 <DT> 24.6.16 NFSPROC_RMDIR (Procedure 15) 356 <DT> 24.6.17 NFSPROC_READDIR (Procedure 16) 356 <DT> 24.6.18 NFSPROC_STATFS (Procedure 17) 356 <DT> 24.7 The Mount Protocol 357 <DT> 24.7.1 Mount Constant Definitions 357 <DT> 24.7.2 Mount Type Definitions 357 <DT> 24.7.3 Mount Data Structures 358 <DT> 24.8 Procedures In The Mount Protocol 359 <DT> 24.9 Semantics of Mount Operations 359 <DT> 24.9.1 MNTPROC_NULL (Procedure 0) 359 <DT> 24.9.2 MNTPROC_MNT (Procedure 1) 359 <DT> 24.9.3 MNTPROC_DUMP (Procedure 2) 360 <DT> 24.9.4 MNTPROC_UMNT (Procedure 3) 360 <DT> 24.9.5 MNTPROC_UMNTALL (Procedure 4) 360 <DT> 24.9.6 MNTPROC_EXPORT (Procedure 5) 360 <DT> 24.10 NFS And Mount Authentication 360 <DT> 24.11 Summary 362 <DT> For Further Study 362 <DT> Exercises 362 </DL> <H3> Chapter 25 A TELNET Client (Program Structure) </H3> <DL> <DT> 25.1 Introduction 365 <DT> 25.2 Overview 366 <DT> 25.2.1 The User's Terminal 366 <DT> 25.2.2 Command And Control Information 366 <DT> 25.2.3 Terminals, Windows, and Files 366 <DT> 25.2.4 The Need For Concurrency 367 <DT> 25.2.5 A Process Model For A TELNET Client 368 <DT> 25.3 A TELNET Client Algorithm 368 <DT> 25.4 Terminal I/O In UNIX 369 <DT> 25.4.1 Controlling A Device Driver 370 <DT> 25.5 Establishing Terminal Modes 371 <DT> 25.6 Global Variable Used For Stored State 373 <DT> 25.7 Restoring Terminal Modes Before Exit 374 <DT> 25.8 Client Suspension And Resumption 375 <DT> 25.9 Finite State Machine Specification 376 <DT> 25.10 Embedding Commands In A TELNET Data Stream 377 <DT> 25.11 Option Negotiation 378 <DT> 25.12 Request/Offer Symmetry 378 <DT> 25.13 TELNET Character Definitions 378 <DT> 25.14 A Finite State Machine For Data From The Server 380 <DT> 25.15 Transitions Among States 380 <DT> 25.16 A Finite State Machine Implementation 382 <DT> 25.17 A Compact FSM Representation 383 <DT> 25.18 Keeping The Compact Representation At Run-Time 384 <DT> 25.19 Implementation Of A Compact Representation 385 <DT> 25.20 Building An FSM Transition Matrix 386 <DT> 25.21 The TCP Output Finite State Machine 388 <DT> 25.22 Definitions For The TCP Output FSM 390 <DT> 25.23 The Option Subnegotiation Finite State Machine 391 <DT> 25.24 Definitions For The Option Subnegotiation FSM 392 <DT> 25.25 FSM Initialization 393 <DT> 25.26 Arguments For The TELNET Client 393 <DT> 25.27 The Heart Of The TELNET Client 395 <DT> 25.28 Implementation Of The Main FSM 400 <DT> 25.29 Summary 401 <DT> For Further Study 401 <DT> Exercises 402 </DL> <H3> Chapter 26 A TELNET Client (Implementation Details) </H3> <DL> <DT> 26.1 Introduction 403 <DT> 26.2 The FSM Action Procedures 403 <DT> 26.3 Recording The Type Of An Option Request 404 <DT> 26.4 Performing No Operation 405 <DT> 26.5 Responding To WILL/WONT For The Echo Option 405 <DT> 26.6 Responding To WILL/WONT For Unsupported Options 407 <DT> 26.7 Responding To WILL/WONT For The No Go-Ahead Option 408 <DT> 26.8 Generating DO/DONT For Binary Transmission 409 <DT> 26.9 Responding To DO/DONT For Unsupported Options 410 <DT> 26.10 Responding To DO/DONT For Transmit Binary Option 411 <DT> 26.11 Responding To DO/DONT For The Terminal Type Option 413 <DT> 26.12 Option Subnegotiation 414 <DT> 26.13 Sending Terminal Type Information 415 <DT> 26.14 Terminating Subnegotiation 417 <DT> 26.15 Sending A Character To The Server 417 <DT> 26.16 Displaying Incoming Data On The User's Terminal 419 <DT> 26.17 Using Termcap To Control The User's Terminal 423 <DT> 26.18 Writing A Block Of Data To The Server 424 <DT> 26.19 Interacting With The Client Process 426 <DT> 26.20 Responding To Illegal Commands 426 <DT> 26.21 Scripting To A File 427 <DT> 26.22 Implementation Of Scripting 427 <DT> 26.23 Initialization Of Scripting 428 <DT> 26.24 Collecting Characters Of The Script File Name 429 <DT> 26.25 Opening A Script File 430 <DT> 26.26 Terminating Scripting 432 <DT> 26.27 Printing Status Information 433 <DT> 26.28 Summary 434 <DT> For Further Study 434 <DT> Exercises 435 </DL> <H3> Chapter 27 Practical Hints And Techniques For UNIX Servers </H3> <DL> <DT> 27.1 Introduction 437 <DT> 27.2 Operating In Background 437 <DT> 27.3 Programming A Server To Operate In Background 438 <DT> 27.4 Open Descriptors And Inheritance 439 <DT> 27.5 Programming A Server To Close Inherited Descriptors 440 <DT> 27.6 Signals From The Controlling TTY 440 <DT> 27.7 Process Groups And Sessions 440 <DT> 27.8 Programming A Server To Change Its TTY And Session 441 <DT> 27.9 Moving To A Safe And Known Directory 441 <DT> 27.10 Programming A Server To Change Directories 442 <DT> 27.11 The UNIX Umask 442 <DT> 27.12 Programming A Server To Set Its Umask 443 <DT> 27.13 Descriptors For Standard I/O 443 <DT> 27.14 Programming A Server To Open Standard Descriptors 443 <DT> 27.15 Mutual Exclusion For The Server 444 <DT> 27.16 Programming A Server To Avoid Multiple Copies 444 <DT> 27.17 Recording A Server's Process ID 445 <DT> 27.18 Programming A Server To Record Its Process ID 445 <DT> 27.19 Waiting For A Child Process To Exit 446 <DT> 27.20 Programming A Server To Wait For Each Child To Exit 446 <DT> 27.21 Extraneous Signals 446 <DT> 27.22 Programming A Server To Ignore Extraneous Signals 446 <DT> 27.23 Using A System Log Facility 447 <DT> 27.23.1 Generating Log Messages 447 <DT> 27.23.2 The Advantage Of Indirection And Standard Error 447 <DT> 27.23.3 Limitations Of I/O Redirection 448 <DT> 27.23.4 A Client-Server Solution 448 <DT> 27.23.5 The Syslog Mechanism 448 <DT> 27.23.6 Syslog Message Classes 449 <DT> 27.23.7 Syslog Facilities 449 <DT> 27.23.8 Syslog Priority Levels 450 <DT> 27.23.9 Using Syslog 450 <DT> 27.23.10 An Example Syslog Configuration File 451 <DT> 27.24 Summary 452 <DT> For Further Study 452 <DT> Exercises 453 <DT> For Further Study 486 <DT> Exercises 486 </DL> <H3> Bibliography </H3> <H3> Index </H3> <BR> <BR> <H4><A HREF="netbooks.html#vol3.tli">Return to list of Comer's networking books</A></H4> <BR> <BR> <H4><A HREF="http://www.cs.purdue.edu/people/comer">Return to Comer's homepage</A></H4> </HTML> </HTML>
</DOC>
