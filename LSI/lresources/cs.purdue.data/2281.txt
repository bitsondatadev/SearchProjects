<DOC>
<DOCNO> http://www.cs.purdue.edu/homes/dec/tcpip3w.cont.html </DOCNO>
<HTML> <HEAD> <TITLE> vol3 contents </TITLE> </HEAD> <BODY> <CENTER> <H2> Table of Contents For <BR><BR> Internetworking With TCP/IP &nbsp;&nbsp; Volume 3<BR><BR> Windows Sockets Version <BR><BR> </H2> </CENTER> <UL><UL> <BR><H3> Foreword &nbsp;&nbsp;xxiii</H3> <BR><H3> Preface &nbsp;&nbsp;xxv</H3> <BR> <H3>Chapter 1 &nbsp; Introduction And Overview &nbsp;&nbsp; 1</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>1.1 <TD ALIGN=left COLSPAN=2> Use Of TCP/IP &nbsp;&nbsp 1 <TR> <TD ALIGN=left>1.2 <TD ALIGN=left COLSPAN=2> Designing Applications For A Distributed Environment &nbsp;&nbsp 2 <TR> <TD ALIGN=left>1.3 <TD ALIGN=left COLSPAN=2> Standard And Nonstandard Application Protocols &nbsp;&nbsp 2 <TR> <TD ALIGN=left>1.4 <TD ALIGN=left COLSPAN=2> An Example Of Standard Application Protocol Use &nbsp;&nbsp 2 <TR> <TD ALIGN=left>1.5 <TD ALIGN=left COLSPAN=2> An Example Connection &nbsp;&nbsp 3 <TR> <TD ALIGN=left>1.6 <TD ALIGN=left COLSPAN=2> Using TELNET To Access An Alternative Service &nbsp;&nbsp 4 <TR> <TD ALIGN=left>1.7 <TD ALIGN=left COLSPAN=2> Application Protocols And Software Flexibility &nbsp;&nbsp 5 <TR> <TD ALIGN=left>1.8 <TD ALIGN=left COLSPAN=2> Viewing Services From The Provider's Perspective &nbsp;&nbsp 6 <TR> <TD ALIGN=left>1.9 <TD ALIGN=left COLSPAN=2> The Remainder Of The Text &nbsp;&nbsp 7 <TR> <TD ALIGN=left>1.10 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 7 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 7<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 8<BR> </TABLE> <BR> <BR> <H3>Chapter 2 &nbsp; The Client Server Model And Software Design &nbsp;&nbsp; 9</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>2.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 9 <TR> <TD ALIGN=left>2.2 <TD ALIGN=left COLSPAN=2> Motivation &nbsp;&nbsp 10 <TR> <TD ALIGN=left>2.3 <TD ALIGN=left COLSPAN=2> Terminology And Concepts &nbsp;&nbsp 10 <TR> <TD ALIGN=left> <TD ALIGN=left>2.3.1 <TD ALIGN=left> Clients And Servers &nbsp;&nbsp 10 <TR> <TD ALIGN=left> <TD ALIGN=left>2.3.2 <TD ALIGN=left> Privilege And Complexity &nbsp;&nbsp 11 <TR> <TD ALIGN=left> <TD ALIGN=left>2.3.3 <TD ALIGN=left> Standard Vs. Nonstandard Client Software &nbsp;&nbsp 11 <TR> <TD ALIGN=left> <TD ALIGN=left>2.3.4 <TD ALIGN=left> Parameterization Of Clients &nbsp;&nbsp 12 <TR> <TD ALIGN=left> <TD ALIGN=left>2.3.5 <TD ALIGN=left> Connectionless Vs. Connection-Oriented Servers &nbsp;&nbsp 13 <TR> <TD ALIGN=left> <TD ALIGN=left>2.3.6 <TD ALIGN=left> Stateless Vs. Stateful Servers &nbsp;&nbsp 14 <TR> <TD ALIGN=left> <TD ALIGN=left>2.3.7 <TD ALIGN=left> A Stateful File Server Example &nbsp;&nbsp 14 <TR> <TD ALIGN=left> <TD ALIGN=left>2.3.8 <TD ALIGN=left> Statelessness Is A Protocol Issue &nbsp;&nbsp 16 <TR> <TD ALIGN=left> <TD ALIGN=left>2.3.9 <TD ALIGN=left> Servers As Clients &nbsp;&nbsp 17 <TR> <TD ALIGN=left>2.4 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 18 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 18<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 18<BR> </TABLE> <BR> <BR> <H3>Chapter 3 &nbsp; Concurrent Processing In Client-Server Software &nbsp;&nbsp; 21</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>3.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 21 <TR> <TD ALIGN=left>3.2 <TD ALIGN=left COLSPAN=2> Concurrency In Networks &nbsp;&nbsp 22 <TR> <TD ALIGN=left>3.3 <TD ALIGN=left COLSPAN=2> Concurrency In Servers &nbsp;&nbsp 23 <TR> <TD ALIGN=left>3.4 <TD ALIGN=left COLSPAN=2> Terminology And Concepts &nbsp;&nbsp 24 <TR> <TD ALIGN=left> <TD ALIGN=left>3.4.1 <TD ALIGN=left> The Process Concept &nbsp;&nbsp 25 <TR> <TD ALIGN=left> <TD ALIGN=left>3.4.2 <TD ALIGN=left> Threads &nbsp;&nbsp 25 <TR> <TD ALIGN=left> <TD ALIGN=left>3.4.3 <TD ALIGN=left> Programs vs. Threads &nbsp;&nbsp 26 <TR> <TD ALIGN=left> <TD ALIGN=left>3.4.4 <TD ALIGN=left> Procedure Calls &nbsp;&nbsp 26 <TR> <TD ALIGN=left>3.5 <TD ALIGN=left COLSPAN=2> An Example Of Concurrent Thread Creation &nbsp;&nbsp 27 <TR> <TD ALIGN=left> <TD ALIGN=left>3.5.1 <TD ALIGN=left> A Sequential C Example &nbsp;&nbsp 27 <TR> <TD ALIGN=left> <TD ALIGN=left>3.5.2 <TD ALIGN=left> A Concurrent Version &nbsp;&nbsp 28 <TR> <TD ALIGN=left> <TD ALIGN=left>3.5.3 <TD ALIGN=left> Timeslicing &nbsp;&nbsp 30 <TR> <TD ALIGN=left>3.6 <TD ALIGN=left COLSPAN=2> Diverging Threads &nbsp;&nbsp 31 <TR> <TD ALIGN=left>3.7 <TD ALIGN=left COLSPAN=2> Context Switching And Protocol Software Design &nbsp;&nbsp 32 <TR> <TD ALIGN=left>3.8 <TD ALIGN=left COLSPAN=2> Concurrency And Asynchronous I/O &nbsp;&nbsp 32 <TR> <TD ALIGN=left>3.9 <TD ALIGN=left COLSPAN=2> Concurrency Under UNIX &nbsp;&nbsp 33 <TR> <TD ALIGN=left>3.10 <TD ALIGN=left COLSPAN=2> Executing A Separately Compiled Program &nbsp;&nbsp 34 <TR> <TD ALIGN=left>3.11 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 35 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 35<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 36<BR> </TABLE> <BR> <BR> <H3>Chapter 4 &nbsp; Program Interface To Protocols &nbsp;&nbsp; 37</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>4.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 37 <TR> <TD ALIGN=left>4.2 <TD ALIGN=left COLSPAN=2> Loosely Specified Protocol Software Interface &nbsp;&nbsp 37 <TR> <TD ALIGN=left> <TD ALIGN=left>4.2.1 <TD ALIGN=left> Advantages And Disadvantages &nbsp;&nbsp 38 <TR> <TD ALIGN=left>4.3 <TD ALIGN=left COLSPAN=2> Interface Functionality &nbsp;&nbsp 38 <TR> <TD ALIGN=left>4.4 <TD ALIGN=left COLSPAN=2> Conceptual Interface Specification &nbsp;&nbsp 39 <TR> <TD ALIGN=left>4.5 <TD ALIGN=left COLSPAN=2> Implementation Of An API &nbsp;&nbsp 39 <TR> <TD ALIGN=left>4.6 <TD ALIGN=left COLSPAN=2> Two Basic Approaches To Network Communication &nbsp;&nbsp 41 <TR> <TD ALIGN=left>4.7 <TD ALIGN=left COLSPAN=2> The Basic I/O Functions Available In ANSI C &nbsp;&nbsp 42 <TR> <TD ALIGN=left>4.8 <TD ALIGN=left COLSPAN=2> History Of The UNIX Socket API &nbsp;&nbsp 43 <TR> <TD ALIGN=left>4.9 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 44 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 44<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 45<BR> </TABLE> <BR> <BR> <H3>Chapter 5 &nbsp; The Socket API &nbsp;&nbsp; 47</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>5.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 47 <TR> <TD ALIGN=left>5.2 <TD ALIGN=left COLSPAN=2> The History Of Sockets &nbsp;&nbsp 47 <TR> <TD ALIGN=left>5.3 <TD ALIGN=left COLSPAN=2> Specifying A Protocol Interface &nbsp;&nbsp 48 <TR> <TD ALIGN=left>5.4 <TD ALIGN=left COLSPAN=2> The Socket Abstraction &nbsp;&nbsp 49 <TR> <TD ALIGN=left> <TD ALIGN=left>5.4.1 <TD ALIGN=left> Socket Descriptors &nbsp;&nbsp 49 <TR> <TD ALIGN=left> <TD ALIGN=left>5.4.2 <TD ALIGN=left> System Data Structures For Sockets &nbsp;&nbsp 50 <TR> <TD ALIGN=left> <TD ALIGN=left>5.4.3 <TD ALIGN=left> Using Sockets &nbsp;&nbsp 51 <TR> <TD ALIGN=left>5.5 <TD ALIGN=left COLSPAN=2> Specifying An Endpoint Address &nbsp;&nbsp 51 <TR> <TD ALIGN=left>5.6 <TD ALIGN=left COLSPAN=2> A Generic Address Structure &nbsp;&nbsp 52 <TR> <TD ALIGN=left>5.7 <TD ALIGN=left COLSPAN=2> Functions In The Socket API &nbsp;&nbsp 53 <TR> <TD ALIGN=left> <TD ALIGN=left>5.7.1 <TD ALIGN=left> The WSAStartup Function &nbsp;&nbsp 53 <TR> <TD ALIGN=left> <TD ALIGN=left>5.7.2 <TD ALIGN=left> The WSACleanup Function &nbsp;&nbsp 54 <TR> <TD ALIGN=left> <TD ALIGN=left>5.7.3 <TD ALIGN=left> The Socket Function &nbsp;&nbsp 54 <TR> <TD ALIGN=left> <TD ALIGN=left>5.7.4 <TD ALIGN=left> The Connect Function &nbsp;&nbsp 54 <TR> <TD ALIGN=left> <TD ALIGN=left>5.7.5 <TD ALIGN=left> The Send Function &nbsp;&nbsp 54 <TR> <TD ALIGN=left> <TD ALIGN=left>5.7.6 <TD ALIGN=left> The Recv Function &nbsp;&nbsp 55 <TR> <TD ALIGN=left> <TD ALIGN=left>5.7.7 <TD ALIGN=left> The Closesocket Function &nbsp;&nbsp 55 <TR> <TD ALIGN=left> <TD ALIGN=left>5.7.8 <TD ALIGN=left> The Bind Function &nbsp;&nbsp 55 <TR> <TD ALIGN=left> <TD ALIGN=left>5.7.9 <TD ALIGN=left> The Listen Function &nbsp;&nbsp 55 <TR> <TD ALIGN=left> <TD ALIGN=left>5.7.10 <TD ALIGN=left> The Accept Function &nbsp;&nbsp 56 <TR> <TD ALIGN=left> <TD ALIGN=left>5.7.11 <TD ALIGN=left> Summary Of Socket Calls Used With TCP &nbsp;&nbsp 56 <TR> <TD ALIGN=left>5.8 <TD ALIGN=left COLSPAN=2> Utility Routines For Integer Conversion &nbsp;&nbsp 56 <TR> <TD ALIGN=left>5.9 <TD ALIGN=left COLSPAN=2> Using Socket Calls In A Program &nbsp;&nbsp 58 <TR> <TD ALIGN=left>5.10 <TD ALIGN=left COLSPAN=2> Symbolic Constants For Socket Call Parameters &nbsp;&nbsp 59 <TR> <TD ALIGN=left>5.11 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 59 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 60<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 60<BR> </TABLE> <BR> <BR> <H3>Chapter 6 &nbsp; Algorithms And Issues In Client Software Design &nbsp;&nbsp; 61</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>6.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 61 <TR> <TD ALIGN=left>6.2 <TD ALIGN=left COLSPAN=2> Learning Algorithms Instead Of Details &nbsp;&nbsp 61 <TR> <TD ALIGN=left>6.3 <TD ALIGN=left COLSPAN=2> Client Architecture &nbsp;&nbsp 62 <TR> <TD ALIGN=left>6.4 <TD ALIGN=left COLSPAN=2> Identifying The Location Of A Server &nbsp;&nbsp 62 <TR> <TD ALIGN=left>6.5 <TD ALIGN=left COLSPAN=2> Parsing An Address Argument &nbsp;&nbsp 64 <TR> <TD ALIGN=left>6.6 <TD ALIGN=left COLSPAN=2> Looking Up A Domain Name &nbsp;&nbsp 65 <TR> <TD ALIGN=left>6.7 <TD ALIGN=left COLSPAN=2> Looking Up A Well-Known Port By Name &nbsp;&nbsp 66 <TR> <TD ALIGN=left>6.8 <TD ALIGN=left COLSPAN=2> Port Numbers And Network Byte Order &nbsp;&nbsp 66 <TR> <TD ALIGN=left>6.9 <TD ALIGN=left COLSPAN=2> Looking Up A Protocol By Name &nbsp;&nbsp 67 <TR> <TD ALIGN=left>6.10 <TD ALIGN=left COLSPAN=2> The TCP Client Algorithm &nbsp;&nbsp 67 <TR> <TD ALIGN=left>6.11 <TD ALIGN=left COLSPAN=2> Allocating A Socket &nbsp;&nbsp 68 <TR> <TD ALIGN=left>6.12 <TD ALIGN=left COLSPAN=2> Choosing A Local Protocol Port Number &nbsp;&nbsp 69 <TR> <TD ALIGN=left>6.13 <TD ALIGN=left COLSPAN=2> A Fundamental Problem In Choosing A Local IP Address &nbsp;&nbsp 69 <TR> <TD ALIGN=left>6.14 <TD ALIGN=left COLSPAN=2> Connecting A TCP Socket To A Server &nbsp;&nbsp 70 <TR> <TD ALIGN=left>6.15 <TD ALIGN=left COLSPAN=2> Communicating With The Server Using TCP &nbsp;&nbsp 70 <TR> <TD ALIGN=left>6.16 <TD ALIGN=left COLSPAN=2> Reading A Response From A TCP Connection &nbsp;&nbsp 71 <TR> <TD ALIGN=left>6.17 <TD ALIGN=left COLSPAN=2> Closing A TCP Connection &nbsp;&nbsp 72 <TR> <TD ALIGN=left> <TD ALIGN=left>6.17.1 <TD ALIGN=left> The Need For Partial Close &nbsp;&nbsp 72 <TR> <TD ALIGN=left> <TD ALIGN=left>6.17.2 <TD ALIGN=left> A Partial Close Operation &nbsp;&nbsp 72 <TR> <TD ALIGN=left>6.18 <TD ALIGN=left COLSPAN=2> Programming A UDP Client &nbsp;&nbsp 73 <TR> <TD ALIGN=left>6.19 <TD ALIGN=left COLSPAN=2> Connected And Unconnected UDP Sockets &nbsp;&nbsp 73 <TR> <TD ALIGN=left>6.20 <TD ALIGN=left COLSPAN=2> Using Connect With UDP &nbsp;&nbsp 74 <TR> <TD ALIGN=left>6.21 <TD ALIGN=left COLSPAN=2> Communicating With A Server Using UDP &nbsp;&nbsp 74 <TR> <TD ALIGN=left>6.22 <TD ALIGN=left COLSPAN=2> Closing A Socket That Uses UDP &nbsp;&nbsp 74 <TR> <TD ALIGN=left>6.23 <TD ALIGN=left COLSPAN=2> Partial Close For UDP &nbsp;&nbsp 75 <TR> <TD ALIGN=left>6.24 <TD ALIGN=left COLSPAN=2> A Warning About UDP Unreliability &nbsp;&nbsp 75 <TR> <TD ALIGN=left>6.25 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 75 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 76<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 76<BR> </TABLE> <BR> <BR> <H3>Chapter 7 &nbsp; Example Client Software &nbsp;&nbsp; 79</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>7.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 79 <TR> <TD ALIGN=left>7.2 <TD ALIGN=left COLSPAN=2> The Importance Of Small Examples &nbsp;&nbsp 79 <TR> <TD ALIGN=left>7.3 <TD ALIGN=left COLSPAN=2> Hiding Details &nbsp;&nbsp 80 <TR> <TD ALIGN=left>7.4 <TD ALIGN=left COLSPAN=2> An Example Procedure Library For Client Programs &nbsp;&nbsp 80 <TR> <TD ALIGN=left>7.5 <TD ALIGN=left COLSPAN=2> Implementation Of ConTCP &nbsp;&nbsp 81 <TR> <TD ALIGN=left>7.6 <TD ALIGN=left COLSPAN=2> Implementation Of ConUDP &nbsp;&nbsp 82 <TR> <TD ALIGN=left>7.7 <TD ALIGN=left COLSPAN=2> A Procedure That Forms Connections &nbsp;&nbsp 82 <TR> <TD ALIGN=left>7.8 <TD ALIGN=left COLSPAN=2> Using The Example Library &nbsp;&nbsp 85 <TR> <TD ALIGN=left>7.9 <TD ALIGN=left COLSPAN=2> The DAYTIME Service &nbsp;&nbsp 85 <TR> <TD ALIGN=left>7.10 <TD ALIGN=left COLSPAN=2> Implementation Of A TCP Client For DAYTIME &nbsp;&nbsp 86 <TR> <TD ALIGN=left>7.11 <TD ALIGN=left COLSPAN=2> Reading From A TCP Connection &nbsp;&nbsp 87 <TR> <TD ALIGN=left>7.12 <TD ALIGN=left COLSPAN=2> The TIME Service &nbsp;&nbsp 88 <TR> <TD ALIGN=left>7.13 <TD ALIGN=left COLSPAN=2> Accessing The TIME Service &nbsp;&nbsp 88 <TR> <TD ALIGN=left>7.14 <TD ALIGN=left COLSPAN=2> Accurate Times And Network Delays &nbsp;&nbsp 89 <TR> <TD ALIGN=left>7.15 <TD ALIGN=left COLSPAN=2> A UDP Client For The TIME Service &nbsp;&nbsp 89 <TR> <TD ALIGN=left>7.16 <TD ALIGN=left COLSPAN=2> The ECHO Service &nbsp;&nbsp 91 <TR> <TD ALIGN=left>7.17 <TD ALIGN=left COLSPAN=2> A TCP Client For The ECHO Service &nbsp;&nbsp 92 <TR> <TD ALIGN=left>7.18 <TD ALIGN=left COLSPAN=2> A UDP Client For The ECHO Service &nbsp;&nbsp 94 <TR> <TD ALIGN=left>7.19 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 96 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 96<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 96<BR> </TABLE> <BR> <BR> <H3>Chapter 8 &nbsp; Algorithms And Issues In Server Software Design &nbsp;&nbsp; 99</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>8.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 99 <TR> <TD ALIGN=left>8.2 <TD ALIGN=left COLSPAN=2> The Conceptual Server Algorithm &nbsp;&nbsp 99 <TR> <TD ALIGN=left>8.3 <TD ALIGN=left COLSPAN=2> Concurrent Vs. Iterative Servers &nbsp;&nbsp 100 <TR> <TD ALIGN=left>8.4 <TD ALIGN=left COLSPAN=2> Connection-Oriented Vs. Connectionless Access &nbsp;&nbsp 100 <TR> <TD ALIGN=left>8.5 <TD ALIGN=left COLSPAN=2> Connection-Oriented Servers &nbsp;&nbsp 101 <TR> <TD ALIGN=left>8.6 <TD ALIGN=left COLSPAN=2> Connectionless Servers &nbsp;&nbsp 101 <TR> <TD ALIGN=left>8.7 <TD ALIGN=left COLSPAN=2> Failure, Reliability, And Statelessness &nbsp;&nbsp 102 <TR> <TD ALIGN=left>8.8 <TD ALIGN=left COLSPAN=2> Optimizing Stateless Servers &nbsp;&nbsp 103 <TR> <TD ALIGN=left>8.9 <TD ALIGN=left COLSPAN=2> Four Basic Types Of Servers &nbsp;&nbsp 105 <TR> <TD ALIGN=left>8.10 <TD ALIGN=left COLSPAN=2> Request Processing Time &nbsp;&nbsp 106 <TR> <TD ALIGN=left>8.11 <TD ALIGN=left COLSPAN=2> Iterative Server Algorithms &nbsp;&nbsp 106 <TR> <TD ALIGN=left>8.12 <TD ALIGN=left COLSPAN=2> An Iterative, Connection-Oriented Server Algorithm &nbsp;&nbsp 107 <TR> <TD ALIGN=left>8.13 <TD ALIGN=left COLSPAN=2> Binding To A Well-Known Address Using INADDR_ANY &nbsp;&nbsp 107 <TR> <TD ALIGN=left>8.14 <TD ALIGN=left COLSPAN=2> Placing The Socket In Passive Mode &nbsp;&nbsp 108 <TR> <TD ALIGN=left>8.15 <TD ALIGN=left COLSPAN=2> Accepting Connections And Using Them &nbsp;&nbsp 108 <TR> <TD ALIGN=left>8.16 <TD ALIGN=left COLSPAN=2> An Iterative, Connectionless Server Algorithm &nbsp;&nbsp 108 <TR> <TD ALIGN=left>8.17 <TD ALIGN=left COLSPAN=2> Forming A Reply Address In A Connectionless Server &nbsp;&nbsp 109 <TR> <TD ALIGN=left>8.18 <TD ALIGN=left COLSPAN=2> Concurrent Server Algorithms &nbsp;&nbsp 110 <TR> <TD ALIGN=left>8.19 <TD ALIGN=left COLSPAN=2> Master And Slave Threads &nbsp;&nbsp 110 <TR> <TD ALIGN=left>8.20 <TD ALIGN=left COLSPAN=2> A Concurrent, Connectionless Server Algorithm &nbsp;&nbsp 111 <TR> <TD ALIGN=left>8.21 <TD ALIGN=left COLSPAN=2> A Concurrent, Connection-Oriented Server Algorithm &nbsp;&nbsp 111 <TR> <TD ALIGN=left>8.22 <TD ALIGN=left COLSPAN=2> Using Separate Programs As Slaves &nbsp;&nbsp 112 <TR> <TD ALIGN=left>8.23 <TD ALIGN=left COLSPAN=2> Apparent Concurrency Using A Single Thread &nbsp;&nbsp 113 <TR> <TD ALIGN=left>8.24 <TD ALIGN=left COLSPAN=2> When To Use Each Server Type &nbsp;&nbsp 114 <TR> <TD ALIGN=left>8.25 <TD ALIGN=left COLSPAN=2> A Summary of Server Types &nbsp;&nbsp 115 <TR> <TD ALIGN=left>8.26 <TD ALIGN=left COLSPAN=2> The Important Problem Of Server Deadlock &nbsp;&nbsp 116 <TR> <TD ALIGN=left>8.27 <TD ALIGN=left COLSPAN=2> Alternative Implementations &nbsp;&nbsp 116 <TR> <TD ALIGN=left>8.28 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 117 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 117<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 117<BR> </TABLE> <BR> <BR> <H3>Chapter 9 &nbsp; Iterative, Connectionless Servers (UDP) &nbsp;&nbsp; 119</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>9.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 119 <TR> <TD ALIGN=left>9.2 <TD ALIGN=left COLSPAN=2> Creating A Passive Socket &nbsp;&nbsp 119 <TR> <TD ALIGN=left>9.3 <TD ALIGN=left COLSPAN=2> Thread Structure &nbsp;&nbsp 122 <TR> <TD ALIGN=left>9.4 <TD ALIGN=left COLSPAN=2> An Example TIME Server &nbsp;&nbsp 123 <TR> <TD ALIGN=left>9.5 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 125 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 126<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 126<BR> </TABLE> <BR> <BR> <H3>Chapter 10 &nbsp; Iterative, Connection-Oriented Servers (TCP) &nbsp;&nbsp; 127</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>10.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 127 <TR> <TD ALIGN=left>10.2 <TD ALIGN=left COLSPAN=2> Allocating A Passive TCP Socket &nbsp;&nbsp 127 <TR> <TD ALIGN=left>10.3 <TD ALIGN=left COLSPAN=2> A Server For The DAYTIME Service &nbsp;&nbsp 128 <TR> <TD ALIGN=left>10.4 <TD ALIGN=left COLSPAN=2> Thread Structure &nbsp;&nbsp 128 <TR> <TD ALIGN=left>10.5 <TD ALIGN=left COLSPAN=2> An Example DAYTIME Server &nbsp;&nbsp 129 <TR> <TD ALIGN=left>10.6 <TD ALIGN=left COLSPAN=2> Closing Connections &nbsp;&nbsp 132 <TR> <TD ALIGN=left>10.7 <TD ALIGN=left COLSPAN=2> Connection Termination And Server Vulnerability &nbsp;&nbsp 132 <TR> <TD ALIGN=left>10.8 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 133 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 133<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 133<BR> </TABLE> <BR> <BR> <H3>Chapter 11 &nbsp; Concurrent, Connection-Oriented Servers (TCP) &nbsp;&nbsp; 135</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>11.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 135 <TR> <TD ALIGN=left>11.2 <TD ALIGN=left COLSPAN=2> Concurrent ECHO &nbsp;&nbsp 135 <TR> <TD ALIGN=left>11.3 <TD ALIGN=left COLSPAN=2> Iterative Vs. Concurrent Implementations &nbsp;&nbsp 136 <TR> <TD ALIGN=left>11.4 <TD ALIGN=left COLSPAN=2> Thread Structure &nbsp;&nbsp 136 <TR> <TD ALIGN=left>11.5 <TD ALIGN=left COLSPAN=2> An Example Concurrent ECHO Server &nbsp;&nbsp 137 <TR> <TD ALIGN=left>11.6 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 140 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 141<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 141<BR> </TABLE> <BR> <BR> <H3>Chapter 12 &nbsp; Singly-Threaded, Concurrent Servers (TCP) &nbsp;&nbsp; 143</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>12.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 143 <TR> <TD ALIGN=left>12.2 <TD ALIGN=left COLSPAN=2> Data-driven Processing In A Server &nbsp;&nbsp 143 <TR> <TD ALIGN=left>12.3 <TD ALIGN=left COLSPAN=2> Data-Driven Processing With A Single Thread &nbsp;&nbsp 144 <TR> <TD ALIGN=left>12.4 <TD ALIGN=left COLSPAN=2> Thread Structure Of A Singly-Threaded Server &nbsp;&nbsp 145 <TR> <TD ALIGN=left>12.5 <TD ALIGN=left COLSPAN=2> An Example Singly-Threaded ECHO Server &nbsp;&nbsp 146 <TR> <TD ALIGN=left>12.6 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 148 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 149<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 149<BR> </TABLE> <BR> <BR> <H3>Chapter 13 &nbsp; Multiprotocol Servers (TCP, UDP) &nbsp;&nbsp; 151</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>13.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 151 <TR> <TD ALIGN=left>13.2 <TD ALIGN=left COLSPAN=2> The Motivation For Reducing The Number Of Servers &nbsp;&nbsp 151 <TR> <TD ALIGN=left>13.3 <TD ALIGN=left COLSPAN=2> Multiprotocol Server Design &nbsp;&nbsp 152 <TR> <TD ALIGN=left>13.4 <TD ALIGN=left COLSPAN=2> Thread Structure &nbsp;&nbsp 152 <TR> <TD ALIGN=left>13.5 <TD ALIGN=left COLSPAN=2> An Example Multiprotocol DAYTIME Server &nbsp;&nbsp 153 <TR> <TD ALIGN=left>13.6 <TD ALIGN=left COLSPAN=2> The Concept Of Shared Code &nbsp;&nbsp 157 <TR> <TD ALIGN=left>13.7 <TD ALIGN=left COLSPAN=2> Concurrent Multiprotocol Servers &nbsp;&nbsp 157 <TR> <TD ALIGN=left>13.8 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 157 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 158<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 158<BR> </TABLE> <BR> <BR> <H3>Chapter 14 &nbsp; Multiservice Servers (TCP, UDP) &nbsp;&nbsp; 159</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>14.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 159 <TR> <TD ALIGN=left>14.2 <TD ALIGN=left COLSPAN=2> Consolidating Servers &nbsp;&nbsp 159 <TR> <TD ALIGN=left>14.3 <TD ALIGN=left COLSPAN=2> A Connectionless, Multiservice Server Design &nbsp;&nbsp 160 <TR> <TD ALIGN=left>14.4 <TD ALIGN=left COLSPAN=2> A Connection-Oriented, Multiservice Server Design &nbsp;&nbsp 161 <TR> <TD ALIGN=left>14.5 <TD ALIGN=left COLSPAN=2> A Concurrent, Connection-Oriented, Multiservice Server &nbsp;&nbsp 162 <TR> <TD ALIGN=left>14.6 <TD ALIGN=left COLSPAN=2> A Singly-Threaded, Multiservice Server Implementation &nbsp;&nbsp 162 <TR> <TD ALIGN=left>14.7 <TD ALIGN=left COLSPAN=2> Invoking Separate Programs From A Multiservice Server &nbsp;&nbsp 163 <TR> <TD ALIGN=left>14.8 <TD ALIGN=left COLSPAN=2> Multiservice, Multiprotocol Designs &nbsp;&nbsp 164 <TR> <TD ALIGN=left>14.9 <TD ALIGN=left COLSPAN=2> An Example Multiservice Server &nbsp;&nbsp 165 <TR> <TD ALIGN=left>14.10 <TD ALIGN=left COLSPAN=2> Static and Dynamic Server Configuration &nbsp;&nbsp 171 <TR> <TD ALIGN=left>14.11 <TD ALIGN=left COLSPAN=2> An Example Super Server, Inetd &nbsp;&nbsp 172 <TR> <TD ALIGN=left>14.12 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 174 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 175<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 175<BR> </TABLE> <BR> <BR> <H3>Chapter 15 &nbsp; Uniform, Efficient Management Of Server Concurrency &nbsp;&nbsp; 177</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>15.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 177 <TR> <TD ALIGN=left>15.2 <TD ALIGN=left COLSPAN=2> Choosing Between An Iterative And A Concurrent Design &nbsp;&nbsp 177 <TR> <TD ALIGN=left>15.3 <TD ALIGN=left COLSPAN=2> Level Of Concurrency &nbsp;&nbsp 178 <TR> <TD ALIGN=left>15.4 <TD ALIGN=left COLSPAN=2> Demand-Driven Concurrency &nbsp;&nbsp 179 <TR> <TD ALIGN=left>15.5 <TD ALIGN=left COLSPAN=2> The Cost Of Concurrency &nbsp;&nbsp 179 <TR> <TD ALIGN=left>15.6 <TD ALIGN=left COLSPAN=2> Overhead And Delay &nbsp;&nbsp 179 <TR> <TD ALIGN=left>15.7 <TD ALIGN=left COLSPAN=2> Small Delays Can Matter &nbsp;&nbsp 180 <TR> <TD ALIGN=left>15.8 <TD ALIGN=left COLSPAN=2> Thread Preallocation &nbsp;&nbsp 181 <TR> <TD ALIGN=left> <TD ALIGN=left>15.8.1 <TD ALIGN=left> Preallocation Techniques &nbsp;&nbsp 182 <TR> <TD ALIGN=left> <TD ALIGN=left>15.8.2 <TD ALIGN=left> Preallocation In A Connection-Oriented Server &nbsp;&nbsp 182 <TR> <TD ALIGN=left> <TD ALIGN=left>15.8.3 <TD ALIGN=left> Preallocation In A Connectionless Server &nbsp;&nbsp 183 <TR> <TD ALIGN=left> <TD ALIGN=left>15.8.4 <TD ALIGN=left> Preallocation, Bursty Traffic, And NFS &nbsp;&nbsp 184 <TR> <TD ALIGN=left> <TD ALIGN=left>15.8.5 <TD ALIGN=left> Preallocation On A Multiprocessor &nbsp;&nbsp 185 <TR> <TD ALIGN=left>15.9 <TD ALIGN=left COLSPAN=2> Delayed Thread Allocation &nbsp;&nbsp 185 <TR> <TD ALIGN=left>15.10 <TD ALIGN=left COLSPAN=2> The Uniform Basis For Both Techniques &nbsp;&nbsp 186 <TR> <TD ALIGN=left>15.11 <TD ALIGN=left COLSPAN=2> Combining Techniques &nbsp;&nbsp 187 <TR> <TD ALIGN=left>15.12 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 187 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 188<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 188<BR> </TABLE> <BR> <BR> <H3>Chapter 16 &nbsp; Concurrency In Clients &nbsp;&nbsp; 189</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>16.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 189 <TR> <TD ALIGN=left>16.2 <TD ALIGN=left COLSPAN=2> The Advantages Of Concurrency &nbsp;&nbsp 189 <TR> <TD ALIGN=left>16.3 <TD ALIGN=left COLSPAN=2> The Motivation For Exercising Control &nbsp;&nbsp 190 <TR> <TD ALIGN=left>16.4 <TD ALIGN=left COLSPAN=2> Concurrent Contact With Multiple Servers &nbsp;&nbsp 191 <TR> <TD ALIGN=left>16.5 <TD ALIGN=left COLSPAN=2> Implementing Concurrent Clients &nbsp;&nbsp 191 <TR> <TD ALIGN=left>16.6 <TD ALIGN=left COLSPAN=2> Singly-Threaded Implementations &nbsp;&nbsp 193 <TR> <TD ALIGN=left>16.7 <TD ALIGN=left COLSPAN=2> An Example Concurrent Client That Uses ECHO &nbsp;&nbsp 194 <TR> <TD ALIGN=left>16.8 <TD ALIGN=left COLSPAN=2> Execution Of The Concurrent Client &nbsp;&nbsp 198 <TR> <TD ALIGN=left>16.9 <TD ALIGN=left COLSPAN=2> Managing A Timer &nbsp;&nbsp 199 <TR> <TD ALIGN=left>16.10 <TD ALIGN=left COLSPAN=2> Example Output &nbsp;&nbsp 200 <TR> <TD ALIGN=left>16.11 <TD ALIGN=left COLSPAN=2> Concurrency In The Example Code &nbsp;&nbsp 200 <TR> <TD ALIGN=left>16.12 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 201 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 201<BR> </TABLE> <BR> <BR> <H3>Chapter 17 &nbsp; Tunneling At The Transport And Application Levels &nbsp;&nbsp; 203</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>17.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 203 <TR> <TD ALIGN=left>17.2 <TD ALIGN=left COLSPAN=2> Multiprotocol Environments &nbsp;&nbsp 203 <TR> <TD ALIGN=left>17.3 <TD ALIGN=left COLSPAN=2> Mixing Network Technologies &nbsp;&nbsp 205 <TR> <TD ALIGN=left>17.4 <TD ALIGN=left COLSPAN=2> Dynamic Circuit Allocation &nbsp;&nbsp 206 <TR> <TD ALIGN=left>17.5 <TD ALIGN=left COLSPAN=2> Encapsulation And Tunneling &nbsp;&nbsp 207 <TR> <TD ALIGN=left>17.6 <TD ALIGN=left COLSPAN=2> Tunneling Through An IP Internet &nbsp;&nbsp 208 <TR> <TD ALIGN=left>17.7 <TD ALIGN=left COLSPAN=2> Application-Level Tunneling Between Clients And Servers &nbsp;&nbsp 208 <TR> <TD ALIGN=left>17.8 <TD ALIGN=left COLSPAN=2> Tunneling, Encapsulation, And Dialup Phone Lines &nbsp;&nbsp 209 <TR> <TD ALIGN=left>17.9 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 210 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 211<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 211<BR> </TABLE> <BR> <BR> <H3>Chapter 18 &nbsp; Application Level Gateways &nbsp;&nbsp; 213</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>18.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 213 <TR> <TD ALIGN=left>18.2 <TD ALIGN=left COLSPAN=2> Clients And Servers In Constrained Environments &nbsp;&nbsp 213 <TR> <TD ALIGN=left> <TD ALIGN=left>18.2.1 <TD ALIGN=left> The Reality Of Multiple Technologies &nbsp;&nbsp 213 <TR> <TD ALIGN=left> <TD ALIGN=left>18.2.2 <TD ALIGN=left> Computers With Limited Functionality &nbsp;&nbsp 214 <TR> <TD ALIGN=left> <TD ALIGN=left>18.2.3 <TD ALIGN=left> Connectivity Constraints That Arise From Security &nbsp;&nbsp 214 <TR> <TD ALIGN=left>18.3 <TD ALIGN=left COLSPAN=2> Using Application Gateways &nbsp;&nbsp 215 <TR> <TD ALIGN=left>18.4 <TD ALIGN=left COLSPAN=2> Interoperability Through A Mail Gateway &nbsp;&nbsp 216 <TR> <TD ALIGN=left>18.5 <TD ALIGN=left COLSPAN=2> Implementation Of A Mail Gateway &nbsp;&nbsp 217 <TR> <TD ALIGN=left>18.6 <TD ALIGN=left COLSPAN=2> A Comparison Of Application Gateways And Tunneling &nbsp;&nbsp 217 <TR> <TD ALIGN=left>18.7 <TD ALIGN=left COLSPAN=2> Application Gateways And Limited Functionality Systems &nbsp;&nbsp 219 <TR> <TD ALIGN=left>18.8 <TD ALIGN=left COLSPAN=2> Application Gateways Used For Security &nbsp;&nbsp 220 <TR> <TD ALIGN=left>18.9 <TD ALIGN=left COLSPAN=2> Application Gateways And The Extra Hop Problem &nbsp;&nbsp 221 <TR> <TD ALIGN=left>18.10 <TD ALIGN=left COLSPAN=2> An Example Application Gateway &nbsp;&nbsp 223 <TR> <TD ALIGN=left>18.11 <TD ALIGN=left COLSPAN=2> Details Of A Web-Based Application Gateway &nbsp;&nbsp 224 <TR> <TD ALIGN=left>18.12 <TD ALIGN=left COLSPAN=2> Invoking A CGI Program &nbsp;&nbsp 225 <TR> <TD ALIGN=left>18.13 <TD ALIGN=left COLSPAN=2> URLs For The RFC Application Gateway &nbsp;&nbsp 226 <TR> <TD ALIGN=left>18.14 <TD ALIGN=left COLSPAN=2> A General-Purpose Application Gateway &nbsp;&nbsp 226 <TR> <TD ALIGN=left>18.15 <TD ALIGN=left COLSPAN=2> Operation Of SLIRP &nbsp;&nbsp 227 <TR> <TD ALIGN=left>18.16 <TD ALIGN=left COLSPAN=2> How SLIRP Handles Connections &nbsp;&nbsp 227 <TR> <TD ALIGN=left>18.17 <TD ALIGN=left COLSPAN=2> IP Addressing And SLIRP &nbsp;&nbsp 228 <TR> <TD ALIGN=left>18.18 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 229 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 229<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 230<BR> </TABLE> <BR> <BR> <H3>Chapter 19 &nbsp; External Data Representation (XDR) &nbsp;&nbsp; 231</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>19.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 231 <TR> <TD ALIGN=left>19.2 <TD ALIGN=left COLSPAN=2> Representations For Data In Computers &nbsp;&nbsp 231 <TR> <TD ALIGN=left>19.3 <TD ALIGN=left COLSPAN=2> The N-Squared Conversion Problem &nbsp;&nbsp 232 <TR> <TD ALIGN=left>19.4 <TD ALIGN=left COLSPAN=2> Network Standard Byte Order &nbsp;&nbsp 233 <TR> <TD ALIGN=left>19.5 <TD ALIGN=left COLSPAN=2> A De Facto Standard External Data Representation &nbsp;&nbsp 234 <TR> <TD ALIGN=left>19.6 <TD ALIGN=left COLSPAN=2> XDR Data Types &nbsp;&nbsp 235 <TR> <TD ALIGN=left>19.7 <TD ALIGN=left COLSPAN=2> Implicit Types &nbsp;&nbsp 236 <TR> <TD ALIGN=left>19.8 <TD ALIGN=left COLSPAN=2> Software Support For Using XDR &nbsp;&nbsp 236 <TR> <TD ALIGN=left>19.9 <TD ALIGN=left COLSPAN=2> XDR Library Routines &nbsp;&nbsp 236 <TR> <TD ALIGN=left>19.10 <TD ALIGN=left COLSPAN=2> Building A Message One Piece At A Time &nbsp;&nbsp 236 <TR> <TD ALIGN=left>19.11 <TD ALIGN=left COLSPAN=2> Conversion Routines In The XDR Library &nbsp;&nbsp 238 <TR> <TD ALIGN=left>19.12 <TD ALIGN=left COLSPAN=2> XDR Streams, I/O, and TCP &nbsp;&nbsp 240 <TR> <TD ALIGN=left>19.13 <TD ALIGN=left COLSPAN=2> Records, Record Boundaries, And Datagram I/O &nbsp;&nbsp 241 <TR> <TD ALIGN=left>19.14 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 241 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 242<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 242<BR> </TABLE> <BR> <BR> <H3>Chapter 20 &nbsp; Remote Procedure Call Concept (RPC) &nbsp;&nbsp; 243</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>20.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 243 <TR> <TD ALIGN=left>20.2 <TD ALIGN=left COLSPAN=2> Remote Procedure Call Model &nbsp;&nbsp 243 <TR> <TD ALIGN=left>20.3 <TD ALIGN=left COLSPAN=2> Two Paradigms For Building Distributed Programs &nbsp;&nbsp 244 <TR> <TD ALIGN=left>20.4 <TD ALIGN=left COLSPAN=2> A Conceptual Model For Conventional Procedure Calls &nbsp;&nbsp 245 <TR> <TD ALIGN=left>20.5 <TD ALIGN=left COLSPAN=2> An Extension Of the Procedural Model &nbsp;&nbsp 245 <TR> <TD ALIGN=left>20.6 <TD ALIGN=left COLSPAN=2> Execution Of Conventional Procedure Call And Return &nbsp;&nbsp 246 <TR> <TD ALIGN=left>20.7 <TD ALIGN=left COLSPAN=2> The Procedural Model In Distributed Systems &nbsp;&nbsp 247 <TR> <TD ALIGN=left>20.8 <TD ALIGN=left COLSPAN=2> Analogy Between Client-Server And RPC &nbsp;&nbsp 248 <TR> <TD ALIGN=left>20.9 <TD ALIGN=left COLSPAN=2> Distributed Computation As A Program &nbsp;&nbsp 249 <TR> <TD ALIGN=left>20.10 <TD ALIGN=left COLSPAN=2> Sun Microsystems' Remote Procedure Call Definition &nbsp;&nbsp 250 <TR> <TD ALIGN=left>20.11 <TD ALIGN=left COLSPAN=2> Remote Programs And Procedures &nbsp;&nbsp 250 <TR> <TD ALIGN=left>20.12 <TD ALIGN=left COLSPAN=2> Reducing The Number Of Arguments &nbsp;&nbsp 251 <TR> <TD ALIGN=left>20.13 <TD ALIGN=left COLSPAN=2> Identifying Remote Programs And Procedures &nbsp;&nbsp 251 <TR> <TD ALIGN=left>20.14 <TD ALIGN=left COLSPAN=2> Accommodating Multiple Versions Of A Remote Program &nbsp;&nbsp 252 <TR> <TD ALIGN=left>20.15 <TD ALIGN=left COLSPAN=2> Mutual Exclusion For Procedures In A Remote Program &nbsp;&nbsp 253 <TR> <TD ALIGN=left>20.16 <TD ALIGN=left COLSPAN=2> Communication Semantics &nbsp;&nbsp 254 <TR> <TD ALIGN=left>20.17 <TD ALIGN=left COLSPAN=2> At Least Once Semantics &nbsp;&nbsp 254 <TR> <TD ALIGN=left>20.18 <TD ALIGN=left COLSPAN=2> RPC Retransmission &nbsp;&nbsp 255 <TR> <TD ALIGN=left>20.19 <TD ALIGN=left COLSPAN=2> Mapping A Remote Program To A Protocol Port &nbsp;&nbsp 255 <TR> <TD ALIGN=left>20.20 <TD ALIGN=left COLSPAN=2> Dynamic Port Mapping &nbsp;&nbsp 256 <TR> <TD ALIGN=left>20.21 <TD ALIGN=left COLSPAN=2> RPC Port Mapper Algorithm &nbsp;&nbsp 257 <TR> <TD ALIGN=left>20.22 <TD ALIGN=left COLSPAN=2> RPC Message Format &nbsp;&nbsp 259 <TR> <TD ALIGN=left>20.23 <TD ALIGN=left COLSPAN=2> Marshaling Arguments For A Remote Procedure &nbsp;&nbsp 260 <TR> <TD ALIGN=left>20.24 <TD ALIGN=left COLSPAN=2> Authentication &nbsp;&nbsp 260 <TR> <TD ALIGN=left>20.25 <TD ALIGN=left COLSPAN=2> An Example Of RPC Message Representation &nbsp;&nbsp 261 <TR> <TD ALIGN=left>20.26 <TD ALIGN=left COLSPAN=2> An Example Of An Authentication Field &nbsp;&nbsp 262 <TR> <TD ALIGN=left>20.27 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 263 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 264<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 264<BR> </TABLE> <BR> <BR> <H3>Chapter 21 &nbsp; Distributed Program Generation (Rpcgen Concept) &nbsp;&nbsp; 267</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>21.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 267 <TR> <TD ALIGN=left>21.2 <TD ALIGN=left COLSPAN=2> Using Remote Procedure Calls &nbsp;&nbsp 268 <TR> <TD ALIGN=left>21.3 <TD ALIGN=left COLSPAN=2> Programming Mechanisms To Support RPC &nbsp;&nbsp 269 <TR> <TD ALIGN=left>21.4 <TD ALIGN=left COLSPAN=2> Dividing A Program Into Local And Remote Procedures &nbsp;&nbsp 270 <TR> <TD ALIGN=left>21.5 <TD ALIGN=left COLSPAN=2> Adding Code For RPC &nbsp;&nbsp 271 <TR> <TD ALIGN=left>21.6 <TD ALIGN=left COLSPAN=2> Stub Procedures &nbsp;&nbsp 271 <TR> <TD ALIGN=left>21.7 <TD ALIGN=left COLSPAN=2> Multiple Remote Procedures And Dispatching &nbsp;&nbsp 272 <TR> <TD ALIGN=left>21.8 <TD ALIGN=left COLSPAN=2> Name Of The Client-Side Stub Procedure &nbsp;&nbsp 273 <TR> <TD ALIGN=left>21.9 <TD ALIGN=left COLSPAN=2> Using Rpcgen To Generate Distributed Programs &nbsp;&nbsp 274 <TR> <TD ALIGN=left>21.10 <TD ALIGN=left COLSPAN=2> Rpcgen Output And Interface Procedures &nbsp;&nbsp 274 <TR> <TD ALIGN=left>21.11 <TD ALIGN=left COLSPAN=2> Rpcgen Input And Output &nbsp;&nbsp 275 <TR> <TD ALIGN=left>21.12 <TD ALIGN=left COLSPAN=2> Using Rpcgen To Build A Client And Server &nbsp;&nbsp 276 <TR> <TD ALIGN=left>21.13 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 276 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 278<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 278<BR> </TABLE> <BR> <BR> <H3>Chapter 22 &nbsp; Distributed Program Generation (Rpcgen Example) &nbsp;&nbsp; 279</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>22.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 279 <TR> <TD ALIGN=left>22.2 <TD ALIGN=left COLSPAN=2> An Example To Illustrate Rpcgen &nbsp;&nbsp 280 <TR> <TD ALIGN=left>22.3 <TD ALIGN=left COLSPAN=2> Dictionary Look Up &nbsp;&nbsp 280 <TR> <TD ALIGN=left>22.4 <TD ALIGN=left COLSPAN=2> Eight Steps To A Distributed Application &nbsp;&nbsp 281 <TR> <TD ALIGN=left>22.5 <TD ALIGN=left COLSPAN=2> Step 1: Build A Conventional Application Program &nbsp;&nbsp 282 <TR> <TD ALIGN=left>22.6 <TD ALIGN=left COLSPAN=2> Step 2: Divide The Program Into Two Parts &nbsp;&nbsp 286 <TR> <TD ALIGN=left>22.7 <TD ALIGN=left COLSPAN=2> Step 3: Create An Rpcgen Specification &nbsp;&nbsp 292 <TR> <TD ALIGN=left>22.8 <TD ALIGN=left COLSPAN=2> Step 4: Run Rpcgen &nbsp;&nbsp 294 <TR> <TD ALIGN=left>22.9 <TD ALIGN=left COLSPAN=2> The .h File Produced By Rpcgen &nbsp;&nbsp 294 <TR> <TD ALIGN=left>22.10 <TD ALIGN=left COLSPAN=2> The XDR Conversion File Produced By Rpcgen &nbsp;&nbsp 296 <TR> <TD ALIGN=left>22.11 <TD ALIGN=left COLSPAN=2> The Client Code Produced By Rpcgen &nbsp;&nbsp 297 <TR> <TD ALIGN=left>22.12 <TD ALIGN=left COLSPAN=2> The Server Code Produced By Rpcgen &nbsp;&nbsp 298 <TR> <TD ALIGN=left>22.13 <TD ALIGN=left COLSPAN=2> Step 5: Write Stub Interface Procedures &nbsp;&nbsp 301 <TR> <TD ALIGN=left> <TD ALIGN=left>22.13.1 <TD ALIGN=left> Client-Side Interface Routines &nbsp;&nbsp 301 <TR> <TD ALIGN=left> <TD ALIGN=left>22.13.2 <TD ALIGN=left> Server-Side Interface Routines &nbsp;&nbsp 304 <TR> <TD ALIGN=left>22.14 <TD ALIGN=left COLSPAN=2> Step 6: Compile And Link The Client Program &nbsp;&nbsp 305 <TR> <TD ALIGN=left>22.15 <TD ALIGN=left COLSPAN=2> Step 7: Compile And Link The Server Program &nbsp;&nbsp 309 <TR> <TD ALIGN=left>22.16 <TD ALIGN=left COLSPAN=2> Step 8: Start The Server And Execute The Client &nbsp;&nbsp 311 <TR> <TD ALIGN=left>22.17 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 311 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 311<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 312<BR> </TABLE> <BR> <BR> <H3>Chapter 23 &nbsp; Network File System Concepts (NFS) &nbsp;&nbsp; 313</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>23.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 313 <TR> <TD ALIGN=left>23.2 <TD ALIGN=left COLSPAN=2> Remote File Access Vs. Transfer &nbsp;&nbsp 313 <TR> <TD ALIGN=left>23.3 <TD ALIGN=left COLSPAN=2> Operations On Remote Files &nbsp;&nbsp 314 <TR> <TD ALIGN=left>23.4 <TD ALIGN=left COLSPAN=2> File Access Among Heterogeneous Computers &nbsp;&nbsp 314 <TR> <TD ALIGN=left>23.5 <TD ALIGN=left COLSPAN=2> Stateless Servers &nbsp;&nbsp 315 <TR> <TD ALIGN=left>23.6 <TD ALIGN=left COLSPAN=2> NFS And UNIX File Semantics &nbsp;&nbsp 315 <TR> <TD ALIGN=left>23.7 <TD ALIGN=left COLSPAN=2> Review Of The UNIX File System &nbsp;&nbsp 315 <TR> <TD ALIGN=left> <TD ALIGN=left>23.7.1 <TD ALIGN=left> Basic Definitions &nbsp;&nbsp 315 <TR> <TD ALIGN=left> <TD ALIGN=left>23.7.2 <TD ALIGN=left> A Byte Sequence Without Record Boundaries &nbsp;&nbsp 316 <TR> <TD ALIGN=left> <TD ALIGN=left>23.7.3 <TD ALIGN=left> A File's Owner And Group Identifiers &nbsp;&nbsp 316 <TR> <TD ALIGN=left> <TD ALIGN=left>23.7.4 <TD ALIGN=left> Protection And Access &nbsp;&nbsp 316 <TR> <TD ALIGN=left> <TD ALIGN=left>23.7.5 <TD ALIGN=left> The UNIX Open-Read-Write-Close Paradigm &nbsp;&nbsp 318 <TR> <TD ALIGN=left> <TD ALIGN=left>23.7.6 <TD ALIGN=left> UNIX Data Transfer &nbsp;&nbsp 319 <TR> <TD ALIGN=left> <TD ALIGN=left>23.7.7 <TD ALIGN=left> Permission To Search A Directory &nbsp;&nbsp 319 <TR> <TD ALIGN=left> <TD ALIGN=left>23.7.8 <TD ALIGN=left> UNIX Random Access &nbsp;&nbsp 320 <TR> <TD ALIGN=left> <TD ALIGN=left>23.7.9 <TD ALIGN=left> Seeking Beyond The End Of A UNIX File &nbsp;&nbsp 320 <TR> <TD ALIGN=left> <TD ALIGN=left>23.7.10 <TD ALIGN=left> UNIX File Position And Concurrent Access &nbsp;&nbsp 321 <TR> <TD ALIGN=left> <TD ALIGN=left>23.7.11 <TD ALIGN=left> Semantics Of Write During Concurrent Access &nbsp;&nbsp 322 <TR> <TD ALIGN=left> <TD ALIGN=left>23.7.12 <TD ALIGN=left> UNIX File Names And Paths &nbsp;&nbsp 322 <TR> <TD ALIGN=left> <TD ALIGN=left>23.7.13 <TD ALIGN=left> The UNIX Inode: Information Stored With A File &nbsp;&nbsp 323 <TR> <TD ALIGN=left> <TD ALIGN=left>23.7.14 <TD ALIGN=left> The UNIX Stat Operation &nbsp;&nbsp 324 <TR> <TD ALIGN=left> <TD ALIGN=left>23.7.15 <TD ALIGN=left> The UNIX File Naming Mechanism &nbsp;&nbsp 325 <TR> <TD ALIGN=left> <TD ALIGN=left>23.7.16 <TD ALIGN=left> UNIX File System Mounts &nbsp;&nbsp 326 <TR> <TD ALIGN=left> <TD ALIGN=left>23.7.17 <TD ALIGN=left> UNIX File Name Resolution &nbsp;&nbsp 328 <TR> <TD ALIGN=left> <TD ALIGN=left>23.7.18 <TD ALIGN=left> UNIX Symbolic Links &nbsp;&nbsp 329 <TR> <TD ALIGN=left>23.8 <TD ALIGN=left COLSPAN=2> Files Under NFS &nbsp;&nbsp 329 <TR> <TD ALIGN=left>23.9 <TD ALIGN=left COLSPAN=2> NFS File Types &nbsp;&nbsp 330 <TR> <TD ALIGN=left>23.10 <TD ALIGN=left COLSPAN=2> NFS File Modes &nbsp;&nbsp 330 <TR> <TD ALIGN=left>23.11 <TD ALIGN=left COLSPAN=2> NFS File Attributes &nbsp;&nbsp 331 <TR> <TD ALIGN=left>23.12 <TD ALIGN=left COLSPAN=2> NFS Client And Server &nbsp;&nbsp 332 <TR> <TD ALIGN=left>23.13 <TD ALIGN=left COLSPAN=2> NFS Client Operation &nbsp;&nbsp 333 <TR> <TD ALIGN=left>23.14 <TD ALIGN=left COLSPAN=2> NFS Client And UNIX &nbsp;&nbsp 334 <TR> <TD ALIGN=left>23.15 <TD ALIGN=left COLSPAN=2> NFS Mounts &nbsp;&nbsp 335 <TR> <TD ALIGN=left>23.16 <TD ALIGN=left COLSPAN=2> File Handle &nbsp;&nbsp 336 <TR> <TD ALIGN=left>23.17 <TD ALIGN=left COLSPAN=2> NFS Handles Replace Path Names &nbsp;&nbsp 336 <TR> <TD ALIGN=left>23.18 <TD ALIGN=left COLSPAN=2> An NFS Client Under Windows &nbsp;&nbsp 338 <TR> <TD ALIGN=left>23.19 <TD ALIGN=left COLSPAN=2> File Positioning With A Stateless Server &nbsp;&nbsp 338 <TR> <TD ALIGN=left>23.20 <TD ALIGN=left COLSPAN=2> Operations On Directories &nbsp;&nbsp 339 <TR> <TD ALIGN=left>23.21 <TD ALIGN=left COLSPAN=2> Reading A Directory Statelessly &nbsp;&nbsp 339 <TR> <TD ALIGN=left>23.22 <TD ALIGN=left COLSPAN=2> Multiple Hierarchies In An NFS Server &nbsp;&nbsp 340 <TR> <TD ALIGN=left>23.23 <TD ALIGN=left COLSPAN=2> The Mount Protocol &nbsp;&nbsp 340 <TR> <TD ALIGN=left>23.24 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 341 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 341<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 341<BR> </TABLE> <BR> <BR> <H3>Chapter 24 &nbsp; Network File System Protocol (NFS, Mount) &nbsp;&nbsp; 343</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>24.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 343 <TR> <TD ALIGN=left>24.2 <TD ALIGN=left COLSPAN=2> Using RPC To Define A Protocol &nbsp;&nbsp 343 <TR> <TD ALIGN=left>24.3 <TD ALIGN=left COLSPAN=2> Defining A Protocol With Data Structures And Procedures &nbsp;&nbsp 344 <TR> <TD ALIGN=left>24.4 <TD ALIGN=left COLSPAN=2> NFS Constant, Type, And Data Declarations &nbsp;&nbsp 345 <TR> <TD ALIGN=left> <TD ALIGN=left>24.4.1 <TD ALIGN=left> NFS Constants &nbsp;&nbsp 345 <TR> <TD ALIGN=left> <TD ALIGN=left>24.4.2 <TD ALIGN=left> NFS Typedef Declarations &nbsp;&nbsp 346 <TR> <TD ALIGN=left> <TD ALIGN=left>24.4.3 <TD ALIGN=left> NFS Data Structures &nbsp;&nbsp 346 <TR> <TD ALIGN=left>24.5 <TD ALIGN=left COLSPAN=2> NFS Procedures &nbsp;&nbsp 348 <TR> <TD ALIGN=left>24.6 <TD ALIGN=left COLSPAN=2> Semantics Of NFS Operations &nbsp;&nbsp 349 <TR> <TD ALIGN=left> <TD ALIGN=left>24.6.1 <TD ALIGN=left> NFSPROC_NULL (Procedure 0) &nbsp;&nbsp 350 <TR> <TD ALIGN=left> <TD ALIGN=left>24.6.2 <TD ALIGN=left> NFSPROC_GETATTR (Procedure 1) &nbsp;&nbsp 350 <TR> <TD ALIGN=left> <TD ALIGN=left>24.6.3 <TD ALIGN=left> NFSPROC_SETATTR (Procedure 2) &nbsp;&nbsp 350 <TR> <TD ALIGN=left> <TD ALIGN=left>24.6.4 <TD ALIGN=left> NFSPROC_ROOT (Procedure 3) [Obsolete in NFS3] &nbsp;&nbsp 350 <TR> <TD ALIGN=left> <TD ALIGN=left>24.6.5 <TD ALIGN=left> NFSPROC_LOOKUP (Procedure 4) &nbsp;&nbsp 350 <TR> <TD ALIGN=left> <TD ALIGN=left>24.6.6 <TD ALIGN=left> NFSPROC_READLINK (Procedure 5) &nbsp;&nbsp 350 <TR> <TD ALIGN=left> <TD ALIGN=left>24.6.7 <TD ALIGN=left> NFSPROC_READ (Procedure 6) &nbsp;&nbsp 350 <TR> <TD ALIGN=left> <TD ALIGN=left>24.6.8 <TD ALIGN=left> NFSPROC_WRITECACHE (Procedure 7) [Obsolete in NFS3] &nbsp;&nbsp 350 <TR> <TD ALIGN=left> <TD ALIGN=left>24.6.9 <TD ALIGN=left> NFSPROC_WRITE (Procedure 8) &nbsp;&nbsp 351 <TR> <TD ALIGN=left> <TD ALIGN=left>24.6.10 <TD ALIGN=left> NFSPROC_CREATE (Procedure 9) &nbsp;&nbsp 351 <TR> <TD ALIGN=left> <TD ALIGN=left>24.6.11 <TD ALIGN=left> NFSPROC_REMOVE (Procedure 10) &nbsp;&nbsp 351 <TR> <TD ALIGN=left> <TD ALIGN=left>24.6.12 <TD ALIGN=left> NFSPROC_RENAME (Procedure 11) &nbsp;&nbsp 351 <TR> <TD ALIGN=left> <TD ALIGN=left>24.6.13 <TD ALIGN=left> NFSPROC_LINK (Procedure 12) &nbsp;&nbsp 351 <TR> <TD ALIGN=left> <TD ALIGN=left>24.6.14 <TD ALIGN=left> NFSPROC_SYMLINK (Procedure 13) &nbsp;&nbsp 351 <TR> <TD ALIGN=left> <TD ALIGN=left>24.6.15 <TD ALIGN=left> NFSPROC_MKDIR (Procedure 14) &nbsp;&nbsp 352 <TR> <TD ALIGN=left> <TD ALIGN=left>24.6.16 <TD ALIGN=left> NFSPROC_RMDIR (Procedure 15) &nbsp;&nbsp 352 <TR> <TD ALIGN=left> <TD ALIGN=left>24.6.17 <TD ALIGN=left> NFSPROC_READDIR (Procedure 16) &nbsp;&nbsp 352 <TR> <TD ALIGN=left> <TD ALIGN=left>24.6.18 <TD ALIGN=left> NFSPROC_STATFS (Procedure 17) &nbsp;&nbsp 352 <TR> <TD ALIGN=left>24.7 <TD ALIGN=left COLSPAN=2> The Mount Protocol &nbsp;&nbsp 353 <TR> <TD ALIGN=left> <TD ALIGN=left>24.7.1 <TD ALIGN=left> Mount Constant Definitions &nbsp;&nbsp 353 <TR> <TD ALIGN=left> <TD ALIGN=left>24.7.2 <TD ALIGN=left> Mount Type Definitions &nbsp;&nbsp 353 <TR> <TD ALIGN=left> <TD ALIGN=left>24.7.3 <TD ALIGN=left> Mount Data Structures &nbsp;&nbsp 354 <TR> <TD ALIGN=left>24.8 <TD ALIGN=left COLSPAN=2> Procedures In The Mount Protocol &nbsp;&nbsp 355 <TR> <TD ALIGN=left>24.9 <TD ALIGN=left COLSPAN=2> Semantics of Mount Operations &nbsp;&nbsp 355 <TR> <TD ALIGN=left> <TD ALIGN=left>24.9.1 <TD ALIGN=left> MNTPROC_NULL (Procedure 0) &nbsp;&nbsp 355 <TR> <TD ALIGN=left> <TD ALIGN=left>24.9.2 <TD ALIGN=left> MNTPROC_MNT (Procedure 1) &nbsp;&nbsp 355 <TR> <TD ALIGN=left> <TD ALIGN=left>24.9.3 <TD ALIGN=left> MNTPROC_DUMP (Procedure 2) &nbsp;&nbsp 356 <TR> <TD ALIGN=left> <TD ALIGN=left>24.9.4 <TD ALIGN=left> MNTPROC_UMNT (Procedure 3) &nbsp;&nbsp 356 <TR> <TD ALIGN=left> <TD ALIGN=left>24.9.5 <TD ALIGN=left> MNTPROC_UMNTALL (Procedure 4) &nbsp;&nbsp 356 <TR> <TD ALIGN=left> <TD ALIGN=left>24.9.6 <TD ALIGN=left> MNTPROC_EXPORT (Procedure 5) &nbsp;&nbsp 356 <TR> <TD ALIGN=left>24.10 <TD ALIGN=left COLSPAN=2> NFS And Mount Authentication &nbsp;&nbsp 356 <TR> <TD ALIGN=left>24.11 <TD ALIGN=left COLSPAN=2> Changes In NFS Version 3 &nbsp;&nbsp 358 <TR> <TD ALIGN=left>24.12 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 359 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 359<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 360<BR> </TABLE> <BR> <BR> <H3>Chapter 25 &nbsp; A TELNET Client (Program Structure) &nbsp;&nbsp; 361</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>25.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 361 <TR> <TD ALIGN=left>25.2 <TD ALIGN=left COLSPAN=2> Overview &nbsp;&nbsp 362 <TR> <TD ALIGN=left> <TD ALIGN=left>25.2.1 <TD ALIGN=left> The User's Terminal &nbsp;&nbsp 362 <TR> <TD ALIGN=left> <TD ALIGN=left>25.2.2 <TD ALIGN=left> Command And Control Information &nbsp;&nbsp 362 <TR> <TD ALIGN=left> <TD ALIGN=left>25.2.3 <TD ALIGN=left> Terminals, Windows, and Files &nbsp;&nbsp 362 <TR> <TD ALIGN=left> <TD ALIGN=left>25.2.4 <TD ALIGN=left> The Need For Concurrency &nbsp;&nbsp 363 <TR> <TD ALIGN=left> <TD ALIGN=left>25.2.5 <TD ALIGN=left> A Thread Model For A TELNET Client &nbsp;&nbsp 364 <TR> <TD ALIGN=left>25.3 <TD ALIGN=left COLSPAN=2> A TELNET Client Algorithm &nbsp;&nbsp 364 <TR> <TD ALIGN=left>25.4 <TD ALIGN=left COLSPAN=2> Keyboard I/O In Windows &nbsp;&nbsp 365 <TR> <TD ALIGN=left>25.5 <TD ALIGN=left COLSPAN=2> Global Variables Used For Keyboard Control &nbsp;&nbsp 366 <TR> <TD ALIGN=left>25.6 <TD ALIGN=left COLSPAN=2> Initializing The Keyboard Thread &nbsp;&nbsp 367 <TR> <TD ALIGN=left>25.7 <TD ALIGN=left COLSPAN=2> Finite State Machine Specification &nbsp;&nbsp 370 <TR> <TD ALIGN=left>25.8 <TD ALIGN=left COLSPAN=2> Embedding Commands In A TELNET Data Stream &nbsp;&nbsp 370 <TR> <TD ALIGN=left>25.9 <TD ALIGN=left COLSPAN=2> Option Negotiation &nbsp;&nbsp 371 <TR> <TD ALIGN=left>25.10 <TD ALIGN=left COLSPAN=2> Request/Offer Symmetry &nbsp;&nbsp 372 <TR> <TD ALIGN=left>25.11 <TD ALIGN=left COLSPAN=2> TELNET Character Definitions &nbsp;&nbsp 372 <TR> <TD ALIGN=left>25.12 <TD ALIGN=left COLSPAN=2> A Finite State Machine For Data From The Server &nbsp;&nbsp 373 <TR> <TD ALIGN=left>25.13 <TD ALIGN=left COLSPAN=2> Transitions Among States &nbsp;&nbsp 374 <TR> <TD ALIGN=left>25.14 <TD ALIGN=left COLSPAN=2> A Finite State Machine Implementation &nbsp;&nbsp 376 <TR> <TD ALIGN=left>25.15 <TD ALIGN=left COLSPAN=2> A Compact FSM Representation &nbsp;&nbsp 376 <TR> <TD ALIGN=left>25.16 <TD ALIGN=left COLSPAN=2> Keeping The Compact Representation At Run-Time &nbsp;&nbsp 378 <TR> <TD ALIGN=left>25.17 <TD ALIGN=left COLSPAN=2> Implementation Of A Compact Representation &nbsp;&nbsp 378 <TR> <TD ALIGN=left>25.18 <TD ALIGN=left COLSPAN=2> Building An FSM Transition Matrix &nbsp;&nbsp 380 <TR> <TD ALIGN=left>25.19 <TD ALIGN=left COLSPAN=2> The Socket Output Finite State Machine &nbsp;&nbsp 382 <TR> <TD ALIGN=left>25.20 <TD ALIGN=left COLSPAN=2> Definitions For The Socket Output FSM &nbsp;&nbsp 384 <TR> <TD ALIGN=left>25.21 <TD ALIGN=left COLSPAN=2> The Option Subnegotiation Finite State Machine &nbsp;&nbsp 385 <TR> <TD ALIGN=left>25.22 <TD ALIGN=left COLSPAN=2> Definitions For The Option Subnegotiation FSM &nbsp;&nbsp 386 <TR> <TD ALIGN=left>25.23 <TD ALIGN=left COLSPAN=2> FSM Initialization &nbsp;&nbsp 387 <TR> <TD ALIGN=left>25.24 <TD ALIGN=left COLSPAN=2> Arguments For The TELNET Client &nbsp;&nbsp 387 <TR> <TD ALIGN=left>25.25 <TD ALIGN=left COLSPAN=2> The Heart Of The TELNET Client &nbsp;&nbsp 389 <TR> <TD ALIGN=left>25.26 <TD ALIGN=left COLSPAN=2> TELNET Synchronization &nbsp;&nbsp 391 <TR> <TD ALIGN=left>25.27 <TD ALIGN=left COLSPAN=2> Handling A Severe Error &nbsp;&nbsp 392 <TR> <TD ALIGN=left>25.28 <TD ALIGN=left COLSPAN=2> Implementation Of The Main FSM &nbsp;&nbsp 393 <TR> <TD ALIGN=left>25.29 <TD ALIGN=left COLSPAN=2> A Procedure For Immediate Disconnection &nbsp;&nbsp 394 <TR> <TD ALIGN=left>25.30 <TD ALIGN=left COLSPAN=2> Abort Procedure &nbsp;&nbsp 395 <TR> <TD ALIGN=left>25.31 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 395 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 396<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 396<BR> </TABLE> <BR> <BR> <H3>Chapter 26 &nbsp; A TELNET Client (Implementation Details) &nbsp;&nbsp; 399</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>26.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 399 <TR> <TD ALIGN=left>26.2 <TD ALIGN=left COLSPAN=2> The FSM Action Procedures &nbsp;&nbsp 399 <TR> <TD ALIGN=left>26.3 <TD ALIGN=left COLSPAN=2> Recording The Type Of An Option Request &nbsp;&nbsp 400 <TR> <TD ALIGN=left>26.4 <TD ALIGN=left COLSPAN=2> Performing No Operation &nbsp;&nbsp 401 <TR> <TD ALIGN=left>26.5 <TD ALIGN=left COLSPAN=2> Responding To WILL/WONT For The Echo Option &nbsp;&nbsp 401 <TR> <TD ALIGN=left>26.6 <TD ALIGN=left COLSPAN=2> Sending A Response &nbsp;&nbsp 402 <TR> <TD ALIGN=left>26.7 <TD ALIGN=left COLSPAN=2> Responding To WILL/WONT For Unsupported Options &nbsp;&nbsp 403 <TR> <TD ALIGN=left>26.8 <TD ALIGN=left COLSPAN=2> Responding To WILL/WONT For The No Go-Ahead Option &nbsp;&nbsp 404 <TR> <TD ALIGN=left>26.9 <TD ALIGN=left COLSPAN=2> Generating DO/DONT For Binary Transmission &nbsp;&nbsp 405 <TR> <TD ALIGN=left>26.10 <TD ALIGN=left COLSPAN=2> Responding To DO/DONT For Unsupported Options &nbsp;&nbsp 406 <TR> <TD ALIGN=left>26.11 <TD ALIGN=left COLSPAN=2> Responding To DO/DONT For Transmit Binary Option &nbsp;&nbsp 406 <TR> <TD ALIGN=left>26.12 <TD ALIGN=left COLSPAN=2> Responding To DO/DONT For The Terminal Type Option &nbsp;&nbsp 408 <TR> <TD ALIGN=left>26.13 <TD ALIGN=left COLSPAN=2> Option Subnegotiation &nbsp;&nbsp 409 <TR> <TD ALIGN=left>26.14 <TD ALIGN=left COLSPAN=2> Sending Terminal Type Information &nbsp;&nbsp 410 <TR> <TD ALIGN=left>26.15 <TD ALIGN=left COLSPAN=2> Terminating Subnegotiation &nbsp;&nbsp 412 <TR> <TD ALIGN=left>26.16 <TD ALIGN=left COLSPAN=2> Sending A Character To The Server &nbsp;&nbsp 412 <TR> <TD ALIGN=left>26.17 <TD ALIGN=left COLSPAN=2> Displaying Incoming Data On The User's Terminal &nbsp;&nbsp 414 <TR> <TD ALIGN=left>26.18 <TD ALIGN=left COLSPAN=2> Writing A Block Of Data To The Server &nbsp;&nbsp 417 <TR> <TD ALIGN=left>26.19 <TD ALIGN=left COLSPAN=2> Interacting With The Local Client &nbsp;&nbsp 418 <TR> <TD ALIGN=left>26.20 <TD ALIGN=left COLSPAN=2> Responding To Illegal Commands &nbsp;&nbsp 419 <TR> <TD ALIGN=left>26.21 <TD ALIGN=left COLSPAN=2> Scripting To A File &nbsp;&nbsp 419 <TR> <TD ALIGN=left>26.22 <TD ALIGN=left COLSPAN=2> Implementation Of Scripting &nbsp;&nbsp 420 <TR> <TD ALIGN=left>26.23 <TD ALIGN=left COLSPAN=2> Initialization Of Scripting &nbsp;&nbsp 420 <TR> <TD ALIGN=left>26.24 <TD ALIGN=left COLSPAN=2> Collecting Characters Of The Script File Name &nbsp;&nbsp 421 <TR> <TD ALIGN=left>26.25 <TD ALIGN=left COLSPAN=2> Opening A Script File &nbsp;&nbsp 422 <TR> <TD ALIGN=left>26.26 <TD ALIGN=left COLSPAN=2> Terminating Scripting &nbsp;&nbsp 424 <TR> <TD ALIGN=left>26.27 <TD ALIGN=left COLSPAN=2> Printing Status Information &nbsp;&nbsp 425 <TR> <TD ALIGN=left>26.28 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 426 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 427<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 427<BR> </TABLE> <BR> <BR> <H3>Chapter 27 &nbsp; Porting Servers From UNIX To Windows &nbsp;&nbsp; 429</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>27.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 429 <TR> <TD ALIGN=left>27.2 <TD ALIGN=left COLSPAN=2> Operating In Background &nbsp;&nbsp 429 <TR> <TD ALIGN=left>27.3 <TD ALIGN=left COLSPAN=2> Shared Descriptors And Inheritance &nbsp;&nbsp 431 <TR> <TD ALIGN=left>27.4 <TD ALIGN=left COLSPAN=2> The Controlling TTY &nbsp;&nbsp 431 <TR> <TD ALIGN=left>27.5 <TD ALIGN=left COLSPAN=2> Working Directories &nbsp;&nbsp 432 <TR> <TD ALIGN=left>27.6 <TD ALIGN=left COLSPAN=2> File Creation And Umask &nbsp;&nbsp 432 <TR> <TD ALIGN=left>27.7 <TD ALIGN=left COLSPAN=2> Process Groups &nbsp;&nbsp 433 <TR> <TD ALIGN=left>27.8 <TD ALIGN=left COLSPAN=2> Descriptors For Standard I/O &nbsp;&nbsp 433 <TR> <TD ALIGN=left>27.9 <TD ALIGN=left COLSPAN=2> Mutual Exclusion For A Server &nbsp;&nbsp 434 <TR> <TD ALIGN=left>27.10 <TD ALIGN=left COLSPAN=2> Recording A Process ID &nbsp;&nbsp 434 <TR> <TD ALIGN=left>27.11 <TD ALIGN=left COLSPAN=2> Waiting For A Child Process To Exit &nbsp;&nbsp 435 <TR> <TD ALIGN=left>27.12 <TD ALIGN=left COLSPAN=2> Using A System Log Facility &nbsp;&nbsp 435 <TR> <TD ALIGN=left> <TD ALIGN=left>27.12.1 <TD ALIGN=left> Generating Log Messages &nbsp;&nbsp 435 <TR> <TD ALIGN=left>27.13 <TD ALIGN=left COLSPAN=2> Miscellaneous Incompatibilities &nbsp;&nbsp 437 <TR> <TD ALIGN=left>27.14 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 438 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 438<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 439<BR> </TABLE> <BR> <BR> <H3>Chapter 28 &nbsp; Deadlock And Starvation In Client-Server Systems &nbsp;&nbsp; 441</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>28.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 441 <TR> <TD ALIGN=left>28.2 <TD ALIGN=left COLSPAN=2> Definition Of Deadlock &nbsp;&nbsp 442 <TR> <TD ALIGN=left>28.3 <TD ALIGN=left COLSPAN=2> Difficulty Of Deadlock Detection &nbsp;&nbsp 442 <TR> <TD ALIGN=left>28.4 <TD ALIGN=left COLSPAN=2> Deadlock Avoidance &nbsp;&nbsp 443 <TR> <TD ALIGN=left>28.5 <TD ALIGN=left COLSPAN=2> Deadlock Between A Client And Server &nbsp;&nbsp 443 <TR> <TD ALIGN=left>28.6 <TD ALIGN=left COLSPAN=2> Avoiding Deadlock In A Single Interaction &nbsp;&nbsp 444 <TR> <TD ALIGN=left>28.7 <TD ALIGN=left COLSPAN=2> Starvation Among A Set Of Clients And A Server &nbsp;&nbsp 444 <TR> <TD ALIGN=left>28.8 <TD ALIGN=left COLSPAN=2> Busy Connections And Starvation &nbsp;&nbsp 445 <TR> <TD ALIGN=left>28.9 <TD ALIGN=left COLSPAN=2> Avoiding Blocking Operations &nbsp;&nbsp 446 <TR> <TD ALIGN=left>28.10 <TD ALIGN=left COLSPAN=2> Threads, Connections, And Other Limits &nbsp;&nbsp 446 <TR> <TD ALIGN=left>28.11 <TD ALIGN=left COLSPAN=2> Cycles Of Clients And Servers &nbsp;&nbsp 447 <TR> <TD ALIGN=left>28.12 <TD ALIGN=left COLSPAN=2> Documenting Dependencies &nbsp;&nbsp 447 <TR> <TD ALIGN=left>28.13 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 448 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 449<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 449<BR> </TABLE> <BR> <BR><H3> Appendix 1 &nbsp; Functions And Library Routines Used With Sockets &nbsp;&nbsp; 451</H3> <BR><H3> Appendix 2 &nbsp; Manipulation Of Windows Socket Descriptors &nbsp;&nbsp; 485</H3> <BR><H3> Bibliography &nbsp;&nbsp;489</H3> <BR><H3> Index &nbsp;&nbsp;499</H3> </UL></UL> </BODY> </BODY>
</DOC>
