<DOC>
<DOCNO> http://www.cs.purdue.edu/homes/dec/xinu1.cont.html </DOCNO>
<html><head> <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"> <title> xinu-book-linksys-version </title> </head> <body> <center> <h2> Table of Contents For <br><br> Operating Systems Design: The Xinu Approach (Linksys Version)<br><br> </h2> </center> <ul><ul> <br><h3> Preface &nbsp;&nbsp;xix</h3> <br><h3> About The Author &nbsp;&nbsp;xxiii</h3> <br> <h3>Chapter 1 &nbsp; Introduction and Overview &nbsp;&nbsp; 1</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">1.1 </td><td colspan="2" align="left"> Operating Systems &nbsp;&nbsp; 1 </td></tr><tr> <td align="left">1.2 </td><td colspan="2" align="left"> Approach Used In The Text &nbsp;&nbsp; 3 </td></tr><tr> <td align="left">1.3 </td><td colspan="2" align="left"> A Hierarchical Design &nbsp;&nbsp; 3 </td></tr><tr> <td align="left">1.4 </td><td colspan="2" align="left"> The Xinu Operating System &nbsp;&nbsp; 5 </td></tr><tr> <td align="left">1.5 </td><td colspan="2" align="left"> What An Operating System Is Not &nbsp;&nbsp; 6 </td></tr><tr> <td align="left">1.6 </td><td colspan="2" align="left"> An Operating System Viewed From The Outside &nbsp;&nbsp; 7 </td></tr><tr> <td align="left">1.7 </td><td colspan="2" align="left"> Remainder Of The Text &nbsp;&nbsp; 8 </td></tr><tr> <td align="left">1.8 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 8 </td></tr><tr> <td align="left">1.9 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 9 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 9<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 2 &nbsp; Concurrent Execution And Operating System Services &nbsp;&nbsp; 11</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">2.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 11 </td></tr><tr> <td align="left">2.2 </td><td colspan="2" align="left"> Programming Models For Multiple Activities &nbsp;&nbsp; 12 </td></tr><tr> <td align="left">2.3 </td><td colspan="2" align="left"> Operating System Services &nbsp;&nbsp; 13 </td></tr><tr> <td align="left">2.4 </td><td colspan="2" align="left"> Concurrent Processing Concepts And Terminology &nbsp;&nbsp; 13 </td></tr><tr> <td align="left">2.5 </td><td colspan="2" align="left"> Distinction Between Sequential And Concurrent Programs &nbsp;&nbsp; 15 </td></tr><tr> <td align="left">2.6 </td><td colspan="2" align="left"> Multiple Processes Sharing A Single Piece Of Code &nbsp;&nbsp; 17 </td></tr><tr> <td align="left">2.7 </td><td colspan="2" align="left"> Process Exit And Process Termination &nbsp;&nbsp; 19 </td></tr><tr> <td align="left">2.8 </td><td colspan="2" align="left"> Shared Memory, Race Conditions, And Synchronization &nbsp;&nbsp; 20 </td></tr><tr> <td align="left">2.9 </td><td colspan="2" align="left"> Semaphores And Mutual Exclusion &nbsp;&nbsp; 24 </td></tr><tr> <td align="left">2.10 </td><td colspan="2" align="left"> Type Names Used In Xinu &nbsp;&nbsp; 26 </td></tr><tr> <td align="left">2.11 </td><td colspan="2" align="left"> Operating System Debugging With Kputc And Kprintf &nbsp;&nbsp; 27 </td></tr><tr> <td align="left">2.12 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 28 </td></tr><tr> <td align="left">2.13 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 28 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 29<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 3 &nbsp; An Overview Of The Hardware and Run-Time Environment &nbsp;&nbsp; 31</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">3.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 31 </td></tr><tr> <td align="left">3.2 </td><td colspan="2" align="left"> Physical And Logical Organizations Of The E2100L &nbsp;&nbsp; 32 </td></tr><tr> <td align="left">3.3 </td><td colspan="2" align="left"> Processor Organization And Registers &nbsp;&nbsp; 33 </td></tr><tr> <td align="left">3.4 </td><td colspan="2" align="left"> Bus Operation: The Fetch-Store Paradigm &nbsp;&nbsp; 34 </td></tr><tr> <td align="left">3.5 </td><td colspan="2" align="left"> Direct Memory Access &nbsp;&nbsp; 34 </td></tr><tr> <td align="left">3.6 </td><td colspan="2" align="left"> The Bus Address Space &nbsp;&nbsp; 35 </td></tr><tr> <td align="left">3.7 </td><td colspan="2" align="left"> Contents Of Kernel Segments KSEG0 and KSEG1 &nbsp;&nbsp; 36 </td></tr><tr> <td align="left">3.8 </td><td colspan="2" align="left"> Bus Startup Static Configuration &nbsp;&nbsp; 37 </td></tr><tr> <td align="left">3.9 </td><td colspan="2" align="left"> Calling Conventions And The Run-Time Stack &nbsp;&nbsp; 38 </td></tr><tr> <td align="left">3.10 </td><td colspan="2" align="left"> Interrupts And Interrupt Processing &nbsp;&nbsp; 40 </td></tr><tr> <td align="left">3.11 </td><td colspan="2" align="left"> Exception Processing &nbsp;&nbsp; 41 </td></tr><tr> <td align="left">3.12 </td><td colspan="2" align="left"> Timer Hardware &nbsp;&nbsp; 42 </td></tr><tr> <td align="left">3.13 </td><td colspan="2" align="left"> Serial Communication &nbsp;&nbsp; 42 </td></tr><tr> <td align="left">3.14 </td><td colspan="2" align="left"> Polled vs. Interrupt-Driven I/O &nbsp;&nbsp; 43 </td></tr><tr> <td align="left">3.15 </td><td colspan="2" align="left"> Memory Cache And KSEG1 &nbsp;&nbsp; 43 </td></tr><tr> <td align="left">3.16 </td><td colspan="2" align="left"> Storage Layout &nbsp;&nbsp; 44 </td></tr><tr> <td align="left">3.17 </td><td colspan="2" align="left"> Memory Protection &nbsp;&nbsp; 45 </td></tr><tr> <td align="left">3.18 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 45 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 45<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 4 &nbsp; List and Queue Manipulation &nbsp;&nbsp; 49</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">4.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 49 </td></tr><tr> <td align="left">4.2 </td><td colspan="2" align="left"> A Unified Structure For Linked Lists Of Processes &nbsp;&nbsp; 50 </td></tr><tr> <td align="left">4.3 </td><td colspan="2" align="left"> A Compact List Data Structure &nbsp;&nbsp; 51 </td></tr><tr> <td align="left">4.4 </td><td colspan="2" align="left"> Implementation Of The Queue Data Structure &nbsp;&nbsp; 53 </td></tr><tr> <td align="left">4.5 </td><td colspan="2" align="left"> Inline Queue Manipulation Functions &nbsp;&nbsp; 55 </td></tr><tr> <td align="left">4.6 </td><td colspan="2" align="left"> Basic Functions To Extract A Process From A List &nbsp;&nbsp; 55 </td></tr><tr> <td align="left">4.7 </td><td colspan="2" align="left"> FIFO Queue Manipulation &nbsp;&nbsp; 57 </td></tr><tr> <td align="left">4.8 </td><td colspan="2" align="left"> Manipulation Of Priority Queues &nbsp;&nbsp; 60 </td></tr><tr> <td align="left">4.9 </td><td colspan="2" align="left"> List Initialization &nbsp;&nbsp; 62 </td></tr><tr> <td align="left">4.10 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 63 </td></tr><tr> <td align="left">4.11 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 64 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 64<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 5 &nbsp; Scheduling and Context Switching &nbsp;&nbsp; 67</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">5.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 67 </td></tr><tr> <td align="left">5.2 </td><td colspan="2" align="left"> The Process Table &nbsp;&nbsp; 68 </td></tr><tr> <td align="left">5.3 </td><td colspan="2" align="left"> Process States &nbsp;&nbsp; 71 </td></tr><tr> <td align="left">5.4 </td><td colspan="2" align="left"> Ready And Current States &nbsp;&nbsp; 72 </td></tr><tr> <td align="left">5.5 </td><td colspan="2" align="left"> A Scheduling Policy &nbsp;&nbsp; 72 </td></tr><tr> <td align="left">5.6 </td><td colspan="2" align="left"> Implementation Of Scheduling &nbsp;&nbsp; 73 </td></tr><tr> <td align="left">5.7 </td><td colspan="2" align="left"> Implementation Of Context Switching &nbsp;&nbsp; 76 </td></tr><tr> <td align="left">5.8 </td><td colspan="2" align="left"> State Saved In Memory &nbsp;&nbsp; 76 </td></tr><tr> <td align="left">5.9 </td><td colspan="2" align="left"> Context Switch On A MIPS Processor &nbsp;&nbsp; 77 </td></tr><tr> <td align="left">5.10 </td><td colspan="2" align="left"> An Address At Which To Restart A Process &nbsp;&nbsp; 80 </td></tr><tr> <td align="left">5.11 </td><td colspan="2" align="left"> Concurrent Execution And A Null Process &nbsp;&nbsp; 81 </td></tr><tr> <td align="left">5.12 </td><td colspan="2" align="left"> Making A Process Ready And The Scheduling Invariant &nbsp;&nbsp; 82 </td></tr><tr> <td align="left">5.13 </td><td colspan="2" align="left"> Deferred Rescheduling &nbsp;&nbsp; 83 </td></tr><tr> <td align="left">5.14 </td><td colspan="2" align="left"> Other Process Scheduling Algorithms &nbsp;&nbsp; 85 </td></tr><tr> <td align="left">5.15 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 86 </td></tr><tr> <td align="left">5.16 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 86 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 87<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 6 &nbsp; More Process Management &nbsp;&nbsp; 89</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">6.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 89 </td></tr><tr> <td align="left">6.2 </td><td colspan="2" align="left"> Process Suspension And Resumption &nbsp;&nbsp; 89 </td></tr><tr> <td align="left">6.3 </td><td colspan="2" align="left"> Self-Suspension And Information Hiding &nbsp;&nbsp; 90 </td></tr><tr> <td align="left">6.4 </td><td colspan="2" align="left"> The Concept Of A System Call &nbsp;&nbsp; 91 </td></tr><tr> <td align="left">6.5 </td><td colspan="2" align="left"> Interrupt Control With Disable And Restore &nbsp;&nbsp; 93 </td></tr><tr> <td align="left">6.6 </td><td colspan="2" align="left"> A System Call Template &nbsp;&nbsp; 94 </td></tr><tr> <td align="left">6.7 </td><td colspan="2" align="left"> System Call Return Values SYSERR And OK &nbsp;&nbsp; 95 </td></tr><tr> <td align="left">6.8 </td><td colspan="2" align="left"> Implementation Of Suspend &nbsp;&nbsp; 95 </td></tr><tr> <td align="left">6.9 </td><td colspan="2" align="left"> Suspending The Current Process &nbsp;&nbsp; 97 </td></tr><tr> <td align="left">6.10 </td><td colspan="2" align="left"> Suspend Return Value &nbsp;&nbsp; 97 </td></tr><tr> <td align="left">6.11 </td><td colspan="2" align="left"> Process Termination And Process Exit &nbsp;&nbsp; 98 </td></tr><tr> <td align="left">6.12 </td><td colspan="2" align="left"> Process Creation &nbsp;&nbsp; 101 </td></tr><tr> <td align="left">6.13 </td><td colspan="2" align="left"> Other Process Manager Functions &nbsp;&nbsp; 106 </td></tr><tr> <td align="left">6.14 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 108 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 108<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 7 &nbsp; Coordination Of Concurrent Processes &nbsp;&nbsp; 111</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">7.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 111 </td></tr><tr> <td align="left">7.2 </td><td colspan="2" align="left"> The Need For Synchronization &nbsp;&nbsp; 111 </td></tr><tr> <td align="left">7.3 </td><td colspan="2" align="left"> A Conceptual View Of Counting Semaphores &nbsp;&nbsp; 113 </td></tr><tr> <td align="left">7.4 </td><td colspan="2" align="left"> Avoidance Of Busy Waiting &nbsp;&nbsp; 113 </td></tr><tr> <td align="left">7.5 </td><td colspan="2" align="left"> Semaphore Policy And Process Selection &nbsp;&nbsp; 114 </td></tr><tr> <td align="left">7.6 </td><td colspan="2" align="left"> The Waiting State &nbsp;&nbsp; 115 </td></tr><tr> <td align="left">7.7 </td><td colspan="2" align="left"> Semaphore Data Structures &nbsp;&nbsp; 116 </td></tr><tr> <td align="left">7.8 </td><td colspan="2" align="left"> The Wait System Call &nbsp;&nbsp; 117 </td></tr><tr> <td align="left">7.9 </td><td colspan="2" align="left"> The Signal System Call &nbsp;&nbsp; 118 </td></tr><tr> <td align="left">7.10 </td><td colspan="2" align="left"> Static And Dynamic Semaphore Allocation &nbsp;&nbsp; 119 </td></tr><tr> <td align="left">7.11 </td><td colspan="2" align="left"> Example Implementation Of Dynamic Semaphores &nbsp;&nbsp; 120 </td></tr><tr> <td align="left">7.12 </td><td colspan="2" align="left"> Semaphore Deletion &nbsp;&nbsp; 121 </td></tr><tr> <td align="left">7.13 </td><td colspan="2" align="left"> Semaphore Reset &nbsp;&nbsp; 123 </td></tr><tr> <td align="left">7.14 </td><td colspan="2" align="left"> Coordination Across Parallel Processors (Multicore) &nbsp;&nbsp; 124 </td></tr><tr> <td align="left">7.15 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 125 </td></tr><tr> <td align="left">7.16 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 125 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 126<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 8 &nbsp; Message Passing &nbsp;&nbsp; 129</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">8.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 129 </td></tr><tr> <td align="left">8.2 </td><td colspan="2" align="left"> Two Types Of Message Passing Services &nbsp;&nbsp; 129 </td></tr><tr> <td align="left">8.3 </td><td colspan="2" align="left"> Limits On Resources Used By Messages &nbsp;&nbsp; 130 </td></tr><tr> <td align="left">8.4 </td><td colspan="2" align="left"> Message Passing Functions And State Transitions &nbsp;&nbsp; 131 </td></tr><tr> <td align="left">8.5 </td><td colspan="2" align="left"> Implementation Of Send &nbsp;&nbsp; 132 </td></tr><tr> <td align="left">8.6 </td><td colspan="2" align="left"> Implementation Of Receive &nbsp;&nbsp; 134 </td></tr><tr> <td align="left">8.7 </td><td colspan="2" align="left"> Implementation Of Non-Blocking Message Reception &nbsp;&nbsp; 135 </td></tr><tr> <td align="left">8.8 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 135 </td></tr><tr> <td align="left">8.9 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 136 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 136<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 9 &nbsp; Basic Memory Management &nbsp;&nbsp; 139</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">9.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 139 </td></tr><tr> <td align="left">9.2 </td><td colspan="2" align="left"> Types Of Memory &nbsp;&nbsp; 139 </td></tr><tr> <td align="left">9.3 </td><td colspan="2" align="left"> Definition Of A Heavyweight Process &nbsp;&nbsp; 140 </td></tr><tr> <td align="left">9.4 </td><td colspan="2" align="left"> Memory Management In A Small Embedded System &nbsp;&nbsp; 141 </td></tr><tr> <td align="left">9.5 </td><td colspan="2" align="left"> Program Segments And Regions Of Memory &nbsp;&nbsp; 142 </td></tr><tr> <td align="left">9.6 </td><td colspan="2" align="left"> Dynamic Memory Allocation In An Embedded System &nbsp;&nbsp; 143 </td></tr><tr> <td align="left">9.7 </td><td colspan="2" align="left"> Design Of The Low-Level Memory Manager &nbsp;&nbsp; 144 </td></tr><tr> <td align="left">9.8 </td><td colspan="2" align="left"> Allocation Strategy And Memory Persistence &nbsp;&nbsp; 144 </td></tr><tr> <td align="left">9.9 </td><td colspan="2" align="left"> Keeping Track Of Free Memory &nbsp;&nbsp; 145 </td></tr><tr> <td align="left">9.10 </td><td colspan="2" align="left"> Implementation Of Low-Level Memory Management &nbsp;&nbsp; 146 </td></tr><tr> <td align="left">9.11 </td><td colspan="2" align="left"> Allocating Heap Storage &nbsp;&nbsp; 148 </td></tr><tr> <td align="left">9.12 </td><td colspan="2" align="left"> Allocating Stack Storage &nbsp;&nbsp; 151 </td></tr><tr> <td align="left">9.13 </td><td colspan="2" align="left"> Releasing Heap And Stack Storage &nbsp;&nbsp; 153 </td></tr><tr> <td align="left">9.14 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 156 </td></tr><tr> <td align="left">9.15 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 156 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 157<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 10 &nbsp; High-Level Memory Management and Virtual Memory &nbsp;&nbsp; 159</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">10.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 159 </td></tr><tr> <td align="left">10.2 </td><td colspan="2" align="left"> Partitioned Space Allocation &nbsp;&nbsp; 160 </td></tr><tr> <td align="left">10.3 </td><td colspan="2" align="left"> Buffer Pools &nbsp;&nbsp; 160 </td></tr><tr> <td align="left">10.4 </td><td colspan="2" align="left"> Allocating A Buffer &nbsp;&nbsp; 162 </td></tr><tr> <td align="left">10.5 </td><td colspan="2" align="left"> Returning Buffers To The Buffer Pool &nbsp;&nbsp; 164 </td></tr><tr> <td align="left">10.6 </td><td colspan="2" align="left"> Creating A Buffer Pool &nbsp;&nbsp; 165 </td></tr><tr> <td align="left">10.7 </td><td colspan="2" align="left"> Initializing The Buffer Pool Table &nbsp;&nbsp; 167 </td></tr><tr> <td align="left">10.8 </td><td colspan="2" align="left"> Virtual Memory And Memory Multiplexing &nbsp;&nbsp; 168 </td></tr><tr> <td align="left">10.9 </td><td colspan="2" align="left"> Real And Virtual Address Spaces &nbsp;&nbsp; 169 </td></tr><tr> <td align="left">10.10 </td><td colspan="2" align="left"> Hardware For Demand Paging &nbsp;&nbsp; 171 </td></tr><tr> <td align="left">10.11 </td><td colspan="2" align="left"> Address Translation With A Page Table &nbsp;&nbsp; 171 </td></tr><tr> <td align="left">10.12 </td><td colspan="2" align="left"> Metadata In A Page Table Entry &nbsp;&nbsp; 173 </td></tr><tr> <td align="left">10.13 </td><td colspan="2" align="left"> Demand Paging And Design Questions &nbsp;&nbsp; 173 </td></tr><tr> <td align="left">10.14 </td><td colspan="2" align="left"> Page Replacement And Global Clock &nbsp;&nbsp; 174 </td></tr><tr> <td align="left">10.15 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 175 </td></tr><tr> <td align="left">10.16 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 175 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 176<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 11 &nbsp; High-Level Message Passing &nbsp;&nbsp; 179</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">11.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 179 </td></tr><tr> <td align="left">11.2 </td><td colspan="2" align="left"> Inter-Process Communication Ports &nbsp;&nbsp; 179 </td></tr><tr> <td align="left">11.3 </td><td colspan="2" align="left"> The Implementation Of Ports &nbsp;&nbsp; 180 </td></tr><tr> <td align="left">11.4 </td><td colspan="2" align="left"> Port Table Initialization &nbsp;&nbsp; 181 </td></tr><tr> <td align="left">11.5 </td><td colspan="2" align="left"> Port Creation &nbsp;&nbsp; 183 </td></tr><tr> <td align="left">11.6 </td><td colspan="2" align="left"> Sending A Message To A Port &nbsp;&nbsp; 184 </td></tr><tr> <td align="left">11.7 </td><td colspan="2" align="left"> Receiving A Message From A Port &nbsp;&nbsp; 186 </td></tr><tr> <td align="left">11.8 </td><td colspan="2" align="left"> Port Deletion And Reset &nbsp;&nbsp; 188 </td></tr><tr> <td align="left">11.9 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 191 </td></tr><tr> <td align="left">11.10 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 191 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 191<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 12 &nbsp; Interrupt Processing &nbsp;&nbsp; 195</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">12.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 195 </td></tr><tr> <td align="left">12.2 </td><td colspan="2" align="left"> The Advantage Of Interrupts &nbsp;&nbsp; 196 </td></tr><tr> <td align="left">12.3 </td><td colspan="2" align="left"> Interrupt Dispatching &nbsp;&nbsp; 196 </td></tr><tr> <td align="left">12.4 </td><td colspan="2" align="left"> Vectored Interrupts &nbsp;&nbsp; 197 </td></tr><tr> <td align="left">12.5 </td><td colspan="2" align="left"> Assignment Of Interrupt Vector Numbers &nbsp;&nbsp; 197 </td></tr><tr> <td align="left">12.6 </td><td colspan="2" align="left"> Interrupt Hardware &nbsp;&nbsp; 198 </td></tr><tr> <td align="left">12.7 </td><td colspan="2" align="left"> IRQ Limits And Interrupt Multiplexing &nbsp;&nbsp; 199 </td></tr><tr> <td align="left">12.8 </td><td colspan="2" align="left"> Interrupt Software And Dispatching &nbsp;&nbsp; 199 </td></tr><tr> <td align="left">12.9 </td><td colspan="2" align="left"> The Lowest Level Of The Interrupt Dispatcher &nbsp;&nbsp; 202 </td></tr><tr> <td align="left">12.10 </td><td colspan="2" align="left"> The High-Level Interrupt Dispatcher &nbsp;&nbsp; 204 </td></tr><tr> <td align="left">12.11 </td><td colspan="2" align="left"> Disabling Interrupts &nbsp;&nbsp; 208 </td></tr><tr> <td align="left">12.12 </td><td colspan="2" align="left"> Constraints On Functions That Interrupt Code Invokes &nbsp;&nbsp; 208 </td></tr><tr> <td align="left">12.13 </td><td colspan="2" align="left"> The Need To Reschedule During An Interrupt &nbsp;&nbsp; 209 </td></tr><tr> <td align="left">12.14 </td><td colspan="2" align="left"> Rescheduling During An Interrupt &nbsp;&nbsp; 210 </td></tr><tr> <td align="left">12.15 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 211 </td></tr><tr> <td align="left">12.16 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 211 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 212<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 13 &nbsp; Real-Time Clock Management &nbsp;&nbsp; 215</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">13.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 215 </td></tr><tr> <td align="left">13.2 </td><td colspan="2" align="left"> Timed Events &nbsp;&nbsp; 216 </td></tr><tr> <td align="left">13.3 </td><td colspan="2" align="left"> Real-Time Clocks And Timer Hardware &nbsp;&nbsp; 216 </td></tr><tr> <td align="left">13.4 </td><td colspan="2" align="left"> Handling Real-Time Clock Interrupts &nbsp;&nbsp; 217 </td></tr><tr> <td align="left">13.5 </td><td colspan="2" align="left"> Delay And Preemption &nbsp;&nbsp; 218 </td></tr><tr> <td align="left">13.6 </td><td colspan="2" align="left"> Emulating A Real-Time Clock With A Timer &nbsp;&nbsp; 219 </td></tr><tr> <td align="left">13.7 </td><td colspan="2" align="left"> Implementation Of Preemption &nbsp;&nbsp; 219 </td></tr><tr> <td align="left">13.8 </td><td colspan="2" align="left"> Efficient Management Of Delay With A Delta List &nbsp;&nbsp; 220 </td></tr><tr> <td align="left">13.9 </td><td colspan="2" align="left"> Delta List Implementation &nbsp;&nbsp; 221 </td></tr><tr> <td align="left">13.10 </td><td colspan="2" align="left"> Putting A Process To Sleep &nbsp;&nbsp; 223 </td></tr><tr> <td align="left">13.11 </td><td colspan="2" align="left"> Timed Message Reception &nbsp;&nbsp; 226 </td></tr><tr> <td align="left">13.12 </td><td colspan="2" align="left"> Awakening Sleeping Processes &nbsp;&nbsp; 230 </td></tr><tr> <td align="left">13.13 </td><td colspan="2" align="left"> Clock Interrupt Processing &nbsp;&nbsp; 231 </td></tr><tr> <td align="left">13.14 </td><td colspan="2" align="left"> Clock Initialization &nbsp;&nbsp; 232 </td></tr><tr> <td align="left">13.15 </td><td colspan="2" align="left"> Interval Timer Management &nbsp;&nbsp; 233 </td></tr><tr> <td align="left">13.16 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 235 </td></tr><tr> <td align="left">13.17 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 235 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 235<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 14 &nbsp; Device-Independent Input and Output &nbsp;&nbsp; 239</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">14.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 239 </td></tr><tr> <td align="left">14.2 </td><td colspan="2" align="left"> Conceptual Organization Of I/O And Device Drivers &nbsp;&nbsp; 240 </td></tr><tr> <td align="left">14.3 </td><td colspan="2" align="left"> Interface And Driver Abstractions &nbsp;&nbsp; 241 </td></tr><tr> <td align="left">14.4 </td><td colspan="2" align="left"> An Example I/O Interface &nbsp;&nbsp; 242 </td></tr><tr> <td align="left">14.5 </td><td colspan="2" align="left"> The Open-Read-Write-Close Paradigm &nbsp;&nbsp; 243 </td></tr><tr> <td align="left">14.6 </td><td colspan="2" align="left"> Bindings For I/O Operations And Device Names &nbsp;&nbsp; 244 </td></tr><tr> <td align="left">14.7 </td><td colspan="2" align="left"> Device Names In Xinu &nbsp;&nbsp; 245 </td></tr><tr> <td align="left">14.8 </td><td colspan="2" align="left"> The Concept Of A Device Switch Table &nbsp;&nbsp; 245 </td></tr><tr> <td align="left">14.9 </td><td colspan="2" align="left"> Multiple Copies Of A Device And Shared Drivers &nbsp;&nbsp; 246 </td></tr><tr> <td align="left">14.10 </td><td colspan="2" align="left"> The Implementation Of High-Level I/O Operations &nbsp;&nbsp; 249 </td></tr><tr> <td align="left">14.11 </td><td colspan="2" align="left"> Other High-Level I/O Functions &nbsp;&nbsp; 251 </td></tr><tr> <td align="left">14.12 </td><td colspan="2" align="left"> Open, Close, And Reference Counting &nbsp;&nbsp; 255 </td></tr><tr> <td align="left">14.13 </td><td colspan="2" align="left"> Null And Error Entries In Devtab &nbsp;&nbsp; 257 </td></tr><tr> <td align="left">14.14 </td><td colspan="2" align="left"> Initialization Of The I/O System &nbsp;&nbsp; 258 </td></tr><tr> <td align="left">14.15 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 262 </td></tr><tr> <td align="left">14.16 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 263 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 263<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 15 &nbsp; An Example Device Driver &nbsp;&nbsp; 267</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">15.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 267 </td></tr><tr> <td align="left">15.2 </td><td colspan="2" align="left"> The Tty Abstraction &nbsp;&nbsp; 267 </td></tr><tr> <td align="left">15.3 </td><td colspan="2" align="left"> Organization Of A Tty Device Driver &nbsp;&nbsp; 269 </td></tr><tr> <td align="left">15.4 </td><td colspan="2" align="left"> Request Queues And Buffers &nbsp;&nbsp; 270 </td></tr><tr> <td align="left">15.5 </td><td colspan="2" align="left"> Synchronization Of Upper Half And Lower Half &nbsp;&nbsp; 271 </td></tr><tr> <td align="left">15.6 </td><td colspan="2" align="left"> Hardware Buffers And Driver Design &nbsp;&nbsp; 272 </td></tr><tr> <td align="left">15.7 </td><td colspan="2" align="left"> Tty Control Block And Data Declarations &nbsp;&nbsp; 273 </td></tr><tr> <td align="left">15.8 </td><td colspan="2" align="left"> Minor Device Numbers &nbsp;&nbsp; 276 </td></tr><tr> <td align="left">15.9 </td><td colspan="2" align="left"> Upper-Half Tty Character Input (ttyGetc) &nbsp;&nbsp; 277 </td></tr><tr> <td align="left">15.10 </td><td colspan="2" align="left"> Generalized Upper-Half Tty Input (ttyRead) &nbsp;&nbsp; 278 </td></tr><tr> <td align="left">15.11 </td><td colspan="2" align="left"> Upper-Half Tty Character Output (ttyPutc) &nbsp;&nbsp; 280 </td></tr><tr> <td align="left">15.12 </td><td colspan="2" align="left"> Starting Output (ttyKickOut) &nbsp;&nbsp; 281 </td></tr><tr> <td align="left">15.13 </td><td colspan="2" align="left"> Upper-Half Tty Multiple Character Output (ttyWrite) &nbsp;&nbsp; 282 </td></tr><tr> <td align="left">15.14 </td><td colspan="2" align="left"> Lower-Half Tty Driver Function (ttyInterrupt) &nbsp;&nbsp; 283 </td></tr><tr> <td align="left">15.15 </td><td colspan="2" align="left"> Output Interrupt Processing (ttyInter_out) &nbsp;&nbsp; 286 </td></tr><tr> <td align="left">15.16 </td><td colspan="2" align="left"> Tty Input Processing (ttyInter_in) &nbsp;&nbsp; 288 </td></tr><tr> <td align="left"> </td><td align="left">15.16.1 </td><td align="left"> Raw Mode Processing &nbsp;&nbsp; 294 </td></tr><tr> <td align="left"> </td><td align="left">15.16.2 </td><td align="left"> Cbreak Mode Processing &nbsp;&nbsp; 294 </td></tr><tr> <td align="left"> </td><td align="left">15.16.3 </td><td align="left"> Cooked Mode Processing &nbsp;&nbsp; 295 </td></tr><tr> <td align="left">15.17 </td><td colspan="2" align="left"> Tty Control Block Initialization (ttyInit) &nbsp;&nbsp; 295 </td></tr><tr> <td align="left">15.18 </td><td colspan="2" align="left"> Device Driver Control &nbsp;&nbsp; 297 </td></tr><tr> <td align="left">15.19 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 299 </td></tr><tr> <td align="left">15.20 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 300 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 300<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 16 &nbsp; DMA Devices And Drivers (Ethernet) &nbsp;&nbsp; 303</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">16.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 303 </td></tr><tr> <td align="left">16.2 </td><td colspan="2" align="left"> Direct Memory Access And Buffers &nbsp;&nbsp; 303 </td></tr><tr> <td align="left">16.3 </td><td colspan="2" align="left"> Multiple Buffers And Rings &nbsp;&nbsp; 304 </td></tr><tr> <td align="left">16.4 </td><td colspan="2" align="left"> An Example Ethernet Driver Using DMA &nbsp;&nbsp; 305 </td></tr><tr> <td align="left">16.5 </td><td colspan="2" align="left"> Device Hardware Definitions And Constants &nbsp;&nbsp; 305 </td></tr><tr> <td align="left">16.6 </td><td colspan="2" align="left"> Rings And Buffers In Memory &nbsp;&nbsp; 309 </td></tr><tr> <td align="left">16.7 </td><td colspan="2" align="left"> Definitions Of An Ethernet Control Block &nbsp;&nbsp; 310 </td></tr><tr> <td align="left">16.8 </td><td colspan="2" align="left"> Device And Driver Initialization &nbsp;&nbsp; 313 </td></tr><tr> <td align="left">16.9 </td><td colspan="2" align="left"> Allocating An Input Buffer &nbsp;&nbsp; 318 </td></tr><tr> <td align="left">16.10 </td><td colspan="2" align="left"> Reading From An Ethernet Device &nbsp;&nbsp; 320 </td></tr><tr> <td align="left">16.11 </td><td colspan="2" align="left"> Writing To An Ethernet Device &nbsp;&nbsp; 322 </td></tr><tr> <td align="left">16.12 </td><td colspan="2" align="left"> Handling Interrupts From An Ethernet Device &nbsp;&nbsp; 324 </td></tr><tr> <td align="left">16.13 </td><td colspan="2" align="left"> Ethernet Control Functions &nbsp;&nbsp; 328 </td></tr><tr> <td align="left">16.14 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 330 </td></tr><tr> <td align="left">16.15 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 330 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 331<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 17 &nbsp; A Minimal Internet Protocol Stack &nbsp;&nbsp; 333</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">17.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 333 </td></tr><tr> <td align="left">17.2 </td><td colspan="2" align="left"> Required Functionality &nbsp;&nbsp; 334 </td></tr><tr> <td align="left">17.3 </td><td colspan="2" align="left"> Simultaneous Conversations, Timeouts, And Processes &nbsp;&nbsp; 335 </td></tr><tr> <td align="left">17.4 </td><td colspan="2" align="left"> ARP Functions &nbsp;&nbsp; 336 </td></tr><tr> <td align="left">17.5 </td><td colspan="2" align="left"> Definition Of A Network Packet &nbsp;&nbsp; 346 </td></tr><tr> <td align="left">17.6 </td><td colspan="2" align="left"> The Network Input Process &nbsp;&nbsp; 347 </td></tr><tr> <td align="left">17.7 </td><td colspan="2" align="left"> Definition Of The UDP Table &nbsp;&nbsp; 351 </td></tr><tr> <td align="left">17.8 </td><td colspan="2" align="left"> UDP Functions &nbsp;&nbsp; 352 </td></tr><tr> <td align="left">17.9 </td><td colspan="2" align="left"> Internet Control Message Protocol &nbsp;&nbsp; 362 </td></tr><tr> <td align="left">17.10 </td><td colspan="2" align="left"> Dynamic Host Configuration Protocol &nbsp;&nbsp; 363 </td></tr><tr> <td align="left">17.11 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 368 </td></tr><tr> <td align="left">17.12 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 368 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 369<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 18 &nbsp; A Remote Disk Driver &nbsp;&nbsp; 371</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">18.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 371 </td></tr><tr> <td align="left">18.2 </td><td colspan="2" align="left"> The Disk Abstraction &nbsp;&nbsp; 371 </td></tr><tr> <td align="left">18.3 </td><td colspan="2" align="left"> Operations A Disk Driver Supports &nbsp;&nbsp; 372 </td></tr><tr> <td align="left">18.4 </td><td colspan="2" align="left"> Block Transfer And High-Level I/O Functions &nbsp;&nbsp; 372 </td></tr><tr> <td align="left">18.5 </td><td colspan="2" align="left"> A Remote Disk Paradigm &nbsp;&nbsp; 373 </td></tr><tr> <td align="left">18.6 </td><td colspan="2" align="left"> Semantics Of Disk Operations &nbsp;&nbsp; 374 </td></tr><tr> <td align="left">18.7 </td><td colspan="2" align="left"> Definition Of Driver Data Structures &nbsp;&nbsp; 375 </td></tr><tr> <td align="left">18.8 </td><td colspan="2" align="left"> Driver Initialization (rdsInit) &nbsp;&nbsp; 381 </td></tr><tr> <td align="left">18.9 </td><td colspan="2" align="left"> The Upper-Half Open Function (rdsOpen) &nbsp;&nbsp; 384 </td></tr><tr> <td align="left">18.10 </td><td colspan="2" align="left"> The Remote Communication Function (rdscomm) &nbsp;&nbsp; 386 </td></tr><tr> <td align="left">18.11 </td><td colspan="2" align="left"> The Upper-Half Write Function (rdsWrite) &nbsp;&nbsp; 389 </td></tr><tr> <td align="left">18.12 </td><td colspan="2" align="left"> The Upper-Half Read Function (rdsRead) &nbsp;&nbsp; 391 </td></tr><tr> <td align="left">18.13 </td><td colspan="2" align="left"> Flushing Pending Requests &nbsp;&nbsp; 395 </td></tr><tr> <td align="left">18.14 </td><td colspan="2" align="left"> The Upper-Half Control Function (rdsControl) &nbsp;&nbsp; 396 </td></tr><tr> <td align="left">18.15 </td><td colspan="2" align="left"> Allocating A Disk Buffer (rdsbufalloc) &nbsp;&nbsp; 399 </td></tr><tr> <td align="left">18.16 </td><td colspan="2" align="left"> The Upper-Half Close Function (rdsClose) &nbsp;&nbsp; 400 </td></tr><tr> <td align="left">18.17 </td><td colspan="2" align="left"> The Lower-Half Communication Process (rdsprocess) &nbsp;&nbsp; 402 </td></tr><tr> <td align="left">18.18 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 407 </td></tr><tr> <td align="left">18.19 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 407 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 408<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 19 &nbsp; File Systems &nbsp;&nbsp; 411</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">19.1 </td><td colspan="2" align="left"> What Is A File System? &nbsp;&nbsp; 411 </td></tr><tr> <td align="left">19.2 </td><td colspan="2" align="left"> An Example Set Of File Operations &nbsp;&nbsp; 412 </td></tr><tr> <td align="left">19.3 </td><td colspan="2" align="left"> Design Of A Local File System &nbsp;&nbsp; 413 </td></tr><tr> <td align="left">19.4 </td><td colspan="2" align="left"> Data Structures For The Xinu File System &nbsp;&nbsp; 413 </td></tr><tr> <td align="left">19.5 </td><td colspan="2" align="left"> Implementation Of The Index Manager &nbsp;&nbsp; 415 </td></tr><tr> <td align="left">19.6 </td><td colspan="2" align="left"> Clearing An Index Block (lfibclear) &nbsp;&nbsp; 420 </td></tr><tr> <td align="left">19.7 </td><td colspan="2" align="left"> Retrieving An Index Block (lfibget) &nbsp;&nbsp; 420 </td></tr><tr> <td align="left">19.8 </td><td colspan="2" align="left"> Storing An Index Block (lfibput) &nbsp;&nbsp; 421 </td></tr><tr> <td align="left">19.9 </td><td colspan="2" align="left"> Allocating An Index Block From The Free List (lfiballoc) &nbsp;&nbsp; 423 </td></tr><tr> <td align="left">19.10 </td><td colspan="2" align="left"> Allocating A Data Block From The Free List (lfdballoc) &nbsp;&nbsp; 424 </td></tr><tr> <td align="left">19.11 </td><td colspan="2" align="left"> Using The Device-Independent I/O Functions For Files &nbsp;&nbsp; 426 </td></tr><tr> <td align="left">19.12 </td><td colspan="2" align="left"> File System Device Configuration And Function Names &nbsp;&nbsp; 426 </td></tr><tr> <td align="left">19.13 </td><td colspan="2" align="left"> The Local File System Open Function (lfsOpen) &nbsp;&nbsp; 427 </td></tr><tr> <td align="left">19.14 </td><td colspan="2" align="left"> Closing A File Pseudo-Device (lflClose) &nbsp;&nbsp; 435 </td></tr><tr> <td align="left">19.15 </td><td colspan="2" align="left"> Flushing Data To Disk (lfflush) &nbsp;&nbsp; 436 </td></tr><tr> <td align="left">19.16 </td><td colspan="2" align="left"> Bulk Transfer Functions For A File (lflWrite, lflRead) &nbsp;&nbsp; 437 </td></tr><tr> <td align="left">19.17 </td><td colspan="2" align="left"> Seeking To A New Position In the File (lflSeek) &nbsp;&nbsp; 439 </td></tr><tr> <td align="left">19.18 </td><td colspan="2" align="left"> Extracting One Byte From A File (lflGetc) &nbsp;&nbsp; 440 </td></tr><tr> <td align="left">19.19 </td><td colspan="2" align="left"> Changing One Byte In A File (lflPutc) &nbsp;&nbsp; 442 </td></tr><tr> <td align="left">19.20 </td><td colspan="2" align="left"> Loading An Index Block And A Data Block (lfsetup) &nbsp;&nbsp; 443 </td></tr><tr> <td align="left">19.21 </td><td colspan="2" align="left"> Master File System Device Initialization (lfsInit) &nbsp;&nbsp; 447 </td></tr><tr> <td align="left">19.22 </td><td colspan="2" align="left"> Pseudo-Device Initialization (lflInit) &nbsp;&nbsp; 448 </td></tr><tr> <td align="left">19.23 </td><td colspan="2" align="left"> File Truncation (lftruncate) &nbsp;&nbsp; 449 </td></tr><tr> <td align="left">19.24 </td><td colspan="2" align="left"> Initial File System Creation (lfscreate) &nbsp;&nbsp; 452 </td></tr><tr> <td align="left">19.25 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 454 </td></tr><tr> <td align="left">19.26 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 455 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 455<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 20 &nbsp; A Remote File Mechanism &nbsp;&nbsp; 459</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">20.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 459 </td></tr><tr> <td align="left">20.2 </td><td colspan="2" align="left"> Remote File Access &nbsp;&nbsp; 459 </td></tr><tr> <td align="left">20.3 </td><td colspan="2" align="left"> Remote File Semantics &nbsp;&nbsp; 460 </td></tr><tr> <td align="left">20.4 </td><td colspan="2" align="left"> Remote File Design And Messages &nbsp;&nbsp; 460 </td></tr><tr> <td align="left">20.5 </td><td colspan="2" align="left"> Remote File Server Communication &nbsp;&nbsp; 468 </td></tr><tr> <td align="left">20.6 </td><td colspan="2" align="left"> Sending A Basic Message &nbsp;&nbsp; 470 </td></tr><tr> <td align="left">20.7 </td><td colspan="2" align="left"> Network Byte Order &nbsp;&nbsp; 472 </td></tr><tr> <td align="left">20.8 </td><td colspan="2" align="left"> A Remote File System Using A Device Paradigm &nbsp;&nbsp; 472 </td></tr><tr> <td align="left">20.9 </td><td colspan="2" align="left"> Opening A Remote File &nbsp;&nbsp; 474 </td></tr><tr> <td align="left">20.10 </td><td colspan="2" align="left"> Checking The File Mode &nbsp;&nbsp; 477 </td></tr><tr> <td align="left">20.11 </td><td colspan="2" align="left"> Closing A Remote File &nbsp;&nbsp; 478 </td></tr><tr> <td align="left">20.12 </td><td colspan="2" align="left"> Reading From A Remote File &nbsp;&nbsp; 479 </td></tr><tr> <td align="left">20.13 </td><td colspan="2" align="left"> Writing To A Remote File &nbsp;&nbsp; 482 </td></tr><tr> <td align="left">20.14 </td><td colspan="2" align="left"> Seek On A Remote File &nbsp;&nbsp; 485 </td></tr><tr> <td align="left">20.15 </td><td colspan="2" align="left"> Character I/O On A Remote File &nbsp;&nbsp; 486 </td></tr><tr> <td align="left">20.16 </td><td colspan="2" align="left"> Remote File System Control Functions &nbsp;&nbsp; 487 </td></tr><tr> <td align="left">20.17 </td><td colspan="2" align="left"> Initializing The Remote File Data Structure &nbsp;&nbsp; 491 </td></tr><tr> <td align="left">20.18 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 493 </td></tr><tr> <td align="left">20.19 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 493 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 493<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 21 &nbsp; A Syntactic Namespace &nbsp;&nbsp; 497</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">21.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 497 </td></tr><tr> <td align="left">21.2 </td><td colspan="2" align="left"> Transparency And A Namespace Abstraction &nbsp;&nbsp; 497 </td></tr><tr> <td align="left">21.3 </td><td colspan="2" align="left"> Myriad Naming Schemes &nbsp;&nbsp; 498 </td></tr><tr> <td align="left"> </td><td align="left">21.3.1 </td><td align="left"> MS-DOS &nbsp;&nbsp; 499 </td></tr><tr> <td align="left"> </td><td align="left">21.3.2 </td><td align="left"> UNIX &nbsp;&nbsp; 499 </td></tr><tr> <td align="left"> </td><td align="left">21.3.3 </td><td align="left"> V System &nbsp;&nbsp; 499 </td></tr><tr> <td align="left"> </td><td align="left">21.3.4 </td><td align="left"> IBIS &nbsp;&nbsp; 499 </td></tr><tr> <td align="left">21.4 </td><td colspan="2" align="left"> Naming System Design Alternatives &nbsp;&nbsp; 500 </td></tr><tr> <td align="left">21.5 </td><td colspan="2" align="left"> A Syntactic Namespace &nbsp;&nbsp; 500 </td></tr><tr> <td align="left">21.6 </td><td colspan="2" align="left"> Patterns And Replacements &nbsp;&nbsp; 501 </td></tr><tr> <td align="left">21.7 </td><td colspan="2" align="left"> Prefix Patterns &nbsp;&nbsp; 501 </td></tr><tr> <td align="left">21.8 </td><td colspan="2" align="left"> Implementation Of A Namespace &nbsp;&nbsp; 502 </td></tr><tr> <td align="left">21.9 </td><td colspan="2" align="left"> Namespace Data Structures And Constants &nbsp;&nbsp; 502 </td></tr><tr> <td align="left">21.10 </td><td colspan="2" align="left"> Adding Mappings To The Namespace Prefix Table &nbsp;&nbsp; 503 </td></tr><tr> <td align="left">21.11 </td><td colspan="2" align="left"> Mapping Names With The Prefix Table &nbsp;&nbsp; 505 </td></tr><tr> <td align="left">21.12 </td><td colspan="2" align="left"> Opening A Named File &nbsp;&nbsp; 509 </td></tr><tr> <td align="left">21.13 </td><td colspan="2" align="left"> Namespace Initialization &nbsp;&nbsp; 510 </td></tr><tr> <td align="left">21.14 </td><td colspan="2" align="left"> Ordering Entries In The Prefix Table &nbsp;&nbsp; 513 </td></tr><tr> <td align="left">21.15 </td><td colspan="2" align="left"> Choosing A Logical Namespace &nbsp;&nbsp; 514 </td></tr><tr> <td align="left">21.16 </td><td colspan="2" align="left"> A Default Hierarchy And The Null Prefix &nbsp;&nbsp; 515 </td></tr><tr> <td align="left">21.17 </td><td colspan="2" align="left"> Additional Object Manipulation Functions &nbsp;&nbsp; 515 </td></tr><tr> <td align="left">21.18 </td><td colspan="2" align="left"> Advantages And Limits Of The Namespace Approach &nbsp;&nbsp; 516 </td></tr><tr> <td align="left">21.19 </td><td colspan="2" align="left"> Generalized Patterns &nbsp;&nbsp; 517 </td></tr><tr> <td align="left">21.20 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 518 </td></tr><tr> <td align="left">21.21 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 518 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 519<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 22 &nbsp; System Initialization &nbsp;&nbsp; 521</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">22.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 521 </td></tr><tr> <td align="left">22.2 </td><td colspan="2" align="left"> Bootstrap: Starting From Scratch &nbsp;&nbsp; 521 </td></tr><tr> <td align="left">22.3 </td><td colspan="2" align="left"> Operating System Initialization &nbsp;&nbsp; 522 </td></tr><tr> <td align="left">22.4 </td><td colspan="2" align="left"> Booting An Alternative Image On The E2100L &nbsp;&nbsp; 523 </td></tr><tr> <td align="left">22.5 </td><td colspan="2" align="left"> Xinu Initialization &nbsp;&nbsp; 524 </td></tr><tr> <td align="left">22.6 </td><td colspan="2" align="left"> System Startup &nbsp;&nbsp; 527 </td></tr><tr> <td align="left">22.7 </td><td colspan="2" align="left"> Transforming A Program Into A Process &nbsp;&nbsp; 531 </td></tr><tr> <td align="left">22.8 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 532 </td></tr><tr> <td align="left">22.9 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 532 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 532<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 23 &nbsp; Exception Handling &nbsp;&nbsp; 535</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">23.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 535 </td></tr><tr> <td align="left">23.2 </td><td colspan="2" align="left"> Exceptions, Traps, And Illegal Interrupts &nbsp;&nbsp; 535 </td></tr><tr> <td align="left">23.3 </td><td colspan="2" align="left"> Implementation Of Panic &nbsp;&nbsp; 536 </td></tr><tr> <td align="left">23.4 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 537 </td></tr><tr> <td align="left">23.5 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 538 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 538<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 24 &nbsp; System Configuration &nbsp;&nbsp; 541</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">24.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 541 </td></tr><tr> <td align="left">24.2 </td><td colspan="2" align="left"> The Need For Multiple Configurations &nbsp;&nbsp; 541 </td></tr><tr> <td align="left">24.3 </td><td colspan="2" align="left"> Configuration In Xinu &nbsp;&nbsp; 542 </td></tr><tr> <td align="left">24.4 </td><td colspan="2" align="left"> Contents Of The Xinu Configuration File &nbsp;&nbsp; 543 </td></tr><tr> <td align="left"> </td><td align="left">24.4.1 </td><td align="left"> Section 1: Type Declarations &nbsp;&nbsp; 543 </td></tr><tr> <td align="left"> </td><td align="left">24.4.2 </td><td align="left"> Section 2: Device Specifications &nbsp;&nbsp; 544 </td></tr><tr> <td align="left"> </td><td align="left">24.4.3 </td><td align="left"> Automatically Generated Symbolic Constants &nbsp;&nbsp; 545 </td></tr><tr> <td align="left">24.5 </td><td colspan="2" align="left"> Computation Of Minor Device Numbers &nbsp;&nbsp; 545 </td></tr><tr> <td align="left">24.6 </td><td colspan="2" align="left"> Steps In Configuring A Xinu System &nbsp;&nbsp; 546 </td></tr><tr> <td align="left">24.7 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 547 </td></tr><tr> <td align="left">24.8 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 547 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 547<br> </td></tr></tbody></table> <br> <br> <h3>Chapter 25 &nbsp; An Example User Interface: The Xinu Shell &nbsp;&nbsp; 549</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">25.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 549 </td></tr><tr> <td align="left">25.2 </td><td colspan="2" align="left"> What Is A User Interface? &nbsp;&nbsp; 550 </td></tr><tr> <td align="left">25.3 </td><td colspan="2" align="left"> Commands And Design Principles &nbsp;&nbsp; 550 </td></tr><tr> <td align="left">25.4 </td><td colspan="2" align="left"> Design Decisions For A Simplified Shell &nbsp;&nbsp; 551 </td></tr><tr> <td align="left">25.5 </td><td colspan="2" align="left"> Shell Organization And Operation &nbsp;&nbsp; 551 </td></tr><tr> <td align="left">25.6 </td><td colspan="2" align="left"> The Definition Of Lexical Tokens &nbsp;&nbsp; 552 </td></tr><tr> <td align="left">25.7 </td><td colspan="2" align="left"> The Definition Of Command-Line Syntax &nbsp;&nbsp; 552 </td></tr><tr> <td align="left">25.8 </td><td colspan="2" align="left"> Implementation Of The Xinu Shell &nbsp;&nbsp; 553 </td></tr><tr> <td align="left">25.9 </td><td colspan="2" align="left"> Storage Of Tokens &nbsp;&nbsp; 555 </td></tr><tr> <td align="left">25.10 </td><td colspan="2" align="left"> Code For The Lexical Analyzer &nbsp;&nbsp; 556 </td></tr><tr> <td align="left">25.11 </td><td colspan="2" align="left"> The Heart Of The Command Interpreter &nbsp;&nbsp; 561 </td></tr><tr> <td align="left">25.12 </td><td colspan="2" align="left"> Command Name Lookup And Builtin Processing &nbsp;&nbsp; 569 </td></tr><tr> <td align="left">25.13 </td><td colspan="2" align="left"> Arguments Passed To Commands &nbsp;&nbsp; 570 </td></tr><tr> <td align="left">25.14 </td><td colspan="2" align="left"> Passing Arguments To A Non-Builtin Command &nbsp;&nbsp; 571 </td></tr><tr> <td align="left">25.15 </td><td colspan="2" align="left"> I/O Redirection &nbsp;&nbsp; 575 </td></tr><tr> <td align="left">25.16 </td><td colspan="2" align="left"> An Example Command Function (sleep) &nbsp;&nbsp; 575 </td></tr><tr> <td align="left">25.17 </td><td colspan="2" align="left"> Perspective &nbsp;&nbsp; 577 </td></tr><tr> <td align="left">25.18 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 578 </td></tr><tr> <td></td><td colspan="2" align="left"> Exercises &nbsp;&nbsp; 578<br> </td></tr></tbody></table> <br> <br><h3> Appendix 1 &nbsp; Porting An Operating System &nbsp;&nbsp; 580</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">A1.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 580 </td></tr><tr> <td align="left">A1.2 </td><td colspan="2" align="left"> Motivation: Evolving Hardware &nbsp;&nbsp; 581 </td></tr><tr> <td align="left">A1.3 </td><td colspan="2" align="left"> Steps Taken When Porting An Operating System &nbsp;&nbsp; 581 </td></tr><tr> <td align="left"> </td><td align="left">A1.3.1 </td><td align="left"> Learning About The Hardware And Compile &nbsp;&nbsp; 583 </td></tr><tr> <td align="left"> </td><td align="left">A1.3.2 </td><td align="left"> Cross Development &nbsp;&nbsp; 583 </td></tr><tr> <td align="left"> </td><td align="left">A1.3.3 </td><td align="left"> Calling Conventions &nbsp;&nbsp; 583 </td></tr><tr> <td align="left"> </td><td align="left">A1.3.4 </td><td align="left"> Bootstrap Mechanisms &nbsp;&nbsp; 584 </td></tr><tr> <td align="left"> </td><td align="left">A1.3.5 </td><td align="left"> Polled Output &nbsp;&nbsp; 584 </td></tr><tr> <td align="left"> </td><td align="left">A1.3.6 </td><td align="left"> Sequential Program Execution &nbsp;&nbsp; 584 </td></tr><tr> <td align="left"> </td><td align="left">A1.3.7 </td><td align="left"> Basic Memory Management &nbsp;&nbsp; 585 </td></tr><tr> <td align="left"> </td><td align="left">A1.3.8 </td><td align="left"> Process Creation And Context Switch &nbsp;&nbsp; 585 </td></tr><tr> <td align="left"> </td><td align="left">A1.3.9 </td><td align="left"> Synchronization And Other Process Management Functions &nbsp;&nbsp; 585 </td></tr><tr> <td align="left"> </td><td align="left">A1.3.10 </td><td align="left"> Interrupt Dispatching And Real-Time Clock &nbsp;&nbsp; 586 </td></tr><tr> <td align="left"> </td><td align="left">A1.3.11 </td><td align="left"> Tty Device Driver &nbsp;&nbsp; 586 </td></tr><tr> <td align="left"> </td><td align="left">A1.3.12 </td><td align="left"> Other I/O Software And Device Drivers &nbsp;&nbsp; 586 </td></tr><tr> <td align="left"> </td><td align="left">A1.3.13 </td><td align="left"> File System &nbsp;&nbsp; 587 </td></tr><tr> <td align="left"> </td><td align="left">A1.3.14 </td><td align="left"> Protocol Software &nbsp;&nbsp; 587 </td></tr><tr> <td align="left"> </td><td align="left">A1.3.15 </td><td align="left"> Shell And Applications &nbsp;&nbsp; 587 </td></tr><tr> <td align="left">A1.4 </td><td colspan="2" align="left"> Programming To Accommodate Change &nbsp;&nbsp; 587 </td></tr><tr> <td align="left">A1.5 </td><td colspan="2" align="left"> Summary &nbsp;&nbsp; 589 </td></tr></tbody></table> <br> <br><h3> Appendix 2 &nbsp; Xinu Design Notes &nbsp;&nbsp; 590</h3> <table cellpadding="0" cellspacing="2"> <tbody><tr> <td align="left">A2.1 </td><td colspan="2" align="left"> Introduction &nbsp;&nbsp; 590 </td></tr><tr> <td align="left">A2.2 </td><td colspan="2" align="left"> Overview &nbsp;&nbsp; 590 </td></tr><tr> <td align="left">A2.3 </td><td colspan="2" align="left"> Xinu Design Notes &nbsp;&nbsp; 591 </td></tr><tr> <td align="left">A2.4 </td><td colspan="2" align="left"> Xinu Implementation &nbsp;&nbsp; 592 </td></tr><tr> <td align="left">A2.5 </td><td colspan="2" align="left"> Major Concepts And Implementation &nbsp;&nbsp; 593 </td></tr></tbody></table> <br><h3> Index &nbsp;&nbsp;596</h3> </ul></ul> </body></html>
</DOC>
