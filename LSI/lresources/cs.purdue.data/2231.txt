<DOC>
<DOCNO> http://www.cs.purdue.edu/homes/dec/nsd-2xxx.cont.html </DOCNO>
<HTML> <HEAD> <TITLE> nsd contents </TITLE> </HEAD> <BODY> <CENTER> <H2> Table of Contents For <BR><BR> Network Systems Design<BR><BR> Using Network Processors (Intel IXP2xxx version) <BR><BR> </H2> </CENTER> <UL><UL> <BR><H3> Foreword &nbsp;&nbsp;xix</H3> <BR><H3> Preface &nbsp;&nbsp;xxi</H3> <BR> <H3>Chapter 1 &nbsp; Introduction And Overview &nbsp;&nbsp; 1</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>1.1 <TD ALIGN=left COLSPAN=2> Network Systems And The Internet &nbsp;&nbsp 1 <TR> <TD ALIGN=left>1.2 <TD ALIGN=left COLSPAN=2> Applications Vs. Infrastructure &nbsp;&nbsp 1 <TR> <TD ALIGN=left>1.3 <TD ALIGN=left COLSPAN=2> Network Systems Engineering &nbsp;&nbsp 2 <TR> <TD ALIGN=left>1.4 <TD ALIGN=left COLSPAN=2> Packet Processing &nbsp;&nbsp 2 <TR> <TD ALIGN=left>1.5 <TD ALIGN=left COLSPAN=2> Achieving High Speed &nbsp;&nbsp 3 <TR> <TD ALIGN=left>1.6 <TD ALIGN=left COLSPAN=2> Network Speed &nbsp;&nbsp 3 <TR> <TD ALIGN=left>1.7 <TD ALIGN=left COLSPAN=2> Hardware, Software, And Hybrids &nbsp;&nbsp 4 <TR> <TD ALIGN=left>1.8 <TD ALIGN=left COLSPAN=2> Scope And Organization Of The Text &nbsp;&nbsp 5 <TR> <TD ALIGN=left>1.9 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 5 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 5<BR> </TABLE> <BR> <BR> <H3>Chapter 2 &nbsp; Basic Terminology And Example Systems &nbsp;&nbsp; 7</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>2.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 7 <TR> <TD ALIGN=left>2.2 <TD ALIGN=left COLSPAN=2> Networks And Packets &nbsp;&nbsp 7 <TR> <TD ALIGN=left>2.3 <TD ALIGN=left COLSPAN=2> Connection-Oriented And Connectionless Paradigms &nbsp;&nbsp 8 <TR> <TD ALIGN=left>2.4 <TD ALIGN=left COLSPAN=2> Digital Circuits &nbsp;&nbsp 8 <TR> <TD ALIGN=left>2.5 <TD ALIGN=left COLSPAN=2> LAN And WAN Classifications &nbsp;&nbsp 9 <TR> <TD ALIGN=left>2.6 <TD ALIGN=left COLSPAN=2> The Internet And Heterogeneity &nbsp;&nbsp 9 <TR> <TD ALIGN=left>2.7 <TD ALIGN=left COLSPAN=2> Example Network Systems &nbsp;&nbsp 9 <TR> <TD ALIGN=left>2.8 <TD ALIGN=left COLSPAN=2> Broadcast Domains &nbsp;&nbsp 10 <TR> <TD ALIGN=left>2.9 <TD ALIGN=left COLSPAN=2> The Two Key Systems Used In The Internet &nbsp;&nbsp 11 <TR> <TD ALIGN=left>2.10 <TD ALIGN=left COLSPAN=2> Other Systems Used In The Internet &nbsp;&nbsp 12 <TR> <TD ALIGN=left>2.11 <TD ALIGN=left COLSPAN=2> Monitoring And Control Systems &nbsp;&nbsp 13 <TR> <TD ALIGN=left>2.12 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 13 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 13<BR> </TABLE> <BR> <BR> <H3>Chapter 3 &nbsp; Review Of Protocols And Packet Formats &nbsp;&nbsp; 15</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>3.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 15 <TR> <TD ALIGN=left>3.2 <TD ALIGN=left COLSPAN=2> Protocols And Layering &nbsp;&nbsp 15 <TR> <TD ALIGN=left>3.3 <TD ALIGN=left COLSPAN=2> Layers 1 And 2 (Physical And Network Interface) &nbsp;&nbsp 17 <TR> <TD ALIGN=left> <TD ALIGN=left>3.3.1 <TD ALIGN=left> Ethernet &nbsp;&nbsp 17 <TR> <TD ALIGN=left> <TD ALIGN=left>3.3.2 <TD ALIGN=left> Ethernet Frame Format &nbsp;&nbsp 17 <TR> <TD ALIGN=left> <TD ALIGN=left>3.3.3 <TD ALIGN=left> Ethernet Addresses &nbsp;&nbsp 18 <TR> <TD ALIGN=left> <TD ALIGN=left>3.3.4 <TD ALIGN=left> Ethernet Type Field &nbsp;&nbsp 19 <TR> <TD ALIGN=left>3.4 <TD ALIGN=left COLSPAN=2> Layer 3 (Internet) &nbsp;&nbsp 19 <TR> <TD ALIGN=left> <TD ALIGN=left>3.4.1 <TD ALIGN=left> The Internet Protocol &nbsp;&nbsp 19 <TR> <TD ALIGN=left> <TD ALIGN=left>3.4.2 <TD ALIGN=left> IP Datagram Format &nbsp;&nbsp 19 <TR> <TD ALIGN=left> <TD ALIGN=left>3.4.3 <TD ALIGN=left> IP Addresses &nbsp;&nbsp 20 <TR> <TD ALIGN=left>3.5 <TD ALIGN=left COLSPAN=2> Layer 4 (Transport) &nbsp;&nbsp 20 <TR> <TD ALIGN=left> <TD ALIGN=left>3.5.1 <TD ALIGN=left> UDP And TCP &nbsp;&nbsp 20 <TR> <TD ALIGN=left> <TD ALIGN=left>3.5.2 <TD ALIGN=left> UDP Datagram Format &nbsp;&nbsp 21 <TR> <TD ALIGN=left> <TD ALIGN=left>3.5.3 <TD ALIGN=left> TCP Segment Format &nbsp;&nbsp 22 <TR> <TD ALIGN=left>3.6 <TD ALIGN=left COLSPAN=2> Protocol Port Numbers And Demultiplexing &nbsp;&nbsp 23 <TR> <TD ALIGN=left>3.7 <TD ALIGN=left COLSPAN=2> Encapsulation And Transmission &nbsp;&nbsp 23 <TR> <TD ALIGN=left>3.8 <TD ALIGN=left COLSPAN=2> Address Resolution Protocol &nbsp;&nbsp 24 <TR> <TD ALIGN=left>3.9 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 24 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 24<BR> </TABLE> <BR> <BR><H3> PART I &nbsp;&nbsp; Traditional Protocol Processing Systems &nbsp;&nbsp; 27</H3> <BR> <H3>Chapter 4 &nbsp; Conventional Computer Hardware Architecture &nbsp;&nbsp; 29</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>4.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 29 <TR> <TD ALIGN=left>4.2 <TD ALIGN=left COLSPAN=2> A Conventional Computer System &nbsp;&nbsp 29 <TR> <TD ALIGN=left>4.3 <TD ALIGN=left COLSPAN=2> Network Interface Cards &nbsp;&nbsp 30 <TR> <TD ALIGN=left>4.4 <TD ALIGN=left COLSPAN=2> Definition Of A Bus &nbsp;&nbsp 31 <TR> <TD ALIGN=left>4.5 <TD ALIGN=left COLSPAN=2> The Bus Address Space &nbsp;&nbsp 32 <TR> <TD ALIGN=left>4.6 <TD ALIGN=left COLSPAN=2> The Fetch-Store Paradigm &nbsp;&nbsp 33 <TR> <TD ALIGN=left>4.7 <TD ALIGN=left COLSPAN=2> Network Interface Card Functionality &nbsp;&nbsp 34 <TR> <TD ALIGN=left>4.8 <TD ALIGN=left COLSPAN=2> NIC Optimizations For High Speed &nbsp;&nbsp 34 <TR> <TD ALIGN=left>4.9 <TD ALIGN=left COLSPAN=2> Onboard Address Recognition &nbsp;&nbsp 35 <TR> <TD ALIGN=left> <TD ALIGN=left>4.9.1 <TD ALIGN=left> Unicast And Broadcast Recognition And Filtering &nbsp;&nbsp 35 <TR> <TD ALIGN=left> <TD ALIGN=left>4.9.2 <TD ALIGN=left> Multicast Recognition And Filtering &nbsp;&nbsp 35 <TR> <TD ALIGN=left>4.10 <TD ALIGN=left COLSPAN=2> Onboard Packet Buffering &nbsp;&nbsp 36 <TR> <TD ALIGN=left>4.11 <TD ALIGN=left COLSPAN=2> Direct Memory Access &nbsp;&nbsp 37 <TR> <TD ALIGN=left>4.12 <TD ALIGN=left COLSPAN=2> Operation And Data Chaining &nbsp;&nbsp 38 <TR> <TD ALIGN=left>4.13 <TD ALIGN=left COLSPAN=2> Data Flow Diagram &nbsp;&nbsp 39 <TR> <TD ALIGN=left>4.14 <TD ALIGN=left COLSPAN=2> Promiscuous Mode &nbsp;&nbsp 39 <TR> <TD ALIGN=left>4.15 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 40 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 40<BR> </TABLE> <BR> <BR> <H3>Chapter 5 &nbsp; Basic Packet Processing: Algorithms And Data Structures &nbsp;&nbsp; 43</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>5.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 43 <TR> <TD ALIGN=left>5.2 <TD ALIGN=left COLSPAN=2> State Information and Resource Exhaustion &nbsp;&nbsp 43 <TR> <TD ALIGN=left>5.3 <TD ALIGN=left COLSPAN=2> Packet Buffer Allocation &nbsp;&nbsp 44 <TR> <TD ALIGN=left>5.4 <TD ALIGN=left COLSPAN=2> Packet Buffer Size And Copying &nbsp;&nbsp 45 <TR> <TD ALIGN=left>5.5 <TD ALIGN=left COLSPAN=2> Protocol Layering And Copying &nbsp;&nbsp 45 <TR> <TD ALIGN=left>5.6 <TD ALIGN=left COLSPAN=2> Heterogeneity And Network Byte Order &nbsp;&nbsp 46 <TR> <TD ALIGN=left>5.7 <TD ALIGN=left COLSPAN=2> Bridge Algorithm &nbsp;&nbsp 47 <TR> <TD ALIGN=left>5.8 <TD ALIGN=left COLSPAN=2> Table Lookup And Hashing &nbsp;&nbsp 49 <TR> <TD ALIGN=left>5.9 <TD ALIGN=left COLSPAN=2> IP Datagram Fragmentation And Reassembly &nbsp;&nbsp 50 <TR> <TD ALIGN=left> <TD ALIGN=left>5.9.1 <TD ALIGN=left> Interpretation Of The Flags Field &nbsp;&nbsp 51 <TR> <TD ALIGN=left> <TD ALIGN=left>5.9.2 <TD ALIGN=left> Interpretation Of The Fragment Offset Field &nbsp;&nbsp 51 <TR> <TD ALIGN=left> <TD ALIGN=left>5.9.3 <TD ALIGN=left> IP Fragmentation Algorithm &nbsp;&nbsp 52 <TR> <TD ALIGN=left> <TD ALIGN=left>5.9.4 <TD ALIGN=left> Fragmenting A Fragment &nbsp;&nbsp 53 <TR> <TD ALIGN=left> <TD ALIGN=left>5.9.5 <TD ALIGN=left> IP Reassembly &nbsp;&nbsp 53 <TR> <TD ALIGN=left> <TD ALIGN=left>5.9.6 <TD ALIGN=left> Grouping Fragments Together &nbsp;&nbsp 54 <TR> <TD ALIGN=left> <TD ALIGN=left>5.9.7 <TD ALIGN=left> Fragment Position &nbsp;&nbsp 54 <TR> <TD ALIGN=left> <TD ALIGN=left>5.9.8 <TD ALIGN=left> IP Reassembly Algorithm &nbsp;&nbsp 55 <TR> <TD ALIGN=left>5.10 <TD ALIGN=left COLSPAN=2> IP Datagram Forwarding &nbsp;&nbsp 56 <TR> <TD ALIGN=left>5.11 <TD ALIGN=left COLSPAN=2> IP Forwarding Algorithm &nbsp;&nbsp 57 <TR> <TD ALIGN=left>5.12 <TD ALIGN=left COLSPAN=2> High-Speed IP Forwarding &nbsp;&nbsp 57 <TR> <TD ALIGN=left>5.13 <TD ALIGN=left COLSPAN=2> TCP Connection Recognition Algorithm &nbsp;&nbsp 59 <TR> <TD ALIGN=left>5.14 <TD ALIGN=left COLSPAN=2> TCP Splicing Algorithm &nbsp;&nbsp 60 <TR> <TD ALIGN=left>5.15 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 63 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 63<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 63<BR> </TABLE> <BR> <BR> <H3>Chapter 6 &nbsp; Packet Processing Functions &nbsp;&nbsp; 67</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>6.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 67 <TR> <TD ALIGN=left>6.2 <TD ALIGN=left COLSPAN=2> Packet Processing &nbsp;&nbsp 68 <TR> <TD ALIGN=left>6.3 <TD ALIGN=left COLSPAN=2> Address Lookup And Packet Forwarding &nbsp;&nbsp 68 <TR> <TD ALIGN=left>6.4 <TD ALIGN=left COLSPAN=2> Error Detection And Correction &nbsp;&nbsp 69 <TR> <TD ALIGN=left>6.5 <TD ALIGN=left COLSPAN=2> Fragmentation, Segmentation, And Reassembly &nbsp;&nbsp 70 <TR> <TD ALIGN=left>6.6 <TD ALIGN=left COLSPAN=2> Frame And Protocol Demultiplexing &nbsp;&nbsp 70 <TR> <TD ALIGN=left>6.7 <TD ALIGN=left COLSPAN=2> Packet Classification &nbsp;&nbsp 71 <TR> <TD ALIGN=left> <TD ALIGN=left>6.7.1 <TD ALIGN=left> Static And Dynamic Classification &nbsp;&nbsp 71 <TR> <TD ALIGN=left> <TD ALIGN=left>6.7.2 <TD ALIGN=left> Demultiplexing Vs. Classification &nbsp;&nbsp 71 <TR> <TD ALIGN=left> <TD ALIGN=left>6.7.3 <TD ALIGN=left> Optimized Packet Processing &nbsp;&nbsp 72 <TR> <TD ALIGN=left> <TD ALIGN=left>6.7.4 <TD ALIGN=left> Classification Languages &nbsp;&nbsp 72 <TR> <TD ALIGN=left>6.8 <TD ALIGN=left COLSPAN=2> Queueing And Packet Discard &nbsp;&nbsp 73 <TR> <TD ALIGN=left> <TD ALIGN=left>6.8.1 <TD ALIGN=left> Basic Queueing &nbsp;&nbsp 73 <TR> <TD ALIGN=left> <TD ALIGN=left>6.8.2 <TD ALIGN=left> Priority Mechanisms &nbsp;&nbsp 73 <TR> <TD ALIGN=left> <TD ALIGN=left>6.8.3 <TD ALIGN=left> Packet Discard &nbsp;&nbsp 75 <TR> <TD ALIGN=left>6.9 <TD ALIGN=left COLSPAN=2> Scheduling And Timing &nbsp;&nbsp 75 <TR> <TD ALIGN=left>6.10 <TD ALIGN=left COLSPAN=2> Security: Authentication And Privacy &nbsp;&nbsp 76 <TR> <TD ALIGN=left>6.11 <TD ALIGN=left COLSPAN=2> Traffic Measurement And Policing &nbsp;&nbsp 76 <TR> <TD ALIGN=left>6.12 <TD ALIGN=left COLSPAN=2> Traffic Shaping &nbsp;&nbsp 77 <TR> <TD ALIGN=left>6.13 <TD ALIGN=left COLSPAN=2> Timer Management &nbsp;&nbsp 79 <TR> <TD ALIGN=left>6.14 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 80 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 80<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 80<BR> </TABLE> <BR> <BR> <H3>Chapter 7 &nbsp; Protocol Software On A Conventional Processor &nbsp;&nbsp; 83</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>7.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 83 <TR> <TD ALIGN=left>7.2 <TD ALIGN=left COLSPAN=2> Implementation Of Packet Processing In An Application &nbsp;&nbsp 83 <TR> <TD ALIGN=left>7.3 <TD ALIGN=left COLSPAN=2> Fast Packet Processing In Software &nbsp;&nbsp 84 <TR> <TD ALIGN=left>7.4 <TD ALIGN=left COLSPAN=2> Embedded Systems &nbsp;&nbsp 84 <TR> <TD ALIGN=left>7.5 <TD ALIGN=left COLSPAN=2> Operating System Implementations &nbsp;&nbsp 85 <TR> <TD ALIGN=left>7.6 <TD ALIGN=left COLSPAN=2> Software Interrupts And Priorities &nbsp;&nbsp 85 <TR> <TD ALIGN=left>7.7 <TD ALIGN=left COLSPAN=2> Multiple Priorities And Kernel Threads &nbsp;&nbsp 87 <TR> <TD ALIGN=left>7.8 <TD ALIGN=left COLSPAN=2> Thread Synchronization &nbsp;&nbsp 88 <TR> <TD ALIGN=left>7.9 <TD ALIGN=left COLSPAN=2> Software For Layered Protocols &nbsp;&nbsp 88 <TR> <TD ALIGN=left> <TD ALIGN=left>7.9.1 <TD ALIGN=left> One Thread Per Layer &nbsp;&nbsp 89 <TR> <TD ALIGN=left> <TD ALIGN=left>7.9.2 <TD ALIGN=left> One Thread Per Protocol &nbsp;&nbsp 90 <TR> <TD ALIGN=left> <TD ALIGN=left>7.9.3 <TD ALIGN=left> Multiple Threads Per Protocol &nbsp;&nbsp 90 <TR> <TD ALIGN=left> <TD ALIGN=left>7.9.4 <TD ALIGN=left> Separate Timer Management Threads &nbsp;&nbsp 90 <TR> <TD ALIGN=left> <TD ALIGN=left>7.9.5 <TD ALIGN=left> One Thread Per Packet &nbsp;&nbsp 91 <TR> <TD ALIGN=left>7.10 <TD ALIGN=left COLSPAN=2> Asynchronous Vs. Synchronous Programming &nbsp;&nbsp 92 <TR> <TD ALIGN=left>7.11 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 93 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 93<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 93<BR> </TABLE> <BR> <BR> <H3>Chapter 8 &nbsp; Hardware Architectures For Protocol Processing &nbsp;&nbsp; 97</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>8.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 97 <TR> <TD ALIGN=left>8.2 <TD ALIGN=left COLSPAN=2> Network Systems Architecture &nbsp;&nbsp 97 <TR> <TD ALIGN=left>8.3 <TD ALIGN=left COLSPAN=2> The Traditional Software Router &nbsp;&nbsp 98 <TR> <TD ALIGN=left>8.4 <TD ALIGN=left COLSPAN=2> Aggregate Data Rate &nbsp;&nbsp 99 <TR> <TD ALIGN=left>8.5 <TD ALIGN=left COLSPAN=2> Aggregate Packet Rate &nbsp;&nbsp 99 <TR> <TD ALIGN=left>8.6 <TD ALIGN=left COLSPAN=2> Packet Rate And Software Router Feasibility &nbsp;&nbsp 101 <TR> <TD ALIGN=left>8.7 <TD ALIGN=left COLSPAN=2> Overcoming The Single CPU Bottleneck &nbsp;&nbsp 103 <TR> <TD ALIGN=left>8.8 <TD ALIGN=left COLSPAN=2> Fine-Grain Parallelism &nbsp;&nbsp 104 <TR> <TD ALIGN=left>8.9 <TD ALIGN=left COLSPAN=2> Symmetric Coarse-Grain Parallelism &nbsp;&nbsp 104 <TR> <TD ALIGN=left>8.10 <TD ALIGN=left COLSPAN=2> Asymmetric Coarse-Grain Parallelism &nbsp;&nbsp 105 <TR> <TD ALIGN=left>8.11 <TD ALIGN=left COLSPAN=2> Special-Purpose Coprocessors &nbsp;&nbsp 105 <TR> <TD ALIGN=left>8.12 <TD ALIGN=left COLSPAN=2> ASIC Coprocessor Implementation &nbsp;&nbsp 106 <TR> <TD ALIGN=left>8.13 <TD ALIGN=left COLSPAN=2> NICs With Onboard Processing &nbsp;&nbsp 107 <TR> <TD ALIGN=left>8.14 <TD ALIGN=left COLSPAN=2> Smart NICs With Onboard Stacks &nbsp;&nbsp 108 <TR> <TD ALIGN=left>8.15 <TD ALIGN=left COLSPAN=2> Cells And Connection-Oriented Addressing &nbsp;&nbsp 108 <TR> <TD ALIGN=left>8.16 <TD ALIGN=left COLSPAN=2> Data Pipelines &nbsp;&nbsp 109 <TR> <TD ALIGN=left>8.17 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 111 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 111<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 111<BR> </TABLE> <BR> <BR> <H3>Chapter 9 &nbsp; Classification And Forwarding &nbsp;&nbsp; 115</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>9.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 115 <TR> <TD ALIGN=left>9.2 <TD ALIGN=left COLSPAN=2> Inherent Limits Of Demultiplexing &nbsp;&nbsp 115 <TR> <TD ALIGN=left>9.3 <TD ALIGN=left COLSPAN=2> Packet Classification &nbsp;&nbsp 116 <TR> <TD ALIGN=left>9.4 <TD ALIGN=left COLSPAN=2> Software Implementation Of Classification &nbsp;&nbsp 117 <TR> <TD ALIGN=left>9.5 <TD ALIGN=left COLSPAN=2> Optimizing Software-Based Classification &nbsp;&nbsp 118 <TR> <TD ALIGN=left>9.6 <TD ALIGN=left COLSPAN=2> Software Classification On Special-Purpose Hardware &nbsp;&nbsp 119 <TR> <TD ALIGN=left>9.7 <TD ALIGN=left COLSPAN=2> Hardware Implementation Of Classification &nbsp;&nbsp 119 <TR> <TD ALIGN=left>9.8 <TD ALIGN=left COLSPAN=2> Optimized Classification Of Multiple Rule Sets &nbsp;&nbsp 120 <TR> <TD ALIGN=left>9.9 <TD ALIGN=left COLSPAN=2> Classification Of Variable-Size Headers &nbsp;&nbsp 122 <TR> <TD ALIGN=left>9.10 <TD ALIGN=left COLSPAN=2> Hybrid Hardware|/|Software Classification &nbsp;&nbsp 123 <TR> <TD ALIGN=left>9.11 <TD ALIGN=left COLSPAN=2> Dynamic Vs. Static Classification &nbsp;&nbsp 124 <TR> <TD ALIGN=left>9.12 <TD ALIGN=left COLSPAN=2> Fine-Grain Flow Creation &nbsp;&nbsp 125 <TR> <TD ALIGN=left>9.13 <TD ALIGN=left COLSPAN=2> Flow Forwarding In A Connection-Oriented Network &nbsp;&nbsp 126 <TR> <TD ALIGN=left>9.14 <TD ALIGN=left COLSPAN=2> Connectionless Network Classification And Forwarding &nbsp;&nbsp 126 <TR> <TD ALIGN=left>9.15 <TD ALIGN=left COLSPAN=2> Second Generation Network Systems &nbsp;&nbsp 127 <TR> <TD ALIGN=left>9.16 <TD ALIGN=left COLSPAN=2> Embedded Processors In Second Generation Systems &nbsp;&nbsp 128 <TR> <TD ALIGN=left>9.17 <TD ALIGN=left COLSPAN=2> Classification And Forwarding Chips &nbsp;&nbsp 129 <TR> <TD ALIGN=left>9.18 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 130 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 130<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 130<BR> </TABLE> <BR> <BR> <H3>Chapter 10 &nbsp; Switching Fabrics &nbsp;&nbsp; 133</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>10.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 133 <TR> <TD ALIGN=left>10.2 <TD ALIGN=left COLSPAN=2> Bandwidth Of An Internal Fast Path &nbsp;&nbsp 133 <TR> <TD ALIGN=left>10.3 <TD ALIGN=left COLSPAN=2> The Switching Fabric Concept &nbsp;&nbsp 134 <TR> <TD ALIGN=left>10.4 <TD ALIGN=left COLSPAN=2> Synchronous And Asynchronous Fabrics &nbsp;&nbsp 135 <TR> <TD ALIGN=left>10.5 <TD ALIGN=left COLSPAN=2> A Taxonomy Of Switching Fabric Architectures &nbsp;&nbsp 136 <TR> <TD ALIGN=left>10.6 <TD ALIGN=left COLSPAN=2> Dedicated Internal Paths And Port Contention &nbsp;&nbsp 136 <TR> <TD ALIGN=left>10.7 <TD ALIGN=left COLSPAN=2> Crossbar Architecture &nbsp;&nbsp 137 <TR> <TD ALIGN=left>10.8 <TD ALIGN=left COLSPAN=2> Basic Queueing &nbsp;&nbsp 139 <TR> <TD ALIGN=left>10.9 <TD ALIGN=left COLSPAN=2> Time Division Solutions: Sharing Data Paths &nbsp;&nbsp 141 <TR> <TD ALIGN=left>10.10 <TD ALIGN=left COLSPAN=2> Shared Bus Architecture &nbsp;&nbsp 141 <TR> <TD ALIGN=left>10.11 <TD ALIGN=left COLSPAN=2> Other Shared Medium Architectures &nbsp;&nbsp 142 <TR> <TD ALIGN=left>10.12 <TD ALIGN=left COLSPAN=2> Shared Memory Architecture &nbsp;&nbsp 143 <TR> <TD ALIGN=left>10.13 <TD ALIGN=left COLSPAN=2> Multistage Fabrics &nbsp;&nbsp 144 <TR> <TD ALIGN=left>10.14 <TD ALIGN=left COLSPAN=2> Banyan Architecture &nbsp;&nbsp 145 <TR> <TD ALIGN=left>10.15 <TD ALIGN=left COLSPAN=2> Scaling A Banyan Switch &nbsp;&nbsp 146 <TR> <TD ALIGN=left>10.16 <TD ALIGN=left COLSPAN=2> Commercial Technologies &nbsp;&nbsp 148 <TR> <TD ALIGN=left>10.17 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 148 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 149<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 149<BR> </TABLE> <BR> <BR><H3> PART II &nbsp;&nbsp; Network Processor Technology &nbsp;&nbsp; 151</H3> <BR> <H3>Chapter 11 &nbsp; Network Processors: Motivation And Purpose &nbsp;&nbsp; 153</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>11.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 153 <TR> <TD ALIGN=left>11.2 <TD ALIGN=left COLSPAN=2> The CPU In A Second Generation Architecture &nbsp;&nbsp 153 <TR> <TD ALIGN=left>11.3 <TD ALIGN=left COLSPAN=2> Third Generation Network Systems &nbsp;&nbsp 154 <TR> <TD ALIGN=left>11.4 <TD ALIGN=left COLSPAN=2> The Motivation For Embedded Processors &nbsp;&nbsp 155 <TR> <TD ALIGN=left>11.5 <TD ALIGN=left COLSPAN=2> RISC vs. CISC &nbsp;&nbsp 155 <TR> <TD ALIGN=left>11.6 <TD ALIGN=left COLSPAN=2> The Need For Custom Silicon &nbsp;&nbsp 156 <TR> <TD ALIGN=left>11.7 <TD ALIGN=left COLSPAN=2> Definition Of A Network Processor &nbsp;&nbsp 157 <TR> <TD ALIGN=left>11.8 <TD ALIGN=left COLSPAN=2> A Fundamental Idea: Flexibility Through Programmability &nbsp;&nbsp 158 <TR> <TD ALIGN=left>11.9 <TD ALIGN=left COLSPAN=2> Instruction Set &nbsp;&nbsp 159 <TR> <TD ALIGN=left>11.10 <TD ALIGN=left COLSPAN=2> Scalability With Parallelism And Pipelining &nbsp;&nbsp 159 <TR> <TD ALIGN=left>11.11 <TD ALIGN=left COLSPAN=2> The Costs And Benefits Of Network Processors &nbsp;&nbsp 160 <TR> <TD ALIGN=left>11.12 <TD ALIGN=left COLSPAN=2> Network Processors And The Economics Of Success &nbsp;&nbsp 161 <TR> <TD ALIGN=left>11.13 <TD ALIGN=left COLSPAN=2> The Status And Future Of Network Processors &nbsp;&nbsp 162 <TR> <TD ALIGN=left>11.14 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 162 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 163<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 163<BR> </TABLE> <BR> <BR> <H3>Chapter 12 &nbsp; The Complexity Of Network Processor Design &nbsp;&nbsp; 165</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>12.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 165 <TR> <TD ALIGN=left>12.2 <TD ALIGN=left COLSPAN=2> Network Processor Functionality &nbsp;&nbsp 165 <TR> <TD ALIGN=left>12.3 <TD ALIGN=left COLSPAN=2> Packet Processing Functions &nbsp;&nbsp 166 <TR> <TD ALIGN=left>12.4 <TD ALIGN=left COLSPAN=2> Ingress And Egress Processing &nbsp;&nbsp 167 <TR> <TD ALIGN=left> <TD ALIGN=left>12.4.1 <TD ALIGN=left> Ingress Processing &nbsp;&nbsp 167 <TR> <TD ALIGN=left> <TD ALIGN=left>12.4.2 <TD ALIGN=left> Egress Processing &nbsp;&nbsp 168 <TR> <TD ALIGN=left>12.5 <TD ALIGN=left COLSPAN=2> Parallel And Distributed Architecture &nbsp;&nbsp 170 <TR> <TD ALIGN=left>12.6 <TD ALIGN=left COLSPAN=2> The Architectural Roles Of Network Processors &nbsp;&nbsp 171 <TR> <TD ALIGN=left>12.7 <TD ALIGN=left COLSPAN=2> Consequences For Each Architectural Role &nbsp;&nbsp 171 <TR> <TD ALIGN=left>12.8 <TD ALIGN=left COLSPAN=2> Macroscopic Data Pipelining And Heterogeneity &nbsp;&nbsp 173 <TR> <TD ALIGN=left>12.9 <TD ALIGN=left COLSPAN=2> Network Processor Design And Software Emulation &nbsp;&nbsp 173 <TR> <TD ALIGN=left>12.10 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 174 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 174<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 175<BR> </TABLE> <BR> <BR> <H3>Chapter 13 &nbsp; Network Processor Architectures &nbsp;&nbsp; 177</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>13.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 177 <TR> <TD ALIGN=left>13.2 <TD ALIGN=left COLSPAN=2> Architectural Variety &nbsp;&nbsp 177 <TR> <TD ALIGN=left>13.3 <TD ALIGN=left COLSPAN=2> Primary Architectural Characteristics &nbsp;&nbsp 178 <TR> <TD ALIGN=left> <TD ALIGN=left>13.3.1 <TD ALIGN=left> Processor Hierarchy &nbsp;&nbsp 178 <TR> <TD ALIGN=left> <TD ALIGN=left>13.3.2 <TD ALIGN=left> Memory Hierarchy &nbsp;&nbsp 179 <TR> <TD ALIGN=left> <TD ALIGN=left>13.3.3 <TD ALIGN=left> Internal Transfer Mechanisms &nbsp;&nbsp 181 <TR> <TD ALIGN=left> <TD ALIGN=left>13.3.4 <TD ALIGN=left> External Interface And Communication Mechanisms &nbsp;&nbsp 182 <TR> <TD ALIGN=left> <TD ALIGN=left>13.3.5 <TD ALIGN=left> Special-Purpose Hardware &nbsp;&nbsp 183 <TR> <TD ALIGN=left> <TD ALIGN=left>13.3.6 <TD ALIGN=left> Polling And Notification Mechanisms &nbsp;&nbsp 183 <TR> <TD ALIGN=left> <TD ALIGN=left>13.3.7 <TD ALIGN=left> Concurrent Execution Support &nbsp;&nbsp 184 <TR> <TD ALIGN=left> <TD ALIGN=left>13.3.8 <TD ALIGN=left> Hardware Support For Programming &nbsp;&nbsp 185 <TR> <TD ALIGN=left> <TD ALIGN=left>13.3.9 <TD ALIGN=left> Hardware And Software Dispatch Mechanisms &nbsp;&nbsp 185 <TR> <TD ALIGN=left> <TD ALIGN=left>13.3.10 <TD ALIGN=left> Implicit Or Explicit Parallelism &nbsp;&nbsp 186 <TR> <TD ALIGN=left>13.4 <TD ALIGN=left COLSPAN=2> Architecture, Packet Flow, And Clock Rates &nbsp;&nbsp 186 <TR> <TD ALIGN=left>13.5 <TD ALIGN=left COLSPAN=2> Software Architecture &nbsp;&nbsp 189 <TR> <TD ALIGN=left>13.6 <TD ALIGN=left COLSPAN=2> Assigning Functionality To The Processor Hierarchy &nbsp;&nbsp 189 <TR> <TD ALIGN=left>13.7 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 191 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 192<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 192<BR> </TABLE> <BR> <BR> <H3>Chapter 14 &nbsp; Issues In Scaling A Network Processor &nbsp;&nbsp; 195</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>14.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 195 <TR> <TD ALIGN=left>14.2 <TD ALIGN=left COLSPAN=2> The Processing Hierarchy And Scaling &nbsp;&nbsp 195 <TR> <TD ALIGN=left>14.3 <TD ALIGN=left COLSPAN=2> Scaling By Making Processors Faster &nbsp;&nbsp 196 <TR> <TD ALIGN=left>14.4 <TD ALIGN=left COLSPAN=2> Scaling By Increasing The Number of Processors &nbsp;&nbsp 196 <TR> <TD ALIGN=left>14.5 <TD ALIGN=left COLSPAN=2> Scaling By Increasing Processor Types &nbsp;&nbsp 197 <TR> <TD ALIGN=left>14.6 <TD ALIGN=left COLSPAN=2> Scaling A Memory Hierarchy &nbsp;&nbsp 198 <TR> <TD ALIGN=left>14.7 <TD ALIGN=left COLSPAN=2> Scaling By Increasing Memory Size &nbsp;&nbsp 200 <TR> <TD ALIGN=left>14.8 <TD ALIGN=left COLSPAN=2> Scaling By Increasing Memory Bandwidth &nbsp;&nbsp 200 <TR> <TD ALIGN=left>14.9 <TD ALIGN=left COLSPAN=2> Scaling By Increasing Types Of Memory &nbsp;&nbsp 201 <TR> <TD ALIGN=left>14.10 <TD ALIGN=left COLSPAN=2> Scaling By Adding Memory Caches &nbsp;&nbsp 202 <TR> <TD ALIGN=left>14.11 <TD ALIGN=left COLSPAN=2> Scaling With Content Addressable Memory &nbsp;&nbsp 203 <TR> <TD ALIGN=left>14.12 <TD ALIGN=left COLSPAN=2> Using CAM for Packet Classification &nbsp;&nbsp 205 <TR> <TD ALIGN=left>14.13 <TD ALIGN=left COLSPAN=2> Other Limitations On Scale &nbsp;&nbsp 207 <TR> <TD ALIGN=left>14.14 <TD ALIGN=left COLSPAN=2> Software Scalability &nbsp;&nbsp 208 <TR> <TD ALIGN=left>14.15 <TD ALIGN=left COLSPAN=2> Bottlenecks And Scale &nbsp;&nbsp 209 <TR> <TD ALIGN=left>14.16 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 209 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 210<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 210<BR> </TABLE> <BR> <BR> <H3>Chapter 15 &nbsp; Examples Of Commercial Network Processors &nbsp;&nbsp; 213</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>15.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 213 <TR> <TD ALIGN=left>15.2 <TD ALIGN=left COLSPAN=2> An Explosion Of Commercial Products &nbsp;&nbsp 213 <TR> <TD ALIGN=left>15.3 <TD ALIGN=left COLSPAN=2> A Selection of Products &nbsp;&nbsp 214 <TR> <TD ALIGN=left>15.4 <TD ALIGN=left COLSPAN=2> Two-Stage Pipeline (Agere) &nbsp;&nbsp 214 <TR> <TD ALIGN=left>15.5 <TD ALIGN=left COLSPAN=2> Augmented RISC Processor (Alchemy) &nbsp;&nbsp 216 <TR> <TD ALIGN=left>15.6 <TD ALIGN=left COLSPAN=2> Embedded Processor Plus Coprocessors (AMCC) &nbsp;&nbsp 218 <TR> <TD ALIGN=left>15.7 <TD ALIGN=left COLSPAN=2> Pipeline Of Homogeneous Processors (Cisco) &nbsp;&nbsp 219 <TR> <TD ALIGN=left>15.8 <TD ALIGN=left COLSPAN=2> Pipeline Of Heterogeneous Processors (EZchip) &nbsp;&nbsp 220 <TR> <TD ALIGN=left>15.9 <TD ALIGN=left COLSPAN=2> Extensive And Diverse Processors (Hifn) &nbsp;&nbsp 222 <TR> <TD ALIGN=left>15.10 <TD ALIGN=left COLSPAN=2> Flexible RISC Plus Coprocessors (Motorola) &nbsp;&nbsp 224 <TR> <TD ALIGN=left>15.11 <TD ALIGN=left COLSPAN=2> Extremely Long Homogeneous Pipeline (Xelerated) &nbsp;&nbsp 228 <TR> <TD ALIGN=left>15.12 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 228 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 229<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 229<BR> </TABLE> <BR> <BR> <H3>Chapter 16 &nbsp; Design Tradeoffs And Consequences &nbsp;&nbsp; 233</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>16.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 233 <TR> <TD ALIGN=left>16.2 <TD ALIGN=left COLSPAN=2> Low Development Cost Vs. Performance &nbsp;&nbsp 233 <TR> <TD ALIGN=left>16.3 <TD ALIGN=left COLSPAN=2> Programmability Vs. Processing Speed &nbsp;&nbsp 234 <TR> <TD ALIGN=left>16.4 <TD ALIGN=left COLSPAN=2> Performance: Packet Rate, Data Rate, And Bursts &nbsp;&nbsp 234 <TR> <TD ALIGN=left>16.5 <TD ALIGN=left COLSPAN=2> Speed Vs. Functionality &nbsp;&nbsp 235 <TR> <TD ALIGN=left>16.6 <TD ALIGN=left COLSPAN=2> Per-Interface Rate Vs. Aggregate Data Rate &nbsp;&nbsp 235 <TR> <TD ALIGN=left>16.7 <TD ALIGN=left COLSPAN=2> Network Processor Speed Vs. Bandwidth &nbsp;&nbsp 235 <TR> <TD ALIGN=left>16.8 <TD ALIGN=left COLSPAN=2> Coprocessor Design: Lookaside Vs. Flow-Through &nbsp;&nbsp 236 <TR> <TD ALIGN=left>16.9 <TD ALIGN=left COLSPAN=2> Pipelining: Uniform Vs. Synchronized &nbsp;&nbsp 236 <TR> <TD ALIGN=left>16.10 <TD ALIGN=left COLSPAN=2> Explicit Parallelism Vs. Cost And Programmability &nbsp;&nbsp 236 <TR> <TD ALIGN=left>16.11 <TD ALIGN=left COLSPAN=2> Parallelism: Scale Vs. Packet Ordering &nbsp;&nbsp 237 <TR> <TD ALIGN=left>16.12 <TD ALIGN=left COLSPAN=2> Parallelism: Speed Vs. Stateful Classification &nbsp;&nbsp 237 <TR> <TD ALIGN=left>16.13 <TD ALIGN=left COLSPAN=2> Memory: Speed Vs. Programmability &nbsp;&nbsp 237 <TR> <TD ALIGN=left>16.14 <TD ALIGN=left COLSPAN=2> I/O Performance Vs. Pin Count &nbsp;&nbsp 238 <TR> <TD ALIGN=left>16.15 <TD ALIGN=left COLSPAN=2> Programming Languages: A Three-Way Tradeoff &nbsp;&nbsp 238 <TR> <TD ALIGN=left>16.16 <TD ALIGN=left COLSPAN=2> Multithreading: Throughput Vs. Programmability &nbsp;&nbsp 238 <TR> <TD ALIGN=left>16.17 <TD ALIGN=left COLSPAN=2> Traffic Management Vs. Blind Forwarding At Low Cost &nbsp;&nbsp 239 <TR> <TD ALIGN=left>16.18 <TD ALIGN=left COLSPAN=2> Generality Vs. Specific Architectural Role &nbsp;&nbsp 239 <TR> <TD ALIGN=left>16.19 <TD ALIGN=left COLSPAN=2> Memory Type: Special-Purpose Vs. General-Purpose &nbsp;&nbsp 239 <TR> <TD ALIGN=left>16.20 <TD ALIGN=left COLSPAN=2> Backward Compatibility Vs. Architectural Advances &nbsp;&nbsp 240 <TR> <TD ALIGN=left>16.21 <TD ALIGN=left COLSPAN=2> Parallelism Vs. Pipelining &nbsp;&nbsp 240 <TR> <TD ALIGN=left>16.22 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 241 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 241<BR> </TABLE> <BR> <BR><H3> PART III &nbsp;&nbsp; Example Network Processor &nbsp;&nbsp; 243</H3> <BR> <H3>Chapter 17 &nbsp; Overview Of The Intel Network Processor &nbsp;&nbsp; 245</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>17.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 245 <TR> <TD ALIGN=left>17.2 <TD ALIGN=left COLSPAN=2> Intel Terminology &nbsp;&nbsp 245 <TR> <TD ALIGN=left>17.3 <TD ALIGN=left COLSPAN=2> IXA: Internet Exchange Architecture &nbsp;&nbsp 246 <TR> <TD ALIGN=left>17.4 <TD ALIGN=left COLSPAN=2> IXP: Internet Exchange Processor &nbsp;&nbsp 246 <TR> <TD ALIGN=left>17.5 <TD ALIGN=left COLSPAN=2> Basic IXP2xxx Features &nbsp;&nbsp 247 <TR> <TD ALIGN=left>17.6 <TD ALIGN=left COLSPAN=2> External Connections &nbsp;&nbsp 248 <TR> <TD ALIGN=left> <TD ALIGN=left>17.6.1 <TD ALIGN=left> Serial Line Interface &nbsp;&nbsp 249 <TR> <TD ALIGN=left> <TD ALIGN=left>17.6.2 <TD ALIGN=left> PCI Bus &nbsp;&nbsp 249 <TR> <TD ALIGN=left> <TD ALIGN=left>17.6.3 <TD ALIGN=left> Media Switch Fabric Interface &nbsp;&nbsp 249 <TR> <TD ALIGN=left> <TD ALIGN=left>17.6.4 <TD ALIGN=left> DRAM Bus &nbsp;&nbsp 250 <TR> <TD ALIGN=left> <TD ALIGN=left>17.6.5 <TD ALIGN=left> SRAM Buses &nbsp;&nbsp 250 <TR> <TD ALIGN=left> <TD ALIGN=left>17.6.6 <TD ALIGN=left> Slowport Bus &nbsp;&nbsp 250 <TR> <TD ALIGN=left>17.7 <TD ALIGN=left COLSPAN=2> Internal Components &nbsp;&nbsp 250 <TR> <TD ALIGN=left>17.8 <TD ALIGN=left COLSPAN=2> IXP2xxx Processor Hierarchy &nbsp;&nbsp 252 <TR> <TD ALIGN=left> <TD ALIGN=left>17.8.1 <TD ALIGN=left> General-Purpose Processor &nbsp;&nbsp 253 <TR> <TD ALIGN=left> <TD ALIGN=left>17.8.2 <TD ALIGN=left> Embedded RISC Processor (XScale) &nbsp;&nbsp 253 <TR> <TD ALIGN=left> <TD ALIGN=left>17.8.3 <TD ALIGN=left> I^/^O Processors (Microengines) &nbsp;&nbsp 253 <TR> <TD ALIGN=left> <TD ALIGN=left>17.8.4 <TD ALIGN=left> Coprocessors And Other Functional Units &nbsp;&nbsp 254 <TR> <TD ALIGN=left> <TD ALIGN=left>17.8.5 <TD ALIGN=left> Physical Interface Processors &nbsp;&nbsp 254 <TR> <TD ALIGN=left>17.9 <TD ALIGN=left COLSPAN=2> IXP2xxx Memories &nbsp;&nbsp 254 <TR> <TD ALIGN=left>17.10 <TD ALIGN=left COLSPAN=2> Word And Longword Accesses &nbsp;&nbsp 256 <TR> <TD ALIGN=left>17.11 <TD ALIGN=left COLSPAN=2> An Example Of Underlying Complexity &nbsp;&nbsp 257 <TR> <TD ALIGN=left>17.12 <TD ALIGN=left COLSPAN=2> Other Hardware Facilities &nbsp;&nbsp 258 <TR> <TD ALIGN=left>17.13 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 258 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 259<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 259<BR> </TABLE> <BR> <BR> <H3>Chapter 18 &nbsp; Embedded RISC Processor (XScale Core) &nbsp;&nbsp; 261</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>18.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 261 <TR> <TD ALIGN=left>18.2 <TD ALIGN=left COLSPAN=2> Purpose Of An Embedded Processor &nbsp;&nbsp 261 <TR> <TD ALIGN=left>18.3 <TD ALIGN=left COLSPAN=2> XScale Architecture &nbsp;&nbsp 263 <TR> <TD ALIGN=left>18.4 <TD ALIGN=left COLSPAN=2> RISC Instruction Set And Registers &nbsp;&nbsp 264 <TR> <TD ALIGN=left>18.5 <TD ALIGN=left COLSPAN=2> XScale Memory Architecture &nbsp;&nbsp 264 <TR> <TD ALIGN=left>18.6 <TD ALIGN=left COLSPAN=2> XScale Memory Map &nbsp;&nbsp 265 <TR> <TD ALIGN=left>18.7 <TD ALIGN=left COLSPAN=2> Virtual Address Space And Memory Management &nbsp;&nbsp 265 <TR> <TD ALIGN=left>18.8 <TD ALIGN=left COLSPAN=2> Shared Memory And Address Translation &nbsp;&nbsp 266 <TR> <TD ALIGN=left>18.9 <TD ALIGN=left COLSPAN=2> Internal Peripheral Units &nbsp;&nbsp 267 <TR> <TD ALIGN=left> <TD ALIGN=left>18.9.1 <TD ALIGN=left> Serial Connection Through UART Hardware &nbsp;&nbsp 267 <TR> <TD ALIGN=left> <TD ALIGN=left>18.9.2 <TD ALIGN=left> Countdown Timers &nbsp;&nbsp 268 <TR> <TD ALIGN=left> <TD ALIGN=left>18.9.3 <TD ALIGN=left> General-Purpose I/O Pins &nbsp;&nbsp 268 <TR> <TD ALIGN=left>18.10 <TD ALIGN=left COLSPAN=2> Other I/O &nbsp;&nbsp 268 <TR> <TD ALIGN=left>18.11 <TD ALIGN=left COLSPAN=2> User And Kernel Mode Operation &nbsp;&nbsp 268 <TR> <TD ALIGN=left>18.12 <TD ALIGN=left COLSPAN=2> Coprocessor 15 &nbsp;&nbsp 269 <TR> <TD ALIGN=left>18.13 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 269 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 269<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 270<BR> </TABLE> <BR> <BR> <H3>Chapter 19 &nbsp; Packet Processor Hardware (Microengines) &nbsp;&nbsp; 273</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>19.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 273 <TR> <TD ALIGN=left>19.2 <TD ALIGN=left COLSPAN=2> The Purpose Of Microengines &nbsp;&nbsp 273 <TR> <TD ALIGN=left>19.3 <TD ALIGN=left COLSPAN=2> Microengine Architecture &nbsp;&nbsp 274 <TR> <TD ALIGN=left>19.4 <TD ALIGN=left COLSPAN=2> The Concept Of Microsequencing &nbsp;&nbsp 274 <TR> <TD ALIGN=left>19.5 <TD ALIGN=left COLSPAN=2> Microengine Instruction Set &nbsp;&nbsp 275 <TR> <TD ALIGN=left>19.6 <TD ALIGN=left COLSPAN=2> Separate Memory Address Spaces &nbsp;&nbsp 277 <TR> <TD ALIGN=left>19.7 <TD ALIGN=left COLSPAN=2> Execution Pipeline &nbsp;&nbsp 278 <TR> <TD ALIGN=left>19.8 <TD ALIGN=left COLSPAN=2> The Concept Of Instruction Stalls &nbsp;&nbsp 279 <TR> <TD ALIGN=left>19.9 <TD ALIGN=left COLSPAN=2> Conditional Branching And Pipeline Abort &nbsp;&nbsp 281 <TR> <TD ALIGN=left>19.10 <TD ALIGN=left COLSPAN=2> Memory Access Delay &nbsp;&nbsp 281 <TR> <TD ALIGN=left>19.11 <TD ALIGN=left COLSPAN=2> Hardware Threads And Context Switching &nbsp;&nbsp 282 <TR> <TD ALIGN=left>19.12 <TD ALIGN=left COLSPAN=2> Microengine Instruction Store &nbsp;&nbsp 284 <TR> <TD ALIGN=left>19.13 <TD ALIGN=left COLSPAN=2> Microengine Hardware Registers &nbsp;&nbsp 285 <TR> <TD ALIGN=left>19.14 <TD ALIGN=left COLSPAN=2> General-Purpose Registers &nbsp;&nbsp 285 <TR> <TD ALIGN=left> <TD ALIGN=left>19.14.1 <TD ALIGN=left> Context-Relative Vs. Absolute Registers &nbsp;&nbsp 285 <TR> <TD ALIGN=left> <TD ALIGN=left>19.14.2 <TD ALIGN=left> Register Banks &nbsp;&nbsp 285 <TR> <TD ALIGN=left>19.15 <TD ALIGN=left COLSPAN=2> Transfer Registers &nbsp;&nbsp 287 <TR> <TD ALIGN=left>19.16 <TD ALIGN=left COLSPAN=2> Next Neighbor Registers And Software Pipeline &nbsp;&nbsp 287 <TR> <TD ALIGN=left>19.17 <TD ALIGN=left COLSPAN=2> Local Memory &nbsp;&nbsp 288 <TR> <TD ALIGN=left>19.18 <TD ALIGN=left COLSPAN=2> Content Addressable Memory (CAM) &nbsp;&nbsp 289 <TR> <TD ALIGN=left>19.19 <TD ALIGN=left COLSPAN=2> Local Control And Status Registers (CSRs) &nbsp;&nbsp 290 <TR> <TD ALIGN=left>19.20 <TD ALIGN=left COLSPAN=2> Inter-Processor Communication &nbsp;&nbsp 290 <TR> <TD ALIGN=left>19.21 <TD ALIGN=left COLSPAN=2> SHaC Unit &nbsp;&nbsp 291 <TR> <TD ALIGN=left>19.22 <TD ALIGN=left COLSPAN=2> SHaC Architecture &nbsp;&nbsp 292 <TR> <TD ALIGN=left>19.23 <TD ALIGN=left COLSPAN=2> Scratchpad Memory &nbsp;&nbsp 293 <TR> <TD ALIGN=left>19.24 <TD ALIGN=left COLSPAN=2> Hash Unit &nbsp;&nbsp 293 <TR> <TD ALIGN=left>19.25 <TD ALIGN=left COLSPAN=2> Configuration, Control, And Status Registers &nbsp;&nbsp 295 <TR> <TD ALIGN=left>19.26 <TD ALIGN=left COLSPAN=2> Media Switch Fabric Interface &nbsp;&nbsp 296 <TR> <TD ALIGN=left>19.27 <TD ALIGN=left COLSPAN=2> Transmit And Receive BUFs &nbsp;&nbsp 296 <TR> <TD ALIGN=left>19.28 <TD ALIGN=left COLSPAN=2> Crypto Unit &nbsp;&nbsp 297 <TR> <TD ALIGN=left>19.29 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 298 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 298<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 299<BR> </TABLE> <BR> <BR> <H3>Chapter 20 &nbsp; Reference System And Software Development Kit (SDK) &nbsp;&nbsp; 301</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>20.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 301 <TR> <TD ALIGN=left>20.2 <TD ALIGN=left COLSPAN=2> Reference Systems &nbsp;&nbsp 301 <TR> <TD ALIGN=left>20.3 <TD ALIGN=left COLSPAN=2> The Intel Reference System &nbsp;&nbsp 302 <TR> <TD ALIGN=left> <TD ALIGN=left>20.3.1 <TD ALIGN=left> Intel's Hardware Testbed &nbsp;&nbsp 302 <TR> <TD ALIGN=left> <TD ALIGN=left>20.3.2 <TD ALIGN=left> Intel's SDK And Related Software &nbsp;&nbsp 303 <TR> <TD ALIGN=left>20.4 <TD ALIGN=left COLSPAN=2> Operating System Used On The XScale &nbsp;&nbsp 304 <TR> <TD ALIGN=left>20.5 <TD ALIGN=left COLSPAN=2> External Host Operating System And Workbench &nbsp;&nbsp 304 <TR> <TD ALIGN=left>20.6 <TD ALIGN=left COLSPAN=2> External File Access And Storage &nbsp;&nbsp 305 <TR> <TD ALIGN=left>20.7 <TD ALIGN=left COLSPAN=2> Bootstrapping The Reference Hardware &nbsp;&nbsp 306 <TR> <TD ALIGN=left>20.8 <TD ALIGN=left COLSPAN=2> Running Software &nbsp;&nbsp 306 <TR> <TD ALIGN=left>20.9 <TD ALIGN=left COLSPAN=2> System Reboot &nbsp;&nbsp 306 <TR> <TD ALIGN=left>20.10 <TD ALIGN=left COLSPAN=2> Alternative Cross-Development Software &nbsp;&nbsp 307 <TR> <TD ALIGN=left>20.11 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 307 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 308<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 308<BR> </TABLE> <BR> <BR> <H3>Chapter 21 &nbsp; Programming Model &nbsp;&nbsp; 311</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>21.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 311 <TR> <TD ALIGN=left>21.2 <TD ALIGN=left COLSPAN=2> Support Software And Overall Structure &nbsp;&nbsp 311 <TR> <TD ALIGN=left>21.3 <TD ALIGN=left COLSPAN=2> Pieces Of Software &nbsp;&nbsp 312 <TR> <TD ALIGN=left>21.4 <TD ALIGN=left COLSPAN=2> Microblocks, Interconnections, And Pipeline Organization &nbsp;&nbsp 312 <TR> <TD ALIGN=left>21.5 <TD ALIGN=left COLSPAN=2> Assignment Of Microblocks To Microengines &nbsp;&nbsp 313 <TR> <TD ALIGN=left>21.6 <TD ALIGN=left COLSPAN=2> Mpackets And Transfers &nbsp;&nbsp 313 <TR> <TD ALIGN=left>21.7 <TD ALIGN=left COLSPAN=2> Ingress (RX) And Egress (TX) Microblocks &nbsp;&nbsp 314 <TR> <TD ALIGN=left>21.8 <TD ALIGN=left COLSPAN=2> Microblocks And Parallel Execution &nbsp;&nbsp 314 <TR> <TD ALIGN=left>21.9 <TD ALIGN=left COLSPAN=2> Packet Buffers &nbsp;&nbsp 315 <TR> <TD ALIGN=left>21.10 <TD ALIGN=left COLSPAN=2> Buffer Queues And Buffer Allocation &nbsp;&nbsp 316 <TR> <TD ALIGN=left>21.11 <TD ALIGN=left COLSPAN=2> Buffer Handles And Packet Discard &nbsp;&nbsp 318 <TR> <TD ALIGN=left>21.12 <TD ALIGN=left COLSPAN=2> Packet Forwarding And Memory Rings &nbsp;&nbsp 319 <TR> <TD ALIGN=left>21.13 <TD ALIGN=left COLSPAN=2> Queue Array Hardware And Spilling &nbsp;&nbsp 320 <TR> <TD ALIGN=left>21.14 <TD ALIGN=left COLSPAN=2> Exceptions, Core Components, And XScale Processing &nbsp;&nbsp 321 <TR> <TD ALIGN=left>21.15 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 321 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 322<BR> </TABLE> <BR> <BR> <H3>Chapter 22 &nbsp; XScale Facilities &nbsp;&nbsp; 325</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>22.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 325 <TR> <TD ALIGN=left>22.2 <TD ALIGN=left COLSPAN=2> XScale Responsibilities &nbsp;&nbsp 325 <TR> <TD ALIGN=left>22.3 <TD ALIGN=left COLSPAN=2> Conceptual Organization Of XScale Software &nbsp;&nbsp 326 <TR> <TD ALIGN=left>22.4 <TD ALIGN=left COLSPAN=2> Core Component Infrastructure (CCI) &nbsp;&nbsp 326 <TR> <TD ALIGN=left>22.5 <TD ALIGN=left COLSPAN=2> Resource Manager (RM) &nbsp;&nbsp 327 <TR> <TD ALIGN=left>22.6 <TD ALIGN=left COLSPAN=2> Operating System Specific Library (OSSL) &nbsp;&nbsp 328 <TR> <TD ALIGN=left>22.7 <TD ALIGN=left COLSPAN=2> Hardware Abstraction Layer (HAL) &nbsp;&nbsp 328 <TR> <TD ALIGN=left>22.8 <TD ALIGN=left COLSPAN=2> Memory Management &nbsp;&nbsp 328 <TR> <TD ALIGN=left>22.9 <TD ALIGN=left COLSPAN=2> Allocation Of Local Memory &nbsp;&nbsp 330 <TR> <TD ALIGN=left>22.10 <TD ALIGN=left COLSPAN=2> Address Translation &nbsp;&nbsp 330 <TR> <TD ALIGN=left>22.11 <TD ALIGN=left COLSPAN=2> Ring And Queue Interface &nbsp;&nbsp 331 <TR> <TD ALIGN=left>22.12 <TD ALIGN=left COLSPAN=2> Buffer Management Facilities &nbsp;&nbsp 332 <TR> <TD ALIGN=left>22.13 <TD ALIGN=left COLSPAN=2> Organization Of Core Software &nbsp;&nbsp 332 <TR> <TD ALIGN=left>22.14 <TD ALIGN=left COLSPAN=2> Patching Symbols And Loading Microcode &nbsp;&nbsp 334 <TR> <TD ALIGN=left>22.15 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 336 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 336<BR> </TABLE> <BR> <BR> <H3>Chapter 23 &nbsp; Microengine Programming I &nbsp;&nbsp; 339</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>23.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 339 <TR> <TD ALIGN=left>23.2 <TD ALIGN=left COLSPAN=2> Intel's Microengine Assembler &nbsp;&nbsp 339 <TR> <TD ALIGN=left>23.3 <TD ALIGN=left COLSPAN=2> Microengine Assembly Language Syntax &nbsp;&nbsp 340 <TR> <TD ALIGN=left>23.4 <TD ALIGN=left COLSPAN=2> Example Operand Syntax &nbsp;&nbsp 341 <TR> <TD ALIGN=left>23.5 <TD ALIGN=left COLSPAN=2> Symbolic Register Names And Allocation &nbsp;&nbsp 344 <TR> <TD ALIGN=left>23.6 <TD ALIGN=left COLSPAN=2> Register Types And Syntax &nbsp;&nbsp 345 <TR> <TD ALIGN=left>23.7 <TD ALIGN=left COLSPAN=2> Local Register Scope, Nesting, And Shadowing &nbsp;&nbsp 346 <TR> <TD ALIGN=left>23.8 <TD ALIGN=left COLSPAN=2> Register Assignments And Conflicts &nbsp;&nbsp 347 <TR> <TD ALIGN=left>23.9 <TD ALIGN=left COLSPAN=2> The Macro Preprocessor &nbsp;&nbsp 348 <TR> <TD ALIGN=left>23.10 <TD ALIGN=left COLSPAN=2> Macro Definition &nbsp;&nbsp 348 <TR> <TD ALIGN=left>23.11 <TD ALIGN=left COLSPAN=2> Repeated Generation Of A Code Segment &nbsp;&nbsp 350 <TR> <TD ALIGN=left>23.12 <TD ALIGN=left COLSPAN=2> Structured Programming Directives &nbsp;&nbsp 351 <TR> <TD ALIGN=left>23.13 <TD ALIGN=left COLSPAN=2> Instructions That Can Cause A Context Switch &nbsp;&nbsp 353 <TR> <TD ALIGN=left>23.14 <TD ALIGN=left COLSPAN=2> Indirect Reference &nbsp;&nbsp 354 <TR> <TD ALIGN=left>23.15 <TD ALIGN=left COLSPAN=2> External Transfers &nbsp;&nbsp 355 <TR> <TD ALIGN=left>23.16 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 356 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 357<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 357<BR> </TABLE> <BR> <BR> <H3>Chapter 24 &nbsp; Microengine Programming II &nbsp;&nbsp; 359</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>24.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 359 <TR> <TD ALIGN=left>24.2 <TD ALIGN=left COLSPAN=2> Specialized Memory Operations &nbsp;&nbsp 359 <TR> <TD ALIGN=left>24.3 <TD ALIGN=left COLSPAN=2> Ring And Queue Manipulation &nbsp;&nbsp 360 <TR> <TD ALIGN=left>24.4 <TD ALIGN=left COLSPAN=2> Processor Coordination Via Bit Testing &nbsp;&nbsp 360 <TR> <TD ALIGN=left>24.5 <TD ALIGN=left COLSPAN=2> Atomic Memory Operations &nbsp;&nbsp 361 <TR> <TD ALIGN=left>24.6 <TD ALIGN=left COLSPAN=2> Critical Sections And Folding &nbsp;&nbsp 362 <TR> <TD ALIGN=left>24.7 <TD ALIGN=left COLSPAN=2> Control And Status Registers &nbsp;&nbsp 364 <TR> <TD ALIGN=left>24.8 <TD ALIGN=left COLSPAN=2> Intel Dispatch Loop Macros &nbsp;&nbsp 365 <TR> <TD ALIGN=left>24.9 <TD ALIGN=left COLSPAN=2> Traffic Management And Packet Scheduling &nbsp;&nbsp 366 <TR> <TD ALIGN=left>24.10 <TD ALIGN=left COLSPAN=2> Accessing Fields In A Packet Header &nbsp;&nbsp 366 <TR> <TD ALIGN=left>24.11 <TD ALIGN=left COLSPAN=2> Dispatch Loop And Associated Variables &nbsp;&nbsp 368 <TR> <TD ALIGN=left>24.12 <TD ALIGN=left COLSPAN=2> Header Caching &nbsp;&nbsp 369 <TR> <TD ALIGN=left>24.13 <TD ALIGN=left COLSPAN=2> Packet I/O And The Concept Of Mpackets &nbsp;&nbsp 369 <TR> <TD ALIGN=left>24.14 <TD ALIGN=left COLSPAN=2> Ingress And Egress Packet Transfer &nbsp;&nbsp 370 <TR> <TD ALIGN=left>24.15 <TD ALIGN=left COLSPAN=2> I/O Details &nbsp;&nbsp 371 <TR> <TD ALIGN=left>24.16 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 372 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 373<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 373<BR> </TABLE> <BR> <BR> <H3>Chapter 25 &nbsp; An Example System &nbsp;&nbsp; 375</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>25.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 375 <TR> <TD ALIGN=left>25.2 <TD ALIGN=left COLSPAN=2> An Example Implementation Of NAT &nbsp;&nbsp 375 <TR> <TD ALIGN=left>25.3 <TD ALIGN=left COLSPAN=2> NAT Complexity And Simplifying Assumptions &nbsp;&nbsp 377 <TR> <TD ALIGN=left>25.4 <TD ALIGN=left COLSPAN=2> Network Address And Port Translation &nbsp;&nbsp 377 <TR> <TD ALIGN=left>25.5 <TD ALIGN=left COLSPAN=2> Ping Packets And Identifiers &nbsp;&nbsp 378 <TR> <TD ALIGN=left>25.6 <TD ALIGN=left COLSPAN=2> Dynamic NAT Table Creation And Management &nbsp;&nbsp 378 <TR> <TD ALIGN=left>25.7 <TD ALIGN=left COLSPAN=2> Organization Of The Code &nbsp;&nbsp 379 <TR> <TD ALIGN=left>25.8 <TD ALIGN=left COLSPAN=2> ARP Processing &nbsp;&nbsp 381 <TR> <TD ALIGN=left>25.9 <TD ALIGN=left COLSPAN=2> Implementation Of The NAT Microblock &nbsp;&nbsp 382 <TR> <TD ALIGN=left>25.10 <TD ALIGN=left COLSPAN=2> Header Caching And Alignment &nbsp;&nbsp 384 <TR> <TD ALIGN=left>25.11 <TD ALIGN=left COLSPAN=2> NAT Table Lookup &nbsp;&nbsp 384 <TR> <TD ALIGN=left>25.12 <TD ALIGN=left COLSPAN=2> Header Fields That NAT Changes &nbsp;&nbsp 387 <TR> <TD ALIGN=left>25.13 <TD ALIGN=left COLSPAN=2> Definition Of Constants For The Entire System &nbsp;&nbsp 388 <TR> <TD ALIGN=left>25.14 <TD ALIGN=left COLSPAN=2> Constants And Types For The User Interface &nbsp;&nbsp 390 <TR> <TD ALIGN=left>25.15 <TD ALIGN=left COLSPAN=2> Definitions Of Scratch Ring Constants &nbsp;&nbsp 391 <TR> <TD ALIGN=left>25.16 <TD ALIGN=left COLSPAN=2> Overall Organization Of The NAT Microblock &nbsp;&nbsp 392 <TR> <TD ALIGN=left>25.17 <TD ALIGN=left COLSPAN=2> Macros Used To Implement NAT &nbsp;&nbsp 400 <TR> <TD ALIGN=left>25.18 <TD ALIGN=left COLSPAN=2> Optimized ARP Table Lookup &nbsp;&nbsp 410 <TR> <TD ALIGN=left>25.19 <TD ALIGN=left COLSPAN=2> Header Modification And Checksum Computation &nbsp;&nbsp 410 <TR> <TD ALIGN=left>25.20 <TD ALIGN=left COLSPAN=2> Core Component &nbsp;&nbsp 411 <TR> <TD ALIGN=left>25.21 <TD ALIGN=left COLSPAN=2> Core Component Initialization &nbsp;&nbsp 411 <TR> <TD ALIGN=left> <TD ALIGN=left>25.21.1 <TD ALIGN=left> Device Registration &nbsp;&nbsp 411 <TR> <TD ALIGN=left> <TD ALIGN=left>25.21.2 <TD ALIGN=left> Other Initialization &nbsp;&nbsp 411 <TR> <TD ALIGN=left> <TD ALIGN=left>25.21.3 <TD ALIGN=left> Patching And Loading Microcode &nbsp;&nbsp 412 <TR> <TD ALIGN=left> <TD ALIGN=left>25.21.4 <TD ALIGN=left> Scratch Rings And Interfaces &nbsp;&nbsp 413 <TR> <TD ALIGN=left> <TD ALIGN=left>25.21.5 <TD ALIGN=left> Hash Engine Initialization &nbsp;&nbsp 413 <TR> <TD ALIGN=left> <TD ALIGN=left>25.21.6 <TD ALIGN=left> Starting Microengines And A Timer Thread &nbsp;&nbsp 413 <TR> <TD ALIGN=left>25.22 <TD ALIGN=left COLSPAN=2> Core Component Packet Processing &nbsp;&nbsp 413 <TR> <TD ALIGN=left>25.23 <TD ALIGN=left COLSPAN=2> Cleanup &nbsp;&nbsp 414 <TR> <TD ALIGN=left>25.24 <TD ALIGN=left COLSPAN=2> Structure Of The Core Component Kernel Module &nbsp;&nbsp 415 <TR> <TD ALIGN=left> <TD ALIGN=left>25.24.1 <TD ALIGN=left> Protocol Declarations Used By The Core Component &nbsp;&nbsp 415 <TR> <TD ALIGN=left> <TD ALIGN=left>25.24.2 <TD ALIGN=left> Core Component Initialization And Pseudo Device &nbsp;&nbsp 417 <TR> <TD ALIGN=left> <TD ALIGN=left>25.24.3 <TD ALIGN=left> Core Component Packet Handler &nbsp;&nbsp 431 <TR> <TD ALIGN=left>25.25 <TD ALIGN=left COLSPAN=2> User Interface Application Code &nbsp;&nbsp 445 <TR> <TD ALIGN=left>25.26 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 449 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 449<BR> </TABLE> <BR> <BR><H3> Appendix 1 &nbsp; Glossary Of Terms And Abbreviations &nbsp;&nbsp; 452</H3> <BR><H3> Bibliography &nbsp;&nbsp;499</H3> <BR><H3> Index &nbsp;&nbsp;503</H3> </UL></UL> </BODY> </BODY>
</DOC>
