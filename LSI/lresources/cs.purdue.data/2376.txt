<DOC>
<DOCNO> http://www.cs.purdue.edu/homes/ayg/CS590D/assignments/one.ans.html </DOCNO>
<HTML><HEAD><TITLE>Assignment #1 (Solution Sketches)</TITLE></HEAD> <BODY BGCOLOR="ffffff"> </HEAD> <BR> <H2>Assignment #1 (Solution Sketches)</H2> <B>Date Assigned:</B> Friday, Jan. 23, 1998<BR> <B>Date Due:</B> Friday, Feb. 6, 1998<BR> <HR NOSHADE SIZE=2> <P><!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN"></P> <ol> <li> <pre><B> query1(X,Y,Z) :- works(X,"First Bank Corporation", S), S>10000, lives(X,Y,Z). query2(X) :- manages(X,Y), lives(X,S,C), lives(Y,S,C). query3(X) :- query4(X) :- manages(X,"Kathy"). qeury4(X) :- manages(X,Y), query4(Y). </b></pre> </p>While queries 1,2 and 3 could be expressed very succinctly in RDBMSs, the relational model is not expressive enough for expressing recursive queries like 4. This requires the logical model of database systems.</P> And PROLOG fails to work for the <tt><B>ancestor</B></tt> problem because it goes into an infinite loop trying to satisfy it, from the order in which we have given the clauses. This has to do (i) with the left recursive way in which the first clause is written and (ii) the depth-first nature of PROLOG's search strategy. A simple reordering of the terms will rectify the situation. </P> <hr> <li>The first thing to note from this exercise is that we are trying to do some kind of non-monotonic inference. This process is referred to as abduction where given that the consequent of an implication is true, we wish to say with some degree of confidence that the antecedent is indeed also true. Notice that the other way is pure logic based deduction. This behavior is very useful for diagnostic expert systems, as mentioned in the question. </P> In a strange way, at least to some extent, PROLOG implements a non-monotonic kind of behavior (not really abductive). One reason is because of the "closed-world" assumption that makes it treat <b>negation as failure.</B> In other words, if it is not able to prove something, it certifies that it is false. For the given facts, <pre><B> nostart(X) :- nogas(X). nostart(pontiac). </b></pre> If we make the query <tt><B>nogas(pontiac)</b></tt>, we get the answer <tt><B>no</b></tt>, meaning that such a fact does not exist in the database. If we were to add the fact <tt><B>nogas(pontiac)</B></tt>, then we will get an answer "yes" for the same query. The databse then will look like: <pre><B> nostart(X) :- nogas(X). nostart(pontiac). nogas(pontiac). </b></pre> Notice that now the second fact becomes redundant because it can be inferred from the first and the third. In this sense, PROLOG is safe to treat "negation as failure" as the extended database is closed under inference. That is, doing any new inference does not contradict old information. I must caution that these are really murky waters because it is not trivial to compute extensions to a database so that it remains closed under inference.</P> To do the kind of abductive reasoning that we are talking about, we need to resort to the inductive capabilities of a system like PROGOL. Notice that in a system like PROGOL, the process of rule induction follows the equation <b>Induction = Abduction + Justification</B>. In other words, abduction is used to construct a "plausible" hypothesis, then the system tries to justify the abduction by determining factors such as cover, degree-of-confidence before accepting them as intensional knowledge.<BR> <BR> <hr> <li>Here's a <a href="gcd.pl">solution</a> for the gcd exercise. It is self-explanatory.<BR> <hr> <li>Here's a very good <a href="ver.ps">solution</a> by Vassilios Verykios.<BR> <BR> </ul> </ol> <BR> </P> <HR NOSHADE SIZE=2> </P> <A HREF="../index.html"><IMG SRC="../images/returnhome.gif" ALT="Return Home" BORDER=0></A> </BODY></HTML> </BODY></HTML>
</DOC>
