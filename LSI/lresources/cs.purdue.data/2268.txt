<DOC>
<DOCNO> http://www.cs.purdue.edu/homes/dec/tcpip2.cont.html </DOCNO>
<HTML> <HEAD> <TITLE> vol2 contents </TITLE> </HEAD> <BODY> <CENTER> <H2> Table of Contents For <BR><BR> Internetworking With TCP/IP &nbsp;&nbsp; Volume 2<BR><BR> 3rd Edition <BR><BR> </H2> </CENTER> <UL><UL> <BR><H3> Foreword &nbsp;&nbsp;xvii</H3> <BR><H3> Preface &nbsp;&nbsp;xix</H3> <BR> <H3>Chapter 1 &nbsp; Introduction And Overview &nbsp;&nbsp; 1</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>1.1 <TD ALIGN=left COLSPAN=2> TCP/IP Protocols &nbsp;&nbsp 1 <TR> <TD ALIGN=left>1.2 <TD ALIGN=left COLSPAN=2> The Need To Understand Details &nbsp;&nbsp 1 <TR> <TD ALIGN=left>1.3 <TD ALIGN=left COLSPAN=2> Complexity Of Interactions Among Protocols &nbsp;&nbsp 2 <TR> <TD ALIGN=left>1.4 <TD ALIGN=left COLSPAN=2> The Approach In This Text &nbsp;&nbsp 2 <TR> <TD ALIGN=left>1.5 <TD ALIGN=left COLSPAN=2> The Importance Of Studying Code &nbsp;&nbsp 3 <TR> <TD ALIGN=left>1.6 <TD ALIGN=left COLSPAN=2> The Xinu Operating System &nbsp;&nbsp 3 <TR> <TD ALIGN=left>1.7 <TD ALIGN=left COLSPAN=2> Organization Of The Remainder Of The Book &nbsp;&nbsp 4 <TR> <TD ALIGN=left>1.8 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 4 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 5<BR> </TABLE> <BR> <BR> <H3>Chapter 2 &nbsp; The Structure Of TCP/IP Software In An Operating System &nbsp;&nbsp; 7</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>2.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 7 <TR> <TD ALIGN=left>2.2 <TD ALIGN=left COLSPAN=2> The Process Concept &nbsp;&nbsp 8 <TR> <TD ALIGN=left>2.3 <TD ALIGN=left COLSPAN=2> Process Priority &nbsp;&nbsp 9 <TR> <TD ALIGN=left>2.4 <TD ALIGN=left COLSPAN=2> Process Synchronization &nbsp;&nbsp 9 <TR> <TD ALIGN=left>2.5 <TD ALIGN=left COLSPAN=2> Interprocess Communication &nbsp;&nbsp 12 <TR> <TD ALIGN=left> <TD ALIGN=left>2.5.1 <TD ALIGN=left> Ports &nbsp;&nbsp 12 <TR> <TD ALIGN=left> <TD ALIGN=left>2.5.2 <TD ALIGN=left> Message Passing &nbsp;&nbsp 13 <TR> <TD ALIGN=left>2.6 <TD ALIGN=left COLSPAN=2> Device Drivers, Input, And Output &nbsp;&nbsp 14 <TR> <TD ALIGN=left>2.7 <TD ALIGN=left COLSPAN=2> Network Input and Interrupts &nbsp;&nbsp 14 <TR> <TD ALIGN=left>2.8 <TD ALIGN=left COLSPAN=2> Passing Packets To Higher Level Protocols &nbsp;&nbsp 16 <TR> <TD ALIGN=left>2.9 <TD ALIGN=left COLSPAN=2> Passing Datagrams From IP To Transport Protocols &nbsp;&nbsp 16 <TR> <TD ALIGN=left> <TD ALIGN=left>2.9.1 <TD ALIGN=left> Passing Incoming Datagrams to TCP &nbsp;&nbsp 17 <TR> <TD ALIGN=left> <TD ALIGN=left>2.9.2 <TD ALIGN=left> Passing Incoming Datagrams to UDP &nbsp;&nbsp 17 <TR> <TD ALIGN=left>2.10 <TD ALIGN=left COLSPAN=2> Delivery To Application Programs &nbsp;&nbsp 18 <TR> <TD ALIGN=left>2.11 <TD ALIGN=left COLSPAN=2> Information Flow On Output &nbsp;&nbsp 19 <TR> <TD ALIGN=left>2.12 <TD ALIGN=left COLSPAN=2> From TCP Through IP To Network Output &nbsp;&nbsp 20 <TR> <TD ALIGN=left>2.13 <TD ALIGN=left COLSPAN=2> UDP Output &nbsp;&nbsp 21 <TR> <TD ALIGN=left>2.14 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 21 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 25<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 25<BR> </TABLE> <BR> <BR> <H3>Chapter 3 &nbsp; Network Interface Layer &nbsp;&nbsp; 27</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>3.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 27 <TR> <TD ALIGN=left>3.2 <TD ALIGN=left COLSPAN=2> The Network Interface Abstraction &nbsp;&nbsp 28 <TR> <TD ALIGN=left> <TD ALIGN=left>3.2.1 <TD ALIGN=left> Interface Structure &nbsp;&nbsp 28 <TR> <TD ALIGN=left>3.3 <TD ALIGN=left COLSPAN=2> Ethernet Definitions &nbsp;&nbsp 30 <TR> <TD ALIGN=left> <TD ALIGN=left>3.3.1 <TD ALIGN=left> Statistics About Use &nbsp;&nbsp 34 <TR> <TD ALIGN=left>3.4 <TD ALIGN=left COLSPAN=2> Logical State Of An Interface &nbsp;&nbsp 34 <TR> <TD ALIGN=left>3.5 <TD ALIGN=left COLSPAN=2> Local Host Interface &nbsp;&nbsp 35 <TR> <TD ALIGN=left>3.6 <TD ALIGN=left COLSPAN=2> Buffer Management &nbsp;&nbsp 36 <TR> <TD ALIGN=left> <TD ALIGN=left>3.6.1 <TD ALIGN=left> Large Buffer Solution &nbsp;&nbsp 36 <TR> <TD ALIGN=left> <TD ALIGN=left>3.6.2 <TD ALIGN=left> Linked List Solutions (mbufs) &nbsp;&nbsp 36 <TR> <TD ALIGN=left> <TD ALIGN=left>3.6.3 <TD ALIGN=left> Our Example Solution &nbsp;&nbsp 37 <TR> <TD ALIGN=left> <TD ALIGN=left>3.6.4 <TD ALIGN=left> Other Buffer Issues &nbsp;&nbsp 37 <TR> <TD ALIGN=left>3.7 <TD ALIGN=left COLSPAN=2> Demultiplexing Incoming Packets &nbsp;&nbsp 38 <TR> <TD ALIGN=left>3.8 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 40 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 40<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 40<BR> </TABLE> <BR> <BR> <H3>Chapter 4 &nbsp; Address Discovery And Binding (ARP) &nbsp;&nbsp; 41</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>4.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 41 <TR> <TD ALIGN=left>4.2 <TD ALIGN=left COLSPAN=2> Conceptual Organization Of ARP Software &nbsp;&nbsp 42 <TR> <TD ALIGN=left>4.3 <TD ALIGN=left COLSPAN=2> Example ARP Design &nbsp;&nbsp 42 <TR> <TD ALIGN=left>4.4 <TD ALIGN=left COLSPAN=2> Data Structures For The ARP Cache &nbsp;&nbsp 43 <TR> <TD ALIGN=left>4.5 <TD ALIGN=left COLSPAN=2> ARP Output Processing &nbsp;&nbsp 46 <TR> <TD ALIGN=left> <TD ALIGN=left>4.5.1 <TD ALIGN=left> Searching The ARP Cache &nbsp;&nbsp 46 <TR> <TD ALIGN=left> <TD ALIGN=left>4.5.2 <TD ALIGN=left> Broadcasting An ARP Request &nbsp;&nbsp 47 <TR> <TD ALIGN=left> <TD ALIGN=left>4.5.3 <TD ALIGN=left> Output Procedure &nbsp;&nbsp 49 <TR> <TD ALIGN=left>4.6 <TD ALIGN=left COLSPAN=2> ARP Input Processing &nbsp;&nbsp 51 <TR> <TD ALIGN=left> <TD ALIGN=left>4.6.1 <TD ALIGN=left> Adding Resolved Entries To The Table &nbsp;&nbsp 51 <TR> <TD ALIGN=left> <TD ALIGN=left>4.6.2 <TD ALIGN=left> Sending Waiting Packets &nbsp;&nbsp 52 <TR> <TD ALIGN=left> <TD ALIGN=left>4.6.3 <TD ALIGN=left> ARP Input Procedure &nbsp;&nbsp 53 <TR> <TD ALIGN=left>4.7 <TD ALIGN=left COLSPAN=2> ARP Cache Management &nbsp;&nbsp 56 <TR> <TD ALIGN=left> <TD ALIGN=left>4.7.1 <TD ALIGN=left> Allocating A Cache Entry &nbsp;&nbsp 56 <TR> <TD ALIGN=left> <TD ALIGN=left>4.7.2 <TD ALIGN=left> Periodic Cache Maintenance &nbsp;&nbsp 58 <TR> <TD ALIGN=left> <TD ALIGN=left>4.7.3 <TD ALIGN=left> Deallocating Queued Packets &nbsp;&nbsp 59 <TR> <TD ALIGN=left>4.8 <TD ALIGN=left COLSPAN=2> ARP Initialization &nbsp;&nbsp 60 <TR> <TD ALIGN=left>4.9 <TD ALIGN=left COLSPAN=2> ARP Configuration Parameters &nbsp;&nbsp 61 <TR> <TD ALIGN=left>4.10 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 61 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 61<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 62<BR> </TABLE> <BR> <BR> <H3>Chapter 5 &nbsp; IP: Global Software Organization &nbsp;&nbsp; 63</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>5.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 63 <TR> <TD ALIGN=left>5.2 <TD ALIGN=left COLSPAN=2> The Central Switch &nbsp;&nbsp 63 <TR> <TD ALIGN=left>5.3 <TD ALIGN=left COLSPAN=2> IP Software Design &nbsp;&nbsp 64 <TR> <TD ALIGN=left>5.4 <TD ALIGN=left COLSPAN=2> IP Software Organization And Datagram Flow &nbsp;&nbsp 65 <TR> <TD ALIGN=left> <TD ALIGN=left>5.4.1 <TD ALIGN=left> A Policy For Selecting Incoming Datagrams &nbsp;&nbsp 65 <TR> <TD ALIGN=left> <TD ALIGN=left>5.4.2 <TD ALIGN=left> Allowing The IP Process To Block &nbsp;&nbsp 67 <TR> <TD ALIGN=left> <TD ALIGN=left>5.4.3 <TD ALIGN=left> Definitions Of Constants Used By IP &nbsp;&nbsp 71 <TR> <TD ALIGN=left> <TD ALIGN=left>5.4.4 <TD ALIGN=left> Checksum Computation &nbsp;&nbsp 74 <TR> <TD ALIGN=left> <TD ALIGN=left>5.4.5 <TD ALIGN=left> Handling Directed Broadcasts &nbsp;&nbsp 75 <TR> <TD ALIGN=left> <TD ALIGN=left>5.4.6 <TD ALIGN=left> Recognizing A Broadcast Address &nbsp;&nbsp 77 <TR> <TD ALIGN=left>5.5 <TD ALIGN=left COLSPAN=2> Byte-Ordering In The IP Header &nbsp;&nbsp 78 <TR> <TD ALIGN=left>5.6 <TD ALIGN=left COLSPAN=2> Sending A Datagram To IP &nbsp;&nbsp 80 <TR> <TD ALIGN=left> <TD ALIGN=left>5.6.1 <TD ALIGN=left> Sending Locally-Generated Datagrams &nbsp;&nbsp 80 <TR> <TD ALIGN=left> <TD ALIGN=left>5.6.2 <TD ALIGN=left> Sending Incoming Datagrams &nbsp;&nbsp 82 <TR> <TD ALIGN=left>5.7 <TD ALIGN=left COLSPAN=2> Table Maintenance &nbsp;&nbsp 83 <TR> <TD ALIGN=left>5.8 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 84 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 85<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 85<BR> </TABLE> <BR> <BR> <H3>Chapter 6 &nbsp; IP: Routing Table And Routing Algorithm &nbsp;&nbsp; 87</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>6.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 87 <TR> <TD ALIGN=left>6.2 <TD ALIGN=left COLSPAN=2> Route Maintenance And Lookup &nbsp;&nbsp 87 <TR> <TD ALIGN=left>6.3 <TD ALIGN=left COLSPAN=2> Routing Table Organization &nbsp;&nbsp 88 <TR> <TD ALIGN=left>6.4 <TD ALIGN=left COLSPAN=2> Routing Table Data Structures &nbsp;&nbsp 89 <TR> <TD ALIGN=left>6.5 <TD ALIGN=left COLSPAN=2> Origin Of Routes And Persistence &nbsp;&nbsp 91 <TR> <TD ALIGN=left>6.6 <TD ALIGN=left COLSPAN=2> Routing A Datagram &nbsp;&nbsp 91 <TR> <TD ALIGN=left> <TD ALIGN=left>6.6.1 <TD ALIGN=left> Utility Procedures &nbsp;&nbsp 91 <TR> <TD ALIGN=left> <TD ALIGN=left>6.6.2 <TD ALIGN=left> Obtaining A Route &nbsp;&nbsp 95 <TR> <TD ALIGN=left> <TD ALIGN=left>6.6.3 <TD ALIGN=left> Data Structure Initialization &nbsp;&nbsp 97 <TR> <TD ALIGN=left>6.7 <TD ALIGN=left COLSPAN=2> Periodic Routing Table Maintenance &nbsp;&nbsp 98 <TR> <TD ALIGN=left> <TD ALIGN=left>6.7.1 <TD ALIGN=left> Adding A Route &nbsp;&nbsp 100 <TR> <TD ALIGN=left> <TD ALIGN=left>6.7.2 <TD ALIGN=left> Deleting A Route &nbsp;&nbsp 103 <TR> <TD ALIGN=left>6.8 <TD ALIGN=left COLSPAN=2> IP Options Processing &nbsp;&nbsp 106 <TR> <TD ALIGN=left>6.9 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 107 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 107<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 108<BR> </TABLE> <BR> <BR> <H3>Chapter 7 &nbsp; IP: Fragmentation And Reassembly &nbsp;&nbsp; 109</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>7.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 109 <TR> <TD ALIGN=left>7.2 <TD ALIGN=left COLSPAN=2> Fragmenting Datagrams &nbsp;&nbsp 109 <TR> <TD ALIGN=left> <TD ALIGN=left>7.2.1 <TD ALIGN=left> Fragmenting Fragments &nbsp;&nbsp 110 <TR> <TD ALIGN=left>7.3 <TD ALIGN=left COLSPAN=2> Implementation Of Fragmentation &nbsp;&nbsp 110 <TR> <TD ALIGN=left> <TD ALIGN=left>7.3.1 <TD ALIGN=left> Sending One Fragment &nbsp;&nbsp 112 <TR> <TD ALIGN=left> <TD ALIGN=left>7.3.2 <TD ALIGN=left> Copying A Datagram Header &nbsp;&nbsp 113 <TR> <TD ALIGN=left>7.4 <TD ALIGN=left COLSPAN=2> Datagram Reassembly &nbsp;&nbsp 115 <TR> <TD ALIGN=left> <TD ALIGN=left>7.4.1 <TD ALIGN=left> Data Structures &nbsp;&nbsp 115 <TR> <TD ALIGN=left> <TD ALIGN=left>7.4.2 <TD ALIGN=left> Mutual Exclusion &nbsp;&nbsp 117 <TR> <TD ALIGN=left> <TD ALIGN=left>7.4.3 <TD ALIGN=left> Adding A Fragment To A List &nbsp;&nbsp 117 <TR> <TD ALIGN=left> <TD ALIGN=left>7.4.4 <TD ALIGN=left> Discarding During Overflow &nbsp;&nbsp 119 <TR> <TD ALIGN=left> <TD ALIGN=left>7.4.5 <TD ALIGN=left> Testing For A Complete Datagram &nbsp;&nbsp 121 <TR> <TD ALIGN=left> <TD ALIGN=left>7.4.6 <TD ALIGN=left> Building A Datagram From Fragments &nbsp;&nbsp 122 <TR> <TD ALIGN=left>7.5 <TD ALIGN=left COLSPAN=2> Maintenance Of Fragment Lists &nbsp;&nbsp 124 <TR> <TD ALIGN=left>7.6 <TD ALIGN=left COLSPAN=2> Initialization &nbsp;&nbsp 126 <TR> <TD ALIGN=left>7.7 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 126 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 127<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 127<BR> </TABLE> <BR> <BR> <H3>Chapter 8 &nbsp; IP: Error Processing (ICMP) &nbsp;&nbsp; 129</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>8.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 129 <TR> <TD ALIGN=left>8.2 <TD ALIGN=left COLSPAN=2> ICMP Message Formats &nbsp;&nbsp 129 <TR> <TD ALIGN=left>8.3 <TD ALIGN=left COLSPAN=2> Implementation Of ICMP Messages &nbsp;&nbsp 129 <TR> <TD ALIGN=left>8.4 <TD ALIGN=left COLSPAN=2> Handling Incoming ICMP Messages &nbsp;&nbsp 132 <TR> <TD ALIGN=left>8.5 <TD ALIGN=left COLSPAN=2> Handling An ICMP Redirect Message &nbsp;&nbsp 134 <TR> <TD ALIGN=left>8.6 <TD ALIGN=left COLSPAN=2> Setting A Subnet Mask &nbsp;&nbsp 135 <TR> <TD ALIGN=left>8.7 <TD ALIGN=left COLSPAN=2> Choosing A Source Address For An ICMP Packet &nbsp;&nbsp 137 <TR> <TD ALIGN=left>8.8 <TD ALIGN=left COLSPAN=2> Generating ICMP Error Messages &nbsp;&nbsp 138 <TR> <TD ALIGN=left>8.9 <TD ALIGN=left COLSPAN=2> Avoiding Errors About Errors &nbsp;&nbsp 141 <TR> <TD ALIGN=left>8.10 <TD ALIGN=left COLSPAN=2> Allocating A Buffer For ICMP &nbsp;&nbsp 142 <TR> <TD ALIGN=left>8.11 <TD ALIGN=left COLSPAN=2> The Data Portion Of An ICMP Message &nbsp;&nbsp 144 <TR> <TD ALIGN=left>8.12 <TD ALIGN=left COLSPAN=2> Generating An ICMP Redirect Message &nbsp;&nbsp 146 <TR> <TD ALIGN=left>8.13 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 147 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 147<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 147<BR> </TABLE> <BR> <BR> <H3>Chapter 9 &nbsp; IP: Multicast Processing (IGMP) &nbsp;&nbsp; 149</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>9.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 149 <TR> <TD ALIGN=left>9.2 <TD ALIGN=left COLSPAN=2> Maintaining Multicast Group Membership Information &nbsp;&nbsp 149 <TR> <TD ALIGN=left>9.3 <TD ALIGN=left COLSPAN=2> A Host Group Table &nbsp;&nbsp 150 <TR> <TD ALIGN=left>9.4 <TD ALIGN=left COLSPAN=2> Searching For A Host Group &nbsp;&nbsp 152 <TR> <TD ALIGN=left>9.5 <TD ALIGN=left COLSPAN=2> Adding A Host Group Entry To The Table &nbsp;&nbsp 153 <TR> <TD ALIGN=left>9.6 <TD ALIGN=left COLSPAN=2> Configuring The Network Interface For A Multicast Address &nbsp;&nbsp 155 <TR> <TD ALIGN=left>9.7 <TD ALIGN=left COLSPAN=2> Translation Between IP and Hardware Multicast Addresses &nbsp;&nbsp 157 <TR> <TD ALIGN=left>9.8 <TD ALIGN=left COLSPAN=2> Removing A Multicast Address From The Host Group Table &nbsp;&nbsp 159 <TR> <TD ALIGN=left>9.9 <TD ALIGN=left COLSPAN=2> Joining A Host Group &nbsp;&nbsp 160 <TR> <TD ALIGN=left>9.10 <TD ALIGN=left COLSPAN=2> Maintaining Contact With A Multicast Router &nbsp;&nbsp 161 <TR> <TD ALIGN=left>9.11 <TD ALIGN=left COLSPAN=2> Implementing IGMP Membership Reports &nbsp;&nbsp 163 <TR> <TD ALIGN=left>9.12 <TD ALIGN=left COLSPAN=2> Computing A Random Delay &nbsp;&nbsp 165 <TR> <TD ALIGN=left>9.13 <TD ALIGN=left COLSPAN=2> A Process To Send IGMP Reports &nbsp;&nbsp 166 <TR> <TD ALIGN=left>9.14 <TD ALIGN=left COLSPAN=2> Handling Incoming IGMP Messages &nbsp;&nbsp 167 <TR> <TD ALIGN=left>9.15 <TD ALIGN=left COLSPAN=2> Leaving A Host Group &nbsp;&nbsp 169 <TR> <TD ALIGN=left>9.16 <TD ALIGN=left COLSPAN=2> Initialization Of IGMP Data Structures &nbsp;&nbsp 170 <TR> <TD ALIGN=left>9.17 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 171 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 172<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 172<BR> </TABLE> <BR> <BR> <H3>Chapter 10 &nbsp; UDP: User Datagrams &nbsp;&nbsp; 173</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>10.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 173 <TR> <TD ALIGN=left>10.2 <TD ALIGN=left COLSPAN=2> UDP Ports And Demultiplexing &nbsp;&nbsp 173 <TR> <TD ALIGN=left> <TD ALIGN=left>10.2.1 <TD ALIGN=left> Ports Used For Pairwise Communication &nbsp;&nbsp 174 <TR> <TD ALIGN=left> <TD ALIGN=left>10.2.2 <TD ALIGN=left> Ports Used For Many-One Communication &nbsp;&nbsp 175 <TR> <TD ALIGN=left> <TD ALIGN=left>10.2.3 <TD ALIGN=left> Modes Of Operation &nbsp;&nbsp 175 <TR> <TD ALIGN=left> <TD ALIGN=left>10.2.4 <TD ALIGN=left> The Subtle Issue Of Demultiplexing &nbsp;&nbsp 175 <TR> <TD ALIGN=left>10.3 <TD ALIGN=left COLSPAN=2> UDP Input Processing &nbsp;&nbsp 177 <TR> <TD ALIGN=left> <TD ALIGN=left>10.3.1 <TD ALIGN=left> UDP Declarations &nbsp;&nbsp 177 <TR> <TD ALIGN=left> <TD ALIGN=left>10.3.2 <TD ALIGN=left> Incoming Datagram Queue Declarations &nbsp;&nbsp 179 <TR> <TD ALIGN=left> <TD ALIGN=left>10.3.3 <TD ALIGN=left> Mapping UDP Port Numbers To Queues &nbsp;&nbsp 181 <TR> <TD ALIGN=left> <TD ALIGN=left>10.3.4 <TD ALIGN=left> Allocating A Free Queue &nbsp;&nbsp 182 <TR> <TD ALIGN=left> <TD ALIGN=left>10.3.5 <TD ALIGN=left> Converting To And From Network Byte Order &nbsp;&nbsp 183 <TR> <TD ALIGN=left> <TD ALIGN=left>10.3.6 <TD ALIGN=left> Processing An Arriving Datagram &nbsp;&nbsp 184 <TR> <TD ALIGN=left> <TD ALIGN=left>10.3.7 <TD ALIGN=left> UDP Checksum Computation &nbsp;&nbsp 186 <TR> <TD ALIGN=left>10.4 <TD ALIGN=left COLSPAN=2> UDP Output Processing &nbsp;&nbsp 187 <TR> <TD ALIGN=left> <TD ALIGN=left>10.4.1 <TD ALIGN=left> Sending A UDP Datagram &nbsp;&nbsp 188 <TR> <TD ALIGN=left>10.5 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 190 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 191<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 191<BR> </TABLE> <BR> <BR> <H3>Chapter 11 &nbsp; TCP: Data Structures And Input Processing &nbsp;&nbsp; 193</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>11.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 193 <TR> <TD ALIGN=left>11.2 <TD ALIGN=left COLSPAN=2> Overview Of TCP Software &nbsp;&nbsp 194 <TR> <TD ALIGN=left>11.3 <TD ALIGN=left COLSPAN=2> Transmission Control Blocks &nbsp;&nbsp 194 <TR> <TD ALIGN=left>11.4 <TD ALIGN=left COLSPAN=2> TCP Segment Format &nbsp;&nbsp 199 <TR> <TD ALIGN=left>11.5 <TD ALIGN=left COLSPAN=2> Sequence Space Comparison &nbsp;&nbsp 200 <TR> <TD ALIGN=left>11.6 <TD ALIGN=left COLSPAN=2> TCP Finite State Machine &nbsp;&nbsp 202 <TR> <TD ALIGN=left>11.7 <TD ALIGN=left COLSPAN=2> Example State Transition &nbsp;&nbsp 204 <TR> <TD ALIGN=left>11.8 <TD ALIGN=left COLSPAN=2> Declaration Of The Finite State Machine &nbsp;&nbsp 204 <TR> <TD ALIGN=left>11.9 <TD ALIGN=left COLSPAN=2> TCB Allocation And Initialization &nbsp;&nbsp 206 <TR> <TD ALIGN=left> <TD ALIGN=left>11.9.1 <TD ALIGN=left> Allocating A TCB &nbsp;&nbsp 206 <TR> <TD ALIGN=left> <TD ALIGN=left>11.9.2 <TD ALIGN=left> Deallocating A TCB &nbsp;&nbsp 207 <TR> <TD ALIGN=left>11.10 <TD ALIGN=left COLSPAN=2> Implementation Of The Finite State Machine &nbsp;&nbsp 208 <TR> <TD ALIGN=left>11.11 <TD ALIGN=left COLSPAN=2> Handling An Input Segment &nbsp;&nbsp 209 <TR> <TD ALIGN=left> <TD ALIGN=left>11.11.1 <TD ALIGN=left> Converting A TCP Header To Local Byte Order &nbsp;&nbsp 211 <TR> <TD ALIGN=left> <TD ALIGN=left>11.11.2 <TD ALIGN=left> Computing The TCP Checksum &nbsp;&nbsp 212 <TR> <TD ALIGN=left> <TD ALIGN=left>11.11.3 <TD ALIGN=left> Finding The TCB For A Segment &nbsp;&nbsp 213 <TR> <TD ALIGN=left> <TD ALIGN=left>11.11.4 <TD ALIGN=left> Checking Segment Validity &nbsp;&nbsp 215 <TR> <TD ALIGN=left> <TD ALIGN=left>11.11.5 <TD ALIGN=left> Choosing A Procedure For the Current State &nbsp;&nbsp 217 <TR> <TD ALIGN=left>11.12 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 218 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 219<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 219<BR> </TABLE> <BR> <BR> <H3>Chapter 12 &nbsp; TCP: Finite State Machine Implementation &nbsp;&nbsp; 221</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>12.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 221 <TR> <TD ALIGN=left>12.2 <TD ALIGN=left COLSPAN=2> CLOSED State Processing &nbsp;&nbsp 221 <TR> <TD ALIGN=left>12.3 <TD ALIGN=left COLSPAN=2> Graceful Shutdown &nbsp;&nbsp 222 <TR> <TD ALIGN=left>12.4 <TD ALIGN=left COLSPAN=2> Timed Delay After Closing &nbsp;&nbsp 222 <TR> <TD ALIGN=left>12.5 <TD ALIGN=left COLSPAN=2> TIME-WAIT State Processing &nbsp;&nbsp 223 <TR> <TD ALIGN=left>12.6 <TD ALIGN=left COLSPAN=2> CLOSING State Processing &nbsp;&nbsp 225 <TR> <TD ALIGN=left>12.7 <TD ALIGN=left COLSPAN=2> FIN-WAIT-2 State Processing &nbsp;&nbsp 226 <TR> <TD ALIGN=left>12.8 <TD ALIGN=left COLSPAN=2> FIN-WAIT-1 State Processing &nbsp;&nbsp 227 <TR> <TD ALIGN=left>12.9 <TD ALIGN=left COLSPAN=2> CLOSE-WAIT State Processing &nbsp;&nbsp 229 <TR> <TD ALIGN=left>12.10 <TD ALIGN=left COLSPAN=2> LAST-ACK State Processing &nbsp;&nbsp 231 <TR> <TD ALIGN=left>12.11 <TD ALIGN=left COLSPAN=2> ESTABLISHED State Processing &nbsp;&nbsp 232 <TR> <TD ALIGN=left>12.12 <TD ALIGN=left COLSPAN=2> Processing Urgent Data In A Segment &nbsp;&nbsp 233 <TR> <TD ALIGN=left>12.13 <TD ALIGN=left COLSPAN=2> Processing Other Data In A Segment &nbsp;&nbsp 235 <TR> <TD ALIGN=left>12.14 <TD ALIGN=left COLSPAN=2> Keeping Track Of Received Octets &nbsp;&nbsp 237 <TR> <TD ALIGN=left>12.15 <TD ALIGN=left COLSPAN=2> Aborting A TCP Connection &nbsp;&nbsp 240 <TR> <TD ALIGN=left>12.16 <TD ALIGN=left COLSPAN=2> Establishing A TCP Connection &nbsp;&nbsp 241 <TR> <TD ALIGN=left>12.17 <TD ALIGN=left COLSPAN=2> Initializing A TCB &nbsp;&nbsp 241 <TR> <TD ALIGN=left>12.18 <TD ALIGN=left COLSPAN=2> SYN-SENT State Processing &nbsp;&nbsp 243 <TR> <TD ALIGN=left>12.19 <TD ALIGN=left COLSPAN=2> SYN-RECEIVED State Processing &nbsp;&nbsp 244 <TR> <TD ALIGN=left>12.20 <TD ALIGN=left COLSPAN=2> LISTEN State Processing &nbsp;&nbsp 247 <TR> <TD ALIGN=left>12.21 <TD ALIGN=left COLSPAN=2> Initializing Window Variables For A New TCB &nbsp;&nbsp 248 <TR> <TD ALIGN=left>12.22 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 250 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 250<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 250<BR> </TABLE> <BR> <BR> <H3>Chapter 13 &nbsp; TCP: Output Processing &nbsp;&nbsp; 251</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>13.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 251 <TR> <TD ALIGN=left>13.2 <TD ALIGN=left COLSPAN=2> Controlling TCP Output Complexity &nbsp;&nbsp 251 <TR> <TD ALIGN=left>13.3 <TD ALIGN=left COLSPAN=2> The Four TCP Output States &nbsp;&nbsp 252 <TR> <TD ALIGN=left>13.4 <TD ALIGN=left COLSPAN=2> TCP Output As A Process &nbsp;&nbsp 252 <TR> <TD ALIGN=left>13.5 <TD ALIGN=left COLSPAN=2> TCP Output Messages &nbsp;&nbsp 253 <TR> <TD ALIGN=left>13.6 <TD ALIGN=left COLSPAN=2> Encoding Output States And TCB Numbers &nbsp;&nbsp 254 <TR> <TD ALIGN=left>13.7 <TD ALIGN=left COLSPAN=2> Implementation Of The TCP Output Process &nbsp;&nbsp 254 <TR> <TD ALIGN=left>13.8 <TD ALIGN=left COLSPAN=2> Mutual Exclusion &nbsp;&nbsp 255 <TR> <TD ALIGN=left>13.9 <TD ALIGN=left COLSPAN=2> Implementation Of The IDLE State &nbsp;&nbsp 256 <TR> <TD ALIGN=left>13.10 <TD ALIGN=left COLSPAN=2> Implementation Of The PERSIST State &nbsp;&nbsp 256 <TR> <TD ALIGN=left>13.11 <TD ALIGN=left COLSPAN=2> Implementation Of The TRANSMIT State &nbsp;&nbsp 257 <TR> <TD ALIGN=left>13.12 <TD ALIGN=left COLSPAN=2> Implementation Of The RETRANSMIT State &nbsp;&nbsp 259 <TR> <TD ALIGN=left>13.13 <TD ALIGN=left COLSPAN=2> Sending A Segment &nbsp;&nbsp 259 <TR> <TD ALIGN=left>13.14 <TD ALIGN=left COLSPAN=2> Computing The TCP Data Length &nbsp;&nbsp 263 <TR> <TD ALIGN=left>13.15 <TD ALIGN=left COLSPAN=2> Computing Sequence Counts &nbsp;&nbsp 264 <TR> <TD ALIGN=left>13.16 <TD ALIGN=left COLSPAN=2> Other TCP Procedures &nbsp;&nbsp 265 <TR> <TD ALIGN=left> <TD ALIGN=left>13.16.1 <TD ALIGN=left> Sending A Reset &nbsp;&nbsp 265 <TR> <TD ALIGN=left> <TD ALIGN=left>13.16.2 <TD ALIGN=left> Converting To Network Byte Order &nbsp;&nbsp 266 <TR> <TD ALIGN=left> <TD ALIGN=left>13.16.3 <TD ALIGN=left> Waiting For Space In The Output Buffer &nbsp;&nbsp 267 <TR> <TD ALIGN=left> <TD ALIGN=left>13.16.4 <TD ALIGN=left> Awakening Processes Waiting For A TCB &nbsp;&nbsp 269 <TR> <TD ALIGN=left> <TD ALIGN=left>13.16.5 <TD ALIGN=left> Choosing An Initial Sequence Number &nbsp;&nbsp 270 <TR> <TD ALIGN=left>13.17 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 271 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 272<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 272<BR> </TABLE> <BR> <BR> <H3>Chapter 14 &nbsp; TCP: Timer Management &nbsp;&nbsp; 273</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>14.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 273 <TR> <TD ALIGN=left>14.2 <TD ALIGN=left COLSPAN=2> A General Data Structure For Timed Events &nbsp;&nbsp 273 <TR> <TD ALIGN=left>14.3 <TD ALIGN=left COLSPAN=2> A Data Structure For TCP Events &nbsp;&nbsp 274 <TR> <TD ALIGN=left>14.4 <TD ALIGN=left COLSPAN=2> Timers, Events, And Messages &nbsp;&nbsp 275 <TR> <TD ALIGN=left>14.5 <TD ALIGN=left COLSPAN=2> The TCP Timer Process &nbsp;&nbsp 276 <TR> <TD ALIGN=left>14.6 <TD ALIGN=left COLSPAN=2> Deleting A TCP Timer Event &nbsp;&nbsp 278 <TR> <TD ALIGN=left>14.7 <TD ALIGN=left COLSPAN=2> Deleting All Events For A TCB &nbsp;&nbsp 280 <TR> <TD ALIGN=left>14.8 <TD ALIGN=left COLSPAN=2> Determining The Time Remaining For An Event &nbsp;&nbsp 281 <TR> <TD ALIGN=left>14.9 <TD ALIGN=left COLSPAN=2> Inserting A TCP Timer Event &nbsp;&nbsp 282 <TR> <TD ALIGN=left>14.10 <TD ALIGN=left COLSPAN=2> Starting TCP Output Without Delay &nbsp;&nbsp 283 <TR> <TD ALIGN=left>14.11 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 285 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 285<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 285<BR> </TABLE> <BR> <BR> <H3>Chapter 15 &nbsp; TCP: Flow Control And Adaptive Retransmission &nbsp;&nbsp; 287</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>15.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 287 <TR> <TD ALIGN=left>15.2 <TD ALIGN=left COLSPAN=2> The Difficulties With Adaptive Retransmission &nbsp;&nbsp 288 <TR> <TD ALIGN=left>15.3 <TD ALIGN=left COLSPAN=2> Tuning Adaptive Retransmission &nbsp;&nbsp 288 <TR> <TD ALIGN=left>15.4 <TD ALIGN=left COLSPAN=2> Retransmission Timer And Backoff &nbsp;&nbsp 288 <TR> <TD ALIGN=left> <TD ALIGN=left>15.4.1 <TD ALIGN=left> Karn's Algorithm &nbsp;&nbsp 288 <TR> <TD ALIGN=left> <TD ALIGN=left>15.4.2 <TD ALIGN=left> Retransmit Output State Processing &nbsp;&nbsp 289 <TR> <TD ALIGN=left>15.5 <TD ALIGN=left COLSPAN=2> Window-Based Flow Control &nbsp;&nbsp 291 <TR> <TD ALIGN=left> <TD ALIGN=left>15.5.1 <TD ALIGN=left> Silly Window Syndrome &nbsp;&nbsp 291 <TR> <TD ALIGN=left> <TD ALIGN=left>15.5.2 <TD ALIGN=left> Receiver-Side Silly Window Avoidance &nbsp;&nbsp 292 <TR> <TD ALIGN=left> <TD ALIGN=left>15.5.3 <TD ALIGN=left> Optimizing Performance After A Zero Window &nbsp;&nbsp 293 <TR> <TD ALIGN=left> <TD ALIGN=left>15.5.4 <TD ALIGN=left> Adjusting The Sender's Window &nbsp;&nbsp 293 <TR> <TD ALIGN=left>15.6 <TD ALIGN=left COLSPAN=2> Maximum Segment Size Computation &nbsp;&nbsp 295 <TR> <TD ALIGN=left> <TD ALIGN=left>15.6.1 <TD ALIGN=left> The Sender's Maximum Segment Size &nbsp;&nbsp 295 <TR> <TD ALIGN=left> <TD ALIGN=left>15.6.2 <TD ALIGN=left> Option Processing &nbsp;&nbsp 297 <TR> <TD ALIGN=left> <TD ALIGN=left>15.6.3 <TD ALIGN=left> Advertising An Input Maximum Segment Size &nbsp;&nbsp 298 <TR> <TD ALIGN=left>15.7 <TD ALIGN=left COLSPAN=2> Congestion Avoidance And Control &nbsp;&nbsp 299 <TR> <TD ALIGN=left> <TD ALIGN=left>15.7.1 <TD ALIGN=left> Multiplicative Decrease &nbsp;&nbsp 299 <TR> <TD ALIGN=left>15.8 <TD ALIGN=left COLSPAN=2> Slow-Start And Congestion Avoidance &nbsp;&nbsp 300 <TR> <TD ALIGN=left> <TD ALIGN=left>15.8.1 <TD ALIGN=left> Slow-start &nbsp;&nbsp 300 <TR> <TD ALIGN=left> <TD ALIGN=left>15.8.2 <TD ALIGN=left> Slower Increase After Threshold &nbsp;&nbsp 300 <TR> <TD ALIGN=left> <TD ALIGN=left>15.8.3 <TD ALIGN=left> Implementation Of Congestion Window Increase &nbsp;&nbsp 301 <TR> <TD ALIGN=left>15.9 <TD ALIGN=left COLSPAN=2> Round Trip Estimation And Timeout &nbsp;&nbsp 303 <TR> <TD ALIGN=left> <TD ALIGN=left>15.9.1 <TD ALIGN=left> A Fast Mean Update Algorithm &nbsp;&nbsp 303 <TR> <TD ALIGN=left> <TD ALIGN=left>15.9.2 <TD ALIGN=left> Handling Incoming Acknowledgements &nbsp;&nbsp 305 <TR> <TD ALIGN=left> <TD ALIGN=left>15.9.3 <TD ALIGN=left> Generating Acknowledgments For Data Outside The Window &nbsp;&nbsp 307 <TR> <TD ALIGN=left> <TD ALIGN=left>15.9.4 <TD ALIGN=left> Changing Output State After Receiving An Acknowledgement &nbsp;&nbsp 308 <TR> <TD ALIGN=left>15.10 <TD ALIGN=left COLSPAN=2> A Miscellaneous Note &nbsp;&nbsp 309 <TR> <TD ALIGN=left>15.11 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 310 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 310<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 310<BR> </TABLE> <BR> <BR> <H3>Chapter 16 &nbsp; TCP: Urgent Data Processing And The Push Function &nbsp;&nbsp; 313</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>16.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 313 <TR> <TD ALIGN=left>16.2 <TD ALIGN=left COLSPAN=2> Out-Of-Band Signaling &nbsp;&nbsp 313 <TR> <TD ALIGN=left>16.3 <TD ALIGN=left COLSPAN=2> Urgent Data &nbsp;&nbsp 314 <TR> <TD ALIGN=left>16.4 <TD ALIGN=left COLSPAN=2> Interpreting The Standard &nbsp;&nbsp 314 <TR> <TD ALIGN=left> <TD ALIGN=left>16.4.1 <TD ALIGN=left> The Out-Of-Band Data Interpretation &nbsp;&nbsp 314 <TR> <TD ALIGN=left> <TD ALIGN=left>16.4.2 <TD ALIGN=left> The Data Mark Interpretation &nbsp;&nbsp 316 <TR> <TD ALIGN=left>16.5 <TD ALIGN=left COLSPAN=2> Configuration For Berkeley Urgent Pointer Interpretation &nbsp;&nbsp 317 <TR> <TD ALIGN=left>16.6 <TD ALIGN=left COLSPAN=2> Informing An Application &nbsp;&nbsp 317 <TR> <TD ALIGN=left> <TD ALIGN=left>16.6.1 <TD ALIGN=left> Multiple Concurrent Application Programs &nbsp;&nbsp 318 <TR> <TD ALIGN=left>16.7 <TD ALIGN=left COLSPAN=2> Reading Data From TCP &nbsp;&nbsp 318 <TR> <TD ALIGN=left>16.8 <TD ALIGN=left COLSPAN=2> Sending Urgent Data &nbsp;&nbsp 320 <TR> <TD ALIGN=left>16.9 <TD ALIGN=left COLSPAN=2> TCP Push Function &nbsp;&nbsp 321 <TR> <TD ALIGN=left>16.10 <TD ALIGN=left COLSPAN=2> Interpreting Push With Out-Of-Order Delivery &nbsp;&nbsp 322 <TR> <TD ALIGN=left>16.11 <TD ALIGN=left COLSPAN=2> Implementation Of Push On Input &nbsp;&nbsp 323 <TR> <TD ALIGN=left>16.12 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 324 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 324<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 324<BR> </TABLE> <BR> <BR> <H3>Chapter 17 &nbsp; Socket-Level Interface &nbsp;&nbsp; 327</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>17.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 327 <TR> <TD ALIGN=left>17.2 <TD ALIGN=left COLSPAN=2> Interfacing Through A Device &nbsp;&nbsp 327 <TR> <TD ALIGN=left> <TD ALIGN=left>17.2.1 <TD ALIGN=left> Single Byte I/O &nbsp;&nbsp 328 <TR> <TD ALIGN=left> <TD ALIGN=left>17.2.2 <TD ALIGN=left> Extensions For Non-Transfer Functions &nbsp;&nbsp 329 <TR> <TD ALIGN=left>17.3 <TD ALIGN=left COLSPAN=2> TCP Connections As Devices &nbsp;&nbsp 329 <TR> <TD ALIGN=left>17.4 <TD ALIGN=left COLSPAN=2> An Example TCP Client Program &nbsp;&nbsp 330 <TR> <TD ALIGN=left>17.5 <TD ALIGN=left COLSPAN=2> An Example TCP Server Program &nbsp;&nbsp 331 <TR> <TD ALIGN=left>17.6 <TD ALIGN=left COLSPAN=2> Implementation Of The TCP Master Device &nbsp;&nbsp 333 <TR> <TD ALIGN=left> <TD ALIGN=left>17.6.1 <TD ALIGN=left> TCP Master Device Open Function &nbsp;&nbsp 333 <TR> <TD ALIGN=left> <TD ALIGN=left>17.6.2 <TD ALIGN=left> Forming A Passive TCP Connection &nbsp;&nbsp 335 <TR> <TD ALIGN=left> <TD ALIGN=left>17.6.3 <TD ALIGN=left> Forming An Active TCP Connection &nbsp;&nbsp 336 <TR> <TD ALIGN=left> <TD ALIGN=left>17.6.4 <TD ALIGN=left> Allocating An Unused Local Port &nbsp;&nbsp 337 <TR> <TD ALIGN=left> <TD ALIGN=left>17.6.5 <TD ALIGN=left> Completing An Active Connection &nbsp;&nbsp 339 <TR> <TD ALIGN=left> <TD ALIGN=left>17.6.6 <TD ALIGN=left> Control For The TCP Master Device &nbsp;&nbsp 340 <TR> <TD ALIGN=left>17.7 <TD ALIGN=left COLSPAN=2> Implementation Of A TCP Slave Device &nbsp;&nbsp 341 <TR> <TD ALIGN=left> <TD ALIGN=left>17.7.1 <TD ALIGN=left> Input From A TCP Slave Device &nbsp;&nbsp 341 <TR> <TD ALIGN=left> <TD ALIGN=left>17.7.2 <TD ALIGN=left> Single Byte Input From A TCP Slave Device &nbsp;&nbsp 344 <TR> <TD ALIGN=left> <TD ALIGN=left>17.7.3 <TD ALIGN=left> Output Through A TCP Slave Device &nbsp;&nbsp 344 <TR> <TD ALIGN=left> <TD ALIGN=left>17.7.4 <TD ALIGN=left> Closing A TCP Connection &nbsp;&nbsp 347 <TR> <TD ALIGN=left> <TD ALIGN=left>17.7.5 <TD ALIGN=left> Control Operations For A TCP Slave Device &nbsp;&nbsp 348 <TR> <TD ALIGN=left> <TD ALIGN=left>17.7.6 <TD ALIGN=left> Accepting Connections From A Passive Device &nbsp;&nbsp 350 <TR> <TD ALIGN=left> <TD ALIGN=left>17.7.7 <TD ALIGN=left> Changing The Size Of A Listen Queue &nbsp;&nbsp 350 <TR> <TD ALIGN=left> <TD ALIGN=left>17.7.8 <TD ALIGN=left> Acquiring Statistics From A Slave Device &nbsp;&nbsp 351 <TR> <TD ALIGN=left> <TD ALIGN=left>17.7.9 <TD ALIGN=left> Setting Or Clearing TCP Options &nbsp;&nbsp 354 <TR> <TD ALIGN=left>17.8 <TD ALIGN=left COLSPAN=2> Initialization Of A Slave Device &nbsp;&nbsp 355 <TR> <TD ALIGN=left>17.9 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 356 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 356<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 356<BR> </TABLE> <BR> <BR> <H3>Chapter 18 &nbsp; RIP: Active Route Propagation And Passive Acquisition &nbsp;&nbsp; 359</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>18.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 359 <TR> <TD ALIGN=left>18.2 <TD ALIGN=left COLSPAN=2> Active And Passive Mode Participants &nbsp;&nbsp 360 <TR> <TD ALIGN=left>18.3 <TD ALIGN=left COLSPAN=2> Basic RIP Algorithm And Cost Metric &nbsp;&nbsp 360 <TR> <TD ALIGN=left>18.4 <TD ALIGN=left COLSPAN=2> Instabilities And Solutions &nbsp;&nbsp 361 <TR> <TD ALIGN=left> <TD ALIGN=left>18.4.1 <TD ALIGN=left> Count To Infinity &nbsp;&nbsp 361 <TR> <TD ALIGN=left> <TD ALIGN=left>18.4.2 <TD ALIGN=left> Gateway Crashes And Route Timeout &nbsp;&nbsp 361 <TR> <TD ALIGN=left> <TD ALIGN=left>18.4.3 <TD ALIGN=left> Split Horizon &nbsp;&nbsp 362 <TR> <TD ALIGN=left> <TD ALIGN=left>18.4.4 <TD ALIGN=left> Poison Reverse &nbsp;&nbsp 362 <TR> <TD ALIGN=left> <TD ALIGN=left>18.4.5 <TD ALIGN=left> Route Timeout With Poison Reverse &nbsp;&nbsp 363 <TR> <TD ALIGN=left> <TD ALIGN=left>18.4.6 <TD ALIGN=left> Triggered Updates &nbsp;&nbsp 363 <TR> <TD ALIGN=left> <TD ALIGN=left>18.4.7 <TD ALIGN=left> Randomization To Prevent Broadcast Storms &nbsp;&nbsp 364 <TR> <TD ALIGN=left>18.5 <TD ALIGN=left COLSPAN=2> Message Types &nbsp;&nbsp 364 <TR> <TD ALIGN=left>18.6 <TD ALIGN=left COLSPAN=2> Protocol Characterization &nbsp;&nbsp 365 <TR> <TD ALIGN=left>18.7 <TD ALIGN=left COLSPAN=2> Implementation Of RIP &nbsp;&nbsp 366 <TR> <TD ALIGN=left> <TD ALIGN=left>18.7.1 <TD ALIGN=left> The Two Styles Of Implementation &nbsp;&nbsp 366 <TR> <TD ALIGN=left> <TD ALIGN=left>18.7.2 <TD ALIGN=left> Declarations &nbsp;&nbsp 366 <TR> <TD ALIGN=left> <TD ALIGN=left>18.7.3 <TD ALIGN=left> Conceptual Organization For Output &nbsp;&nbsp 369 <TR> <TD ALIGN=left>18.8 <TD ALIGN=left COLSPAN=2> The Principle RIP Process &nbsp;&nbsp 369 <TR> <TD ALIGN=left> <TD ALIGN=left>18.8.1 <TD ALIGN=left> Must Be Zero Field Must Be Zero &nbsp;&nbsp 371 <TR> <TD ALIGN=left> <TD ALIGN=left>18.8.2 <TD ALIGN=left> Processing An Incoming Response &nbsp;&nbsp 373 <TR> <TD ALIGN=left> <TD ALIGN=left>18.8.3 <TD ALIGN=left> Locking During Update &nbsp;&nbsp 374 <TR> <TD ALIGN=left> <TD ALIGN=left>18.8.4 <TD ALIGN=left> Verifying An Address &nbsp;&nbsp 374 <TR> <TD ALIGN=left>18.9 <TD ALIGN=left COLSPAN=2> Responding To An Incoming Request &nbsp;&nbsp 375 <TR> <TD ALIGN=left>18.10 <TD ALIGN=left COLSPAN=2> Generating Update Messages &nbsp;&nbsp 377 <TR> <TD ALIGN=left>18.11 <TD ALIGN=left COLSPAN=2> Initializing Copies Of An Update Message &nbsp;&nbsp 379 <TR> <TD ALIGN=left> <TD ALIGN=left>18.11.1 <TD ALIGN=left> Adding Routes To Copies Of An Update Message &nbsp;&nbsp 380 <TR> <TD ALIGN=left> <TD ALIGN=left>18.11.2 <TD ALIGN=left> Computing A Metric To Advertise &nbsp;&nbsp 382 <TR> <TD ALIGN=left> <TD ALIGN=left>18.11.3 <TD ALIGN=left> Allocating A Datagram For A RIP Message &nbsp;&nbsp 383 <TR> <TD ALIGN=left>18.12 <TD ALIGN=left COLSPAN=2> Generating Periodic RIP Output &nbsp;&nbsp 384 <TR> <TD ALIGN=left>18.13 <TD ALIGN=left COLSPAN=2> Limitations Of RIP &nbsp;&nbsp 385 <TR> <TD ALIGN=left>18.14 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 385 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 386<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 386<BR> </TABLE> <BR> <BR> <H3>Chapter 19 &nbsp; OSPF: Route Propagation With An SPF Algorithm &nbsp;&nbsp; 387</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>19.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 387 <TR> <TD ALIGN=left>19.2 <TD ALIGN=left COLSPAN=2> OSPF Configuration And Options &nbsp;&nbsp 388 <TR> <TD ALIGN=left>19.3 <TD ALIGN=left COLSPAN=2> OSPF's Graph-Theoretic Model &nbsp;&nbsp 388 <TR> <TD ALIGN=left>19.4 <TD ALIGN=left COLSPAN=2> OSPF Declarations &nbsp;&nbsp 392 <TR> <TD ALIGN=left> <TD ALIGN=left>19.4.1 <TD ALIGN=left> OSPF Packet Format Declarations &nbsp;&nbsp 392 <TR> <TD ALIGN=left> <TD ALIGN=left>19.4.2 <TD ALIGN=left> OSPF Interface Declarations &nbsp;&nbsp 393 <TR> <TD ALIGN=left> <TD ALIGN=left>19.4.3 <TD ALIGN=left> Global Constant And Data Structure Declarations &nbsp;&nbsp 395 <TR> <TD ALIGN=left>19.5 <TD ALIGN=left COLSPAN=2> Adjacency And Link State Propagation &nbsp;&nbsp 398 <TR> <TD ALIGN=left>19.6 <TD ALIGN=left COLSPAN=2> Discovering Neighboring Gateways With Hello &nbsp;&nbsp 399 <TR> <TD ALIGN=left>19.7 <TD ALIGN=left COLSPAN=2> Sending Hello Packets &nbsp;&nbsp 401 <TR> <TD ALIGN=left> <TD ALIGN=left>19.7.1 <TD ALIGN=left> A Template For Hello Packets &nbsp;&nbsp 403 <TR> <TD ALIGN=left> <TD ALIGN=left>19.7.2 <TD ALIGN=left> The Hello Output Process &nbsp;&nbsp 405 <TR> <TD ALIGN=left>19.8 <TD ALIGN=left COLSPAN=2> Designated Router Concept &nbsp;&nbsp 407 <TR> <TD ALIGN=left>19.9 <TD ALIGN=left COLSPAN=2> Electing A Designated Router &nbsp;&nbsp 407 <TR> <TD ALIGN=left>19.10 <TD ALIGN=left COLSPAN=2> Reforming Adjacencies After A Change &nbsp;&nbsp 411 <TR> <TD ALIGN=left>19.11 <TD ALIGN=left COLSPAN=2> Handling Arriving Hello Packets &nbsp;&nbsp 414 <TR> <TD ALIGN=left>19.12 <TD ALIGN=left COLSPAN=2> Adding A Gateway To The Neighbor List &nbsp;&nbsp 416 <TR> <TD ALIGN=left>19.13 <TD ALIGN=left COLSPAN=2> Neighbor State Transitions &nbsp;&nbsp 418 <TR> <TD ALIGN=left>19.14 <TD ALIGN=left COLSPAN=2> OSPF Timer Events And Retransmissions &nbsp;&nbsp 420 <TR> <TD ALIGN=left>19.15 <TD ALIGN=left COLSPAN=2> Determining Whether Adjacency Is Permitted &nbsp;&nbsp 422 <TR> <TD ALIGN=left>19.16 <TD ALIGN=left COLSPAN=2> Handling OSPF input &nbsp;&nbsp 423 <TR> <TD ALIGN=left>19.17 <TD ALIGN=left COLSPAN=2> Declarations And Procedures For Link State Processing &nbsp;&nbsp 426 <TR> <TD ALIGN=left>19.18 <TD ALIGN=left COLSPAN=2> Generating Database Description Packets &nbsp;&nbsp 429 <TR> <TD ALIGN=left>19.19 <TD ALIGN=left COLSPAN=2> Creating A Template &nbsp;&nbsp 430 <TR> <TD ALIGN=left>19.20 <TD ALIGN=left COLSPAN=2> Transmitting A Database Description Packet &nbsp;&nbsp 431 <TR> <TD ALIGN=left>19.21 <TD ALIGN=left COLSPAN=2> Handling An Arriving Database Description Packet &nbsp;&nbsp 433 <TR> <TD ALIGN=left> <TD ALIGN=left>19.21.1 <TD ALIGN=left> Handling A Packet In The EXSTART State &nbsp;&nbsp 435 <TR> <TD ALIGN=left> <TD ALIGN=left>19.21.2 <TD ALIGN=left> Handling A Packet In The EXCHNG State &nbsp;&nbsp 437 <TR> <TD ALIGN=left> <TD ALIGN=left>19.21.3 <TD ALIGN=left> Handling A Packet In The FULL State &nbsp;&nbsp 438 <TR> <TD ALIGN=left>19.22 <TD ALIGN=left COLSPAN=2> Handling Link State Request Packets &nbsp;&nbsp 440 <TR> <TD ALIGN=left>19.23 <TD ALIGN=left COLSPAN=2> Building A Link State Summary &nbsp;&nbsp 442 <TR> <TD ALIGN=left>19.24 <TD ALIGN=left COLSPAN=2> OSPF Utility Procedures &nbsp;&nbsp 443 <TR> <TD ALIGN=left>19.25 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 446 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 447<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 447<BR> </TABLE> <BR> <BR> <H3>Chapter 20 &nbsp; SNMP: MIB Variables, Representations, And Bindings &nbsp;&nbsp; 449</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>20.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 449 <TR> <TD ALIGN=left>20.2 <TD ALIGN=left COLSPAN=2> Server Organization And Name Mapping &nbsp;&nbsp 450 <TR> <TD ALIGN=left>20.3 <TD ALIGN=left COLSPAN=2> MIB Variables &nbsp;&nbsp 451 <TR> <TD ALIGN=left> <TD ALIGN=left>20.3.1 <TD ALIGN=left> Fields Within Tables &nbsp;&nbsp 451 <TR> <TD ALIGN=left>20.4 <TD ALIGN=left COLSPAN=2> MIB Variable Names &nbsp;&nbsp 452 <TR> <TD ALIGN=left> <TD ALIGN=left>20.4.1 <TD ALIGN=left> Numeric Representation Of Names &nbsp;&nbsp 452 <TR> <TD ALIGN=left>20.5 <TD ALIGN=left COLSPAN=2> Lexicographic Ordering Among Names &nbsp;&nbsp 453 <TR> <TD ALIGN=left>20.6 <TD ALIGN=left COLSPAN=2> Prefix Removal &nbsp;&nbsp 453 <TR> <TD ALIGN=left>20.7 <TD ALIGN=left COLSPAN=2> Operations Applied To MIB Variables &nbsp;&nbsp 454 <TR> <TD ALIGN=left>20.8 <TD ALIGN=left COLSPAN=2> Names For Tables &nbsp;&nbsp 454 <TR> <TD ALIGN=left>20.9 <TD ALIGN=left COLSPAN=2> Conceptual Threading Of The Name Hierarchy &nbsp;&nbsp 455 <TR> <TD ALIGN=left>20.10 <TD ALIGN=left COLSPAN=2> Data Structure For MIB Variables &nbsp;&nbsp 456 <TR> <TD ALIGN=left> <TD ALIGN=left>20.10.1 <TD ALIGN=left> Using Separate Functions To Perform Operations &nbsp;&nbsp 458 <TR> <TD ALIGN=left>20.11 <TD ALIGN=left COLSPAN=2> A Data Structure For Fast Lookup &nbsp;&nbsp 459 <TR> <TD ALIGN=left>20.12 <TD ALIGN=left COLSPAN=2> Implementation Of The Hash Table &nbsp;&nbsp 460 <TR> <TD ALIGN=left>20.13 <TD ALIGN=left COLSPAN=2> Specification Of MIB Bindings &nbsp;&nbsp 460 <TR> <TD ALIGN=left>20.14 <TD ALIGN=left COLSPAN=2> Internal Variables Used In Bindings &nbsp;&nbsp 467 <TR> <TD ALIGN=left>20.15 <TD ALIGN=left COLSPAN=2> Hash Table Lookup &nbsp;&nbsp 469 <TR> <TD ALIGN=left>20.16 <TD ALIGN=left COLSPAN=2> SNMP Structures And Constants &nbsp;&nbsp 471 <TR> <TD ALIGN=left>20.17 <TD ALIGN=left COLSPAN=2> ASN.1 Representation Manipulation &nbsp;&nbsp 477 <TR> <TD ALIGN=left> <TD ALIGN=left>20.17.1 <TD ALIGN=left> Representation Of Length &nbsp;&nbsp 478 <TR> <TD ALIGN=left> <TD ALIGN=left>20.17.2 <TD ALIGN=left> Converting Integers To ASN.1 Form &nbsp;&nbsp 481 <TR> <TD ALIGN=left> <TD ALIGN=left>20.17.3 <TD ALIGN=left> Converting Object Ids To ASN.1 Form &nbsp;&nbsp 483 <TR> <TD ALIGN=left> <TD ALIGN=left>20.17.4 <TD ALIGN=left> A Generic Routine For Converting Values &nbsp;&nbsp 486 <TR> <TD ALIGN=left>20.18 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 488 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 489<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 489<BR> </TABLE> <BR> <BR> <H3>Chapter 21 &nbsp; SNMP: Client And Server &nbsp;&nbsp; 491</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>21.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 491 <TR> <TD ALIGN=left>21.2 <TD ALIGN=left COLSPAN=2> Data Representation In The Server &nbsp;&nbsp 491 <TR> <TD ALIGN=left>21.3 <TD ALIGN=left COLSPAN=2> Server Implementation &nbsp;&nbsp 492 <TR> <TD ALIGN=left>21.4 <TD ALIGN=left COLSPAN=2> Parsing An SNMP Message &nbsp;&nbsp 495 <TR> <TD ALIGN=left>21.5 <TD ALIGN=left COLSPAN=2> Converting ASN.1 Names In The Binding List &nbsp;&nbsp 500 <TR> <TD ALIGN=left>21.6 <TD ALIGN=left COLSPAN=2> Resolving A Query &nbsp;&nbsp 501 <TR> <TD ALIGN=left>21.7 <TD ALIGN=left COLSPAN=2> Interpreting The Get-Next Operation &nbsp;&nbsp 504 <TR> <TD ALIGN=left>21.8 <TD ALIGN=left COLSPAN=2> Indirect Application Of Operations &nbsp;&nbsp 504 <TR> <TD ALIGN=left>21.9 <TD ALIGN=left COLSPAN=2> Indirection For Tables &nbsp;&nbsp 507 <TR> <TD ALIGN=left>21.10 <TD ALIGN=left COLSPAN=2> Generating A Reply Message Backward &nbsp;&nbsp 509 <TR> <TD ALIGN=left>21.11 <TD ALIGN=left COLSPAN=2> Converting From Internal Form to ASN.1 &nbsp;&nbsp 512 <TR> <TD ALIGN=left>21.12 <TD ALIGN=left COLSPAN=2> Utility Functions Used By The Server &nbsp;&nbsp 514 <TR> <TD ALIGN=left>21.13 <TD ALIGN=left COLSPAN=2> Implementation Of An SNMP Client &nbsp;&nbsp 515 <TR> <TD ALIGN=left>21.14 <TD ALIGN=left COLSPAN=2> Initialization Of Variables &nbsp;&nbsp 517 <TR> <TD ALIGN=left>21.15 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 519 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 519<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 520<BR> </TABLE> <BR> <BR> <H3>Chapter 22 &nbsp; SNMP: Table Access Functions &nbsp;&nbsp; 521</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>22.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 521 <TR> <TD ALIGN=left>22.2 <TD ALIGN=left COLSPAN=2> Table Access &nbsp;&nbsp 522 <TR> <TD ALIGN=left>22.3 <TD ALIGN=left COLSPAN=2> Object Identifiers For Tables &nbsp;&nbsp 522 <TR> <TD ALIGN=left>22.4 <TD ALIGN=left COLSPAN=2> Address Entry Table Functions &nbsp;&nbsp 522 <TR> <TD ALIGN=left> <TD ALIGN=left>22.4.1 <TD ALIGN=left> Get Operation For The Address Entry Table &nbsp;&nbsp 524 <TR> <TD ALIGN=left> <TD ALIGN=left>22.4.2 <TD ALIGN=left> Get-First Operation For The Address Entry Table &nbsp;&nbsp 526 <TR> <TD ALIGN=left> <TD ALIGN=left>22.4.3 <TD ALIGN=left> Get-Next Operation For The Address Entry Table &nbsp;&nbsp 527 <TR> <TD ALIGN=left> <TD ALIGN=left>22.4.4 <TD ALIGN=left> Incremental Search In The Address Entry Table &nbsp;&nbsp 528 <TR> <TD ALIGN=left> <TD ALIGN=left>22.4.5 <TD ALIGN=left> Set Operation For The Address Entry Table &nbsp;&nbsp 529 <TR> <TD ALIGN=left>22.5 <TD ALIGN=left COLSPAN=2> Net-To-Media Table Functions &nbsp;&nbsp 530 <TR> <TD ALIGN=left> <TD ALIGN=left>22.5.1 <TD ALIGN=left> Get Operation For The Net-To-Media Table &nbsp;&nbsp 532 <TR> <TD ALIGN=left> <TD ALIGN=left>22.5.2 <TD ALIGN=left> Get-First Operation For The Net-To-Media Table &nbsp;&nbsp 534 <TR> <TD ALIGN=left> <TD ALIGN=left>22.5.3 <TD ALIGN=left> Get-Next Operation For The Net-To-Media Table &nbsp;&nbsp 535 <TR> <TD ALIGN=left> <TD ALIGN=left>22.5.4 <TD ALIGN=left> Incremental Search In The Net-To-Media Table &nbsp;&nbsp 537 <TR> <TD ALIGN=left> <TD ALIGN=left>22.5.5 <TD ALIGN=left> Order From Chaos &nbsp;&nbsp 539 <TR> <TD ALIGN=left> <TD ALIGN=left>22.5.6 <TD ALIGN=left> Set Operation For The Net-To-Media Table &nbsp;&nbsp 539 <TR> <TD ALIGN=left>22.6 <TD ALIGN=left COLSPAN=2> Network Interface Table Functions &nbsp;&nbsp 541 <TR> <TD ALIGN=left> <TD ALIGN=left>22.6.1 <TD ALIGN=left> Interface Table ID Matching &nbsp;&nbsp 541 <TR> <TD ALIGN=left> <TD ALIGN=left>22.6.2 <TD ALIGN=left> Get Operation For The Network Interface Table &nbsp;&nbsp 543 <TR> <TD ALIGN=left> <TD ALIGN=left>22.6.3 <TD ALIGN=left> Get-First Operation For The Network Interface Table &nbsp;&nbsp 546 <TR> <TD ALIGN=left> <TD ALIGN=left>22.6.4 <TD ALIGN=left> Get-Next Operation For The Network Interface Table &nbsp;&nbsp 547 <TR> <TD ALIGN=left> <TD ALIGN=left>22.6.5 <TD ALIGN=left> Set Operation For The Network Interface Table &nbsp;&nbsp 549 <TR> <TD ALIGN=left>22.7 <TD ALIGN=left COLSPAN=2> Routing Table Functions &nbsp;&nbsp 550 <TR> <TD ALIGN=left> <TD ALIGN=left>22.7.1 <TD ALIGN=left> Get Operation For The Routing Table &nbsp;&nbsp 551 <TR> <TD ALIGN=left> <TD ALIGN=left>22.7.2 <TD ALIGN=left> Get-First Operation For The Routing Table &nbsp;&nbsp 554 <TR> <TD ALIGN=left> <TD ALIGN=left>22.7.3 <TD ALIGN=left> Get-Next Operation For The Routing Table &nbsp;&nbsp 555 <TR> <TD ALIGN=left> <TD ALIGN=left>22.7.4 <TD ALIGN=left> Incremental Search In The Routing Table &nbsp;&nbsp 557 <TR> <TD ALIGN=left> <TD ALIGN=left>22.7.5 <TD ALIGN=left> Set Operation For The Routing Table &nbsp;&nbsp 558 <TR> <TD ALIGN=left>22.8 <TD ALIGN=left COLSPAN=2> TCP Connection Table Functions &nbsp;&nbsp 560 <TR> <TD ALIGN=left> <TD ALIGN=left>22.8.1 <TD ALIGN=left> Get Operation For The TCP Connection Table &nbsp;&nbsp 562 <TR> <TD ALIGN=left> <TD ALIGN=left>22.8.2 <TD ALIGN=left> Get-First Operation For The TCP Connection Table &nbsp;&nbsp 563 <TR> <TD ALIGN=left> <TD ALIGN=left>22.8.3 <TD ALIGN=left> Get-Next Operation For The TCP Connection Table &nbsp;&nbsp 565 <TR> <TD ALIGN=left> <TD ALIGN=left>22.8.4 <TD ALIGN=left> Incremental Search In The TCP Connection Table &nbsp;&nbsp 566 <TR> <TD ALIGN=left> <TD ALIGN=left>22.8.5 <TD ALIGN=left> Set Operation For The TCP Connection Table &nbsp;&nbsp 567 <TR> <TD ALIGN=left>22.9 <TD ALIGN=left COLSPAN=2> UDP Listener Table &nbsp;&nbsp 569 <TR> <TD ALIGN=left> <TD ALIGN=left>22.9.1 <TD ALIGN=left> Get Operation For The UDP Listener Table &nbsp;&nbsp 570 <TR> <TD ALIGN=left> <TD ALIGN=left>22.9.2 <TD ALIGN=left> Get-First Operation For The UDP Listener Table &nbsp;&nbsp 572 <TR> <TD ALIGN=left> <TD ALIGN=left>22.9.3 <TD ALIGN=left> Get-Next Operation For The UDP Listener Table &nbsp;&nbsp 573 <TR> <TD ALIGN=left> <TD ALIGN=left>22.9.4 <TD ALIGN=left> Incremental Search In The UDP Listener Table &nbsp;&nbsp 574 <TR> <TD ALIGN=left> <TD ALIGN=left>22.9.5 <TD ALIGN=left> Set Operation For The UDP Listener Table &nbsp;&nbsp 575 <TR> <TD ALIGN=left>22.10 <TD ALIGN=left COLSPAN=2> Utility Routines To Convert IP Addresses &nbsp;&nbsp 576 <TR> <TD ALIGN=left>22.11 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 578 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 578<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 578<BR> </TABLE> <BR> <BR> <H3>Chapter 23 &nbsp; Implementation In Retrospect &nbsp;&nbsp; 579</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>23.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 579 <TR> <TD ALIGN=left>23.2 <TD ALIGN=left COLSPAN=2> Statistical Analysis Of The Code &nbsp;&nbsp 579 <TR> <TD ALIGN=left>23.3 <TD ALIGN=left COLSPAN=2> Lines Of Code For Each Protocol &nbsp;&nbsp 580 <TR> <TD ALIGN=left>23.4 <TD ALIGN=left COLSPAN=2> Functions And Procedures For Each Protocol &nbsp;&nbsp 582 <TR> <TD ALIGN=left>23.5 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 583 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 583<BR> </TABLE> <BR> <BR><H3> Appendix 1 &nbsp; Cross Reference Of Procedure Calls &nbsp;&nbsp; 585</H3> <BR><H3> Appendix 2 &nbsp; Cross Reference Of C Structures Used In The Code &nbsp;&nbsp; 607</H3> <BR><H3> Appendix 3 &nbsp; Xinu Functions And Constants Used In The Code &nbsp;&nbsp; 613</H3> <BR><H3> Bibliography &nbsp;&nbsp;631</H3> <BR><H3> Index &nbsp;&nbsp;639</H3> </UL></UL> </BODY> </BODY>
</DOC>
