<DOC>
<DOCNO> http://www.cs.purdue.edu/homes/dec/xinu2.cont.html </DOCNO>
<HTML> <H2> Table of Contents: Operating System Design Volume 2</H2> <BR> <H3> Foreword </H3> <H3> Preface </H3> <H3> Chapter 1 Introduction and Overview </H3> <DL> <DT> 1.1 Introduction 1 <DT> 1.2 Internetworking 2 <DT> 1.3 Design Methodology 2 <DT> 1.4 Goals 3 <DT> 1.5 A Target System 3 <DT> 1.6 User Interface 3 <DT> 1.6.1 Other System Information Commands 5 <DT> 1.6.2 Background Processing 6 <DT> 1.6.3 Changing To Background 7 <DT> 1.6.4 I/O Redirection 7 <DT> 1.6.5 Quoting 8 <DT> 1.7 Internetwork Communication 9 <DT> 1.8 Design Plan 9 <DT> 1.9 Summary 11 <DT> For Further Study 11 <DT> Exercises 12 </DL> <H3> Chapter 2 An Overview of Network Hardware </H3> <DL> <DT> 2.1 Introduction 13 <DT> 2.2 Two Approaches To Network Communication 13 <DT> 2.3 Long-Haul And Local-Area Networks 14 <DT> 2.4 Ethernet Packet-Switched Network Technology 15 <DT> 2.5 Properties Of An Ethernet 18 <DT> 2.6 Collision Detection And Recovery 18 <DT> 2.7 Ethernet Capacity 19 <DT> 2.8 Ethernet Addresses 19 <DT> 2.9 Ethernet Frame Format 20 <DT> 2.10 DEQNA Ethernet Interface 21 <DT> 2.10.1 DEQNA CSR 21 <DT> 2.10.2 The DEQNA CSR Bits 22 <DT> 2.11 Format Of DEQNA Command Lists 23 <DT> 2.12 Summary 23 <DT> For Further Study 24 <DT> Exercises 24 </DL> <H3> Chapter 3 Physical Transport </H3> <DL> <DT> 3.1 Introduction 27 <DT> 3.2 Blocks And Frames 27 <DT> 3.3 An Example Implementation Using Xinu 29 <DT> 3.3.1 Ethernet And Interface Device Definitions 29 <DT> 3.4 Ethernet Definitions 32 <DT> 3.5 Frame Format In Memory 34 <DT> 3.6 The Ethernet Frame Type 34 <DT> 3.7 Ethernet Device Control Block 34 <DT> 3.8 Upper-Half Input Routine 35 <DT> 3.9 Upper-Half Output Routine 38 <DT> 3.10 The Lower-Half Routines 40 <DT> 3.11 Device And Driver Initialization 43 <DT> 3.12 Ethernet Device Driver Configuration 46 <DT> 3.13 Summary 46 <DT> For Further Study 47 <DT> Exercises 47 </DL> <H3> Chapter 4 Internetworking </H3> <DL> <DT> 4.1 Introduction 49 <DT> 4.2 Why An Internet? 50 <DT> 4.2.1 Properties Of The Internet 50 <DT> 4.3 The DARPA Internet 51 <DT> 4.3.1 Internet Architecture 51 <DT> 4.3.2 Gateways 53 <DT> 4.3.3 Internet Addressing 53 <DT> 4.3.4 Network And Broadcast Addresses 54 <DT> 4.3.5 Dotted Decimal Notation 54 <DT> 4.3.6 The User's View 55 <DT> 4.3.7 An Example 56 <DT> 4.4 Network Byte Order 59 <DT> 4.5 Computing A Network Address 61 <DT> 4.6 The Unanswered Questions 62 <DT> 4.7 Summary 63 <DT> For Further Study 63 <DT> Exercises 63 </DL> <H3> Chapter 5 Address Determination at Boot Time </H3> <DL> <DT> 5.1 Introduction 65 <DT> 5.2 A Mechanism For Timing Responses 66 <DT> 5.3 Reverse Address Resolution Protocol (RARP) 68 <DT> 5.3.1 Sending A RARP Packet 71 <DT> 5.3.2 Handling RARP Responses 72 <DT> 5.4 Summary 75 <DT> For Further Study 75 <DT> Exercises 76 </DL> <H3> Chapter 6 Address Resolution at Run Time </H3> <DL> <DT> 6.1 Introduction 77 <DT> 6.2 ARP: An Address Resolution Protocol 78 <DT> 6.2.1 Refinements 78 <DT> 6.3 ARP Implementation 79 <DT> 6.3.1 Finding A Physical Address 79 <DT> 6.3.2 Searching The ARP cache 81 <DT> 6.3.3 Handling Incoming ARP Packets 83 <DT> 6.4 ARP And RARP Initialization 86 <DT> 6.5 Summary 87 <DT> For Further Study 87 <DT> Exercises 87 </DL> <H3> Chapter 7 The Internet Protocol and Routing </H3> <DL> <DT> 7.1 Introduction 89 <DT> 7.2 A Virtual Network 89 <DT> 7.3 Internet Datagram 90 <DT> 7.3.1 Datagram Length And Fragmentation 90 <DT> 7.3.2 Datagram Format 90 <DT> 7.4 Sending An IP Datagram 93 <DT> 7.5 Routing 94 <DT> 7.5.1 Direct Routing 95 <DT> 7.5.2 Indirect Routing 95 <DT> 7.5.3 Simplified Routing For Single Connections 96 <DT> 7.6 Summary 98 <DT> For Further Study 98 <DT> Exercises 98 </DL> <H3> Chapter 8 Internet Control Messages </H3> <DL> <DT> 8.1 Introduction 101 <DT> 8.2 Extranormal Communication 101 <DT> 8.3 Internet Control Message Protocol 102 <DT> 8.3.1 ICMP Messages 102 <DT> 8.3.2 ICMP Echo Request And Reply Messages 103 <DT> 8.3.3 ICMP Redirect Messages 103 <DT> 8.3.4 ICMP Source Quench 103 <DT> 8.4 An Implementation Of ICMP 104 <DT> 8.4.1 ICMP Message Input Processing 105 <DT> 8.5 Summary 107 <DT> For Further Study 107 <DT> Exercises 108 </DL> <H3> Chapter 9 User Datagram Protocol </H3> <DL> <DT> 9.1 Introduction 109 <DT> 9.2 Identifying The Ultimate Destination 109 <DT> 9.3 The Important Concept Of Unreliable Delivery 110 <DT> 9.4 DARPA User Datagram Protocol 111 <DT> 9.4.1 The Relationship Between Packet Layout And Protocol Software 111 <DT> 9.4.2 UDP Declarations 113 <DT> 9.4.3 Sending User Datagrams 114 <DT> 9.4.4 Assigning The IP Packet Type 115 <DT> 9.4.5 Passing A User Datagram To Lower Layers 115 <DT> 9.5 Summary 115 <DT> For Further Study 116 <DT> Exercises 116 </DL> <H3> Chapter 10 Network Input and Protocol Demultiplexing </H3> <DL> <DT> 10.1 Introduction 117 <DT> 10.2 A Network Input Process 117 <DT> 10.3 Demultiplexing 120 <DT> 10.4 Implementation Of The Network Input Process 120 <DT> 10.4.1 General Network Declarations 120 <DT> 10.4.2 The Network Input Procedure 122 <DT> 10.4.3 Network Initialization 123 <DT> 10.4.4 Output By The Network Input Process 125 <DT> 10.4.5 Implementation Of Network Output Process 125 <DT> 10.5 The Details Of Datagram Demultiplexing 127 <DT> 10.5.1 Datagram Timeout 129 <DT> 10.6 The Needed Interface 129 <DT> 10.7 Summary 129 <DT> For Further Study 130 <DT> Exercises 130 </DL> <H3> Chapter 11 Device Interface for Datagram Communication </H3> <DL> <DT> 11.1 Datagram Interface And Copying 131 <DT> 11.2 Data Or Datagram Oriented User Interface 132 <DT> 11.3 Datagram Pseudo-Device Interface 133 <DT> 11.4 Datagram Pseudo-Device Implementation 133 <DT> 11.4.1 Datagram Pseudo-device Initialization 135 <DT> 11.4.2 Utility Procedures 136 <DT> 11.4.3 Opening A Datagram Pseudo-Device 140 <DT> 11.4.4 Closing A Datagram Pseudo-Device 141 <DT> 11.4.5 Data Transfer Operations 142 <DT> 11.4.6 Modes Of Transfer 143 <DT> 11.4.7 Implementation Of Datagram Write 143 <DT> 11.4.8 Implementation Of Datagram Read 145 <DT> 11.4.9 Datagram Device Control Functions 148 <DT> 11.5 Datagram Pseudo-Device Interface Configuration 149 <DT> 11.6 Summary 150 <DT> For Further Study 151 <DT> Exercises 151 </DL> <H3> Chapter 12 The Client-Server Interaction Paradigm </H3> <DL> <DT> 12.1 Introduction 153 <DT> 12.2 The Client-Server Model 154 <DT> 12.3 UDP Echo Server 154 <DT> 12.4 Echo Server Implementation 155 <DT> 12.5 Time And Date Service 156 <DT> 12.5.1 Representation For The Date And Time 156 <DT> 12.5.2 Maintaining The Time-of-Day In Xinu 157 <DT> 12.5.3 Local And Universal Time 159 <DT> 12.5.4 Obtaining The Time 161 <DT> 12.6 RARP Client 164 <DT> 12.7 The ICMP Echo Server And Client-Server Model 165 <DT> 12.8 Alternatives To The Client-Server Model 166 <DT> 12.9 A Machine Status Service 166 <DT> 12.10 Implementation Of The Machine Status Service 167 <DT> 12.10.1 Rwho Packet Format 167 <DT> 12.10.2 Rwho Information Collection Daemon 169 <DT> 12.10.3 Clock Consistency 171 <DT> 12.10.4 Rwho Output Daemon 172 <DT> 12.10.5 Rwho Subsystem Startup 174 <DT> 12.11 Summary 175 <DT> For Further Study 175 <DT> Exercises 175 </DL> <H3> Chapter 13 A Stateless File Server </H3> <DL> <DT> 13.1 Introduction 177 <DT> 13.2 Remote Files Vs. Remote Disks 177 <DT> 13.3 The Property Of Statelessness In Servers 179 <DT> 13.4 Statelessness In A File Server 180 <DT> 13.5 File Requests And Responses 180 <DT> 13.6 Efficient, Stateless File Access 181 <DT> 13.7 UNIX Implementation Of A File Server 182 <DT> 13.7.1 Server Declarations 182 <DT> 13.7.2 Xinu Include Files 184 <DT> 13.7.3 Utility Procedures 188 <DT> 13.7.4 Closing A File 188 <DT> 13.7.5 Seeking In A File 189 <DT> 13.7.6 Removing A File 190 <DT> 13.7.7 Opening A UNIX file 190 <DT> 13.7.8 Checking The Cache For Open Files 192 <DT> 13.7.9 Removing Cached Information 194 <DT> 13.7.10 Organization Of The Server 194 <DT> 13.7.11 Acquiring A Request 196 <DT> 13.7.12 Sending Replies 197 <DT> 13.8 Handlers For File Operations 198 <DT> 13.8.1 Mapping Requests To Handlers 198 <DT> 13.8.2 Handling The Close Operation 200 <DT> 13.8.3 Handling The Access Operation 200 <DT> 13.8.4 Handling The Unlink Operation 201 <DT> 13.8.5 Handling The Open Operation 202 <DT> 13.8.6 Handling The Read Operation 202 <DT> 13.8.7 Handling The Write Operation 203 <DT> 13.8.8 Handling The Mkdir Operation 204 <DT> 13.8.9 Handling The Rmdir Operation 205 <DT> 13.8.10 Handling The Rename Operation 206 <DT> 13.9 Server Initialization 208 <DT> 13.9.1 Command Line Arguments 208 <DT> 13.9.2 Extracting Arguments At Run-Time 209 <DT> 13.9.3 Server Initialization 211 <DT> 13.10 Summary 212 <DT> For Further Study 213 <DT> Exercises 213 </DL> <H3> Chapter 14 Remote File Access </H3> <DL> <DT> 14.1 Introduction 215 <DT> 14.2 Remote File Pseudo-Devices 215 <DT> 14.3 Maintaining State Information 216 <DT> 14.4 Remote File Pseudo-Device Support Routines 216 <DT> 14.5 Composing Request Packets 220 <DT> 14.6 A Universal Remote I/O Routine 223 <DT> 14.7 Opening A Remote File 224 <DT> 14.8 Closing A Remote File 225 <DT> 14.9 Reading From A Remote File 227 <DT> 14.10 Writing To A Remote File 227 <DT> 14.11 Single Character Transfer Operations 228 <DT> 14.12 Seeking In A Remote File 230 <DT> 14.13 Operations On Remote Files 230 <DT> 14.14 Remote File Device Initialization 233 <DT> 14.15 Remote File Pseudo-Device Configuration 235 <DT> 14.16 Summary 236 <DT> For Further Study 236 <DT> Exercises 236 </DL> <H3> Chapter 15 A Syntactic Namespace </H3> <DL> <DT> 15.1 Introduction 239 <DT> 15.2 The Problem With File Names 240 <DT> 15.2.1 MS-DOS 240 <DT> 15.2.2 UNIX 240 <DT> 15.2.3 V System 241 <DT> 15.2.4 Newcastle Connection 241 <DT> 15.2.5 IBIS 241 <DT> 15.2.6 TILDE 241 <DT> 15.3 Naming System Design Alternatives 241 <DT> 15.4 A Syntactic Namespace 242 <DT> 15.5 Patterns And Replacements 242 <DT> 15.6 Prefix Patterns 243 <DT> 15.7 Implementation Of A Simple Syntactic Namespace 243 <DT> 15.7.1 The Pseudo-Device NAMESPACE 243 <DT> 15.7.2 Definitions Of Data Structures And Constants 244 <DT> 15.7.3 Adding Mappings To The Prefix Table 245 <DT> 15.7.4 Removing A Name Mapping 246 <DT> 15.7.5 Mapping Names With The Prefix Table 247 <DT> 15.7.6 Iterative Resolution Of Recursive Mappings 249 <DT> 15.7.7 Opening A Named File 250 <DT> 15.7.8 Namespace Initialization 250 <DT> 15.8 Choosing Initial Prefix Mappings 252 <DT> 15.8.1 Default Hierarchy And The Null Prefix 253 <DT> 15.8.2 A Common Name Syntax 254 <DT> 15.9 Additional File Manipulation Commands 254 <DT> 15.9.1 Removing A File 254 <DT> 15.9.2 Renaming A File 256 <DT> 15.9.3 Testing File Accessibility 257 <DT> 15.10 Advantages Of The Namespace Approach 257 <DT> 15.11 The Limits Of Fixed Prefix Patterns 258 <DT> 15.12 Generalized Patterns 258 <DT> 15.13 Configuring The Namespace Pseudo-Device 259 <DT> 15.14 Summary 260 <DT> For Further Study 260 <DT> Exercises 261 </DL> <H3> Chapter 16 User Interface Design </H3> <DL> <DT> 16.1 Introduction 263 <DT> 16.2 What Is A User Interface? 263 <DT> 16.3 The Definition Of Goodness 264 <DT> 16.4 What We Seek 264 <DT> 16.5 Interface Hardware 265 <DT> 16.5.1 Keyboard Input Hardware 265 <DT> 16.5.2 Display Hardware 266 <DT> 16.5.3 Pointing Device 267 <DT> 16.6 The Two-Tier Interface Model 268 <DT> 16.7 Syntactic Flexibility 268 <DT> 16.8 Semantic Features And Issues 269 <DT> 16.8.1 Command Set 269 <DT> 16.8.2 Design Principles 269 <DT> 16.8.3 Concurrent Processing 270 <DT> 16.8.4 Interprocess Communication 271 <DT> 16.8.5 I/O And File Specification 271 <DT> 16.8.6 Response To Requests 271 <DT> 16.9 Syntactic Features And Issues 272 <DT> 16.9.1 Lexical Conventions And Quoting 272 <DT> 16.9.2 Command History And Editing 272 <DT> 16.9.3 Abbreviations And Command Aliases 273 <DT> 16.9.4 Command Name Expansion 273 <DT> 16.9.5 Typed Vs. Untyped Arguments 273 <DT> 16.9.6 Programming Language Constructs 274 <DT> 16.9.7 Windows 275 <DT> 16.10 Modifying The Syntactic Interface 276 <DT> 16.10.1 Parameterization Vs. Extensibility 277 <DT> 16.10.2 Multiple Syntactic Interfaces 277 <DT> 16.11 Summary 278 <DT> For Further Study 278 <DT> Exercises 279 </DL> <H3> Chapter 17 An Example User Interface: The Xinu Shell </H3> <DL> <DT> 17.1 Introduction 281 <DT> 17.2 The Assumed Interface Hardware 281 <DT> 17.3 A Basic Design Decision 282 <DT> 17.4 Overview Of Shell Organization And Operation 282 <DT> 17.4.1 Input Form 282 <DT> 17.5 Imperative Vs. Interrogative Interaction Form 282 <DT> 17.5.1 Processes Vs. Procedures 283 <DT> 17.5.2 File Name Independence 283 <DT> 17.6 Command Syntax 283 <DT> 17.6.1 The Definition Of Lexical Tokens 284 <DT> 17.6.2 The Definition Of Command-Line Syntax 284 <DT> 17.7 Shell Semantics 285 <DT> 17.8 Implementation Of The Xinu Shell 286 <DT> 17.8.1 Shell Definitions 286 <DT> 17.8.2 Declaration Of Commands 287 <DT> 17.8.3 Dividing The Command Line Into Tokens 289 <DT> 17.8.4 The Heart Of The Command Interpreter 291 <DT> 17.8.5 Command Lookup And Invocation Of Builtins 296 <DT> 17.8.6 I/O Redirection 296 <DT> 17.8.7 Passing Arguments To The Command Process 297 <DT> 17.8.8 Starting A Command In Background 301 <DT> 17.8.9 Foreground Processing And Command Expansion 301 <DT> 17.8.10 Moving A Command To Background 302 <DT> 17.8.11 User Login 303 <DT> 17.9 Summary 305 <DT> For Further Study 305 <DT> Exercises 306 </DL> <H3> Chapter 18 An Example Set Of Shell Commands </H3> <DL> <DT> 18.1 Introduction 309 <DT> 18.2 Command And Procedure Names 309 <DT> 18.2.1 Choosing Command Names 309 <DT> 18.2.2 Choosing Procedure Names 310 <DT> 18.3 Types Of Commands 310 <DT> 18.4 Command Implementation 311 <DT> 18.5 General Information Commands 311 <DT> 18.5.1 Time And Date Command 311 <DT> 18.5.2 Help Command 315 <DT> 18.5.3 Uptime And Ruptime Commands 317 <DT> 18.6 System Information Commands 320 <DT> 18.6.1 Bpool Command 320 <DT> 18.6.2 Devs Command 321 <DT> 18.6.3 Dg Command 322 <DT> 18.6.4 Mem Command 323 <DT> 18.6.5 Netstat Command 325 <DT> 18.6.6 Ps Command 327 <DT> 18.6.7 Rf Command 329 <DT> 18.6.8 Routes Command 330 <DT> 18.6.9 Who Command 332 <DT> 18.7 Computational Commands 333 <DT> 18.7.1 Cat Command 333 <DT> 18.7.2 Close Command 335 <DT> 18.7.3 Cp Command 336 <DT> 18.7.4 Create Command 337 <DT> 18.7.5 Echo Command 341 <DT> 18.7.6 Exit And Logout Commands 342 <DT> 18.7.7 Kill Command 343 <DT> 18.7.8 Mount Command 344 <DT> 18.7.9 Mv Command 346 <DT> 18.7.10 Reboot Command 346 <DT> 18.7.11 Rm Command 347 <DT> 18.7.12 Rls Command 348 <DT> 18.7.13 Sleep Command 350 <DT> 18.7.14 Snap Command 351 <DT> 18.7.15 Unmount Command 355 <DT> 18.8 Summary 355 <DT> For Further Study 356 <DT> Exercises 356 </DL> <H3> Chapter 19 Resolving High-Level Machine Names </H3> <DL> <DT> 19.1 Introduction 359 <DT> 19.2 Naming Machines 359 <DT> 19.3 Flat Namespace 360 <DT> 19.4 Hierarchical Names 361 <DT> 19.5 Distributed Hierarchical Namespace 361 <DT> 19.6 Subset Authority 362 <DT> 19.7 Nameservers 362 <DT> 19.8 Efficient Distributed Name Resolution 363 <DT> 19.9 Name Abbreviation 364 <DT> 19.10 The DARPA Domain Name System 364 <DT> 19.11 Domain Nameservers 365 <DT> 19.12 DARPA Domain Name Resolution 365 <DT> 19.13 Pointer Queries And Inverse Mappings 366 <DT> 19.14 Example Domain Name Resolution Software 366 <DT> 19.15 Compressed Name Format 369 <DT> 19.16 Mapping An Internet Address To A Domain Name 369 <DT> 19.17 Obtaining A Machine Name 372 <DT> 19.18 Summary 373 <DT> For Further Study 373 <DT> Exercises 373 </DL> <H3> Chapter 20 Higher-Level Protocols </H3> <DL> <DT> 20.1 Introduction 375 <DT> 20.2 Reliable End-To-End Communication 375 <DT> 20.3 The DARPA Transmission Control Protocol (TCP) 376 <DT> 20.4 Remote Interactive Computing 377 <DT> 20.5 DARPA TELNET Protocol 377 <DT> 20.6 4.2 UNIX Rlogin 378 <DT> 20.7 File Transport 378 <DT> 20.8 DARPA File Transport Protocol (FTP) 379 <DT> 20.9 Mail Transport Protocols 380 <DT> 20.10 DARPA Simplified Mail Transport Protocol (SMTP) 380 <DT> 20.11 Protocol Dependencies 380 <DT> 20.12 Summary 381 <DT> For Further Study 381 <DT> Exercises 382 <DT> Cross-Development Commands 419 <DT> System Calls 444 <DT> Library Procedures 502 <DT> Device Descriptions 529 <DT> DARPA ARP and RARP Protocol Format 541 <DT> Ethernet Link-Level Protocol Format 542 <DT> Xinu Ethernet Downloader (ELOAD) Protocol Format 543 <DT> Xinu File Server (FS) Protocol Format 545 <DT> DARPA ICMP Protocol Format 546 <DT> DARPA IP Protocol Format 547 <DT> Xinu PURPLE Downloading Protocol Format 549 <DT> DARPA UDP Protocol Format 551 </DL> <H3> Bibliography </H3> <H3> Index </H3> <BR> <BR> <H4><A HREF="osbooks.html">Return to list of Comer's OS books</A></H4> <BR> <BR> <H4><A HREF="http://www.cs.purdue.edu/people/comer">Return to Comer's homepage</A></H4> </HTML> </HTML>
</DOC>
