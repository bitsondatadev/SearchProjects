<DOC>
<DOCNO> http://www.cs.purdue.edu/homes/dec/nsd.cont.html </DOCNO>
<HTML> <HEAD> <TITLE> nsd contents </TITLE> </HEAD> <BODY> <CENTER> <H2> Table of Contents For <BR><BR> Network System Design<BR><BR> With Network Processors <BR><BR> </H2> </CENTER> <UL><UL> <BR><H3> Preface &nbsp;&nbsp;xix</H3> <BR> <H3>Chapter 1 &nbsp; Introduction And Overview &nbsp;&nbsp; 1</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>1.1 <TD ALIGN=left COLSPAN=2> Network Systems And The Internet &nbsp;&nbsp 1 <TR> <TD ALIGN=left>1.2 <TD ALIGN=left COLSPAN=2> Applications Vs. Infrastructure &nbsp;&nbsp 1 <TR> <TD ALIGN=left>1.3 <TD ALIGN=left COLSPAN=2> Network System Engineering &nbsp;&nbsp 2 <TR> <TD ALIGN=left>1.4 <TD ALIGN=left COLSPAN=2> Packet Processing &nbsp;&nbsp 2 <TR> <TD ALIGN=left>1.5 <TD ALIGN=left COLSPAN=2> Achieving High Speed &nbsp;&nbsp 3 <TR> <TD ALIGN=left>1.6 <TD ALIGN=left COLSPAN=2> Network Speed &nbsp;&nbsp 3 <TR> <TD ALIGN=left>1.7 <TD ALIGN=left COLSPAN=2> Hardware, Software, And Hybrids &nbsp;&nbsp 4 <TR> <TD ALIGN=left>1.8 <TD ALIGN=left COLSPAN=2> Scope And Organization Of The Text &nbsp;&nbsp 5 <TR> <TD ALIGN=left>1.9 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 5 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 5<BR> </TABLE> <BR> <BR> <H3>Chapter 2 &nbsp; Basic Terminology And Example Systems &nbsp;&nbsp; 7</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>2.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 7 <TR> <TD ALIGN=left>2.2 <TD ALIGN=left COLSPAN=2> Networks And Packets &nbsp;&nbsp 7 <TR> <TD ALIGN=left>2.3 <TD ALIGN=left COLSPAN=2> Connection-Oriented And Connectionless Paradigms &nbsp;&nbsp 8 <TR> <TD ALIGN=left>2.4 <TD ALIGN=left COLSPAN=2> Digital Circuits &nbsp;&nbsp 8 <TR> <TD ALIGN=left>2.5 <TD ALIGN=left COLSPAN=2> LAN And WAN Classifications &nbsp;&nbsp 9 <TR> <TD ALIGN=left>2.6 <TD ALIGN=left COLSPAN=2> The Internet And Heterogeneity &nbsp;&nbsp 9 <TR> <TD ALIGN=left>2.7 <TD ALIGN=left COLSPAN=2> Example Network Systems &nbsp;&nbsp 9 <TR> <TD ALIGN=left>2.8 <TD ALIGN=left COLSPAN=2> Broadcast Domains &nbsp;&nbsp 10 <TR> <TD ALIGN=left>2.9 <TD ALIGN=left COLSPAN=2> The Two Key Systems Used In The Internet &nbsp;&nbsp 11 <TR> <TD ALIGN=left>2.10 <TD ALIGN=left COLSPAN=2> Other Systems Used In The Internet &nbsp;&nbsp 12 <TR> <TD ALIGN=left>2.11 <TD ALIGN=left COLSPAN=2> Monitoring And Control Systems &nbsp;&nbsp 12 <TR> <TD ALIGN=left>2.12 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 13 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 13<BR> </TABLE> <BR> <BR> <H3>Chapter 3 &nbsp; Review Of Protocols And Packet Formats &nbsp;&nbsp; 15</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>3.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 15 <TR> <TD ALIGN=left>3.2 <TD ALIGN=left COLSPAN=2> Protocols And Layering &nbsp;&nbsp 15 <TR> <TD ALIGN=left>3.3 <TD ALIGN=left COLSPAN=2> Layers 1 And 2 (Physical And Network Interface) &nbsp;&nbsp 17 <TR> <TD ALIGN=left> <TD ALIGN=left>3.3.1 <TD ALIGN=left> Ethernet &nbsp;&nbsp 17 <TR> <TD ALIGN=left> <TD ALIGN=left>3.3.2 <TD ALIGN=left> Ethernet Frame Format &nbsp;&nbsp 17 <TR> <TD ALIGN=left> <TD ALIGN=left>3.3.3 <TD ALIGN=left> Ethernet Addresses &nbsp;&nbsp 18 <TR> <TD ALIGN=left> <TD ALIGN=left>3.3.4 <TD ALIGN=left> Ethernet Type Field &nbsp;&nbsp 19 <TR> <TD ALIGN=left>3.4 <TD ALIGN=left COLSPAN=2> Layer 3 (Internet) &nbsp;&nbsp 19 <TR> <TD ALIGN=left> <TD ALIGN=left>3.4.1 <TD ALIGN=left> The Internet Protocol &nbsp;&nbsp 19 <TR> <TD ALIGN=left> <TD ALIGN=left>3.4.2 <TD ALIGN=left> IP Datagram Format &nbsp;&nbsp 19 <TR> <TD ALIGN=left> <TD ALIGN=left>3.4.3 <TD ALIGN=left> IP Addresses &nbsp;&nbsp 20 <TR> <TD ALIGN=left>3.5 <TD ALIGN=left COLSPAN=2> Layer 4 (Transport) &nbsp;&nbsp 20 <TR> <TD ALIGN=left> <TD ALIGN=left>3.5.1 <TD ALIGN=left> UDP And TCP &nbsp;&nbsp 20 <TR> <TD ALIGN=left> <TD ALIGN=left>3.5.2 <TD ALIGN=left> UDP Datagram Format &nbsp;&nbsp 21 <TR> <TD ALIGN=left> <TD ALIGN=left>3.5.3 <TD ALIGN=left> TCP Segment Format &nbsp;&nbsp 21 <TR> <TD ALIGN=left>3.6 <TD ALIGN=left COLSPAN=2> Protocol Port Numbers And Demultiplexing &nbsp;&nbsp 22 <TR> <TD ALIGN=left>3.7 <TD ALIGN=left COLSPAN=2> Encapsulation And Transmission &nbsp;&nbsp 23 <TR> <TD ALIGN=left>3.8 <TD ALIGN=left COLSPAN=2> Address Resolution Protocol &nbsp;&nbsp 23 <TR> <TD ALIGN=left>3.9 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 24 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 24<BR> </TABLE> <BR> <BR><H3> PART I &nbsp;&nbsp; Traditional Protocol Processing Systems &nbsp;&nbsp; 27</H3> <BR> <H3>Chapter 4 &nbsp; Conventional Computer Hardware Architecture &nbsp;&nbsp; 29</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>4.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 29 <TR> <TD ALIGN=left>4.2 <TD ALIGN=left COLSPAN=2> A Conventional Computer System &nbsp;&nbsp 29 <TR> <TD ALIGN=left>4.3 <TD ALIGN=left COLSPAN=2> Network Interface Cards &nbsp;&nbsp 30 <TR> <TD ALIGN=left>4.4 <TD ALIGN=left COLSPAN=2> Definition Of A Bus &nbsp;&nbsp 31 <TR> <TD ALIGN=left>4.5 <TD ALIGN=left COLSPAN=2> The Bus Address Space &nbsp;&nbsp 32 <TR> <TD ALIGN=left>4.6 <TD ALIGN=left COLSPAN=2> The Fetch-Store Paradigm &nbsp;&nbsp 33 <TR> <TD ALIGN=left>4.7 <TD ALIGN=left COLSPAN=2> Network Interface Card Functionality &nbsp;&nbsp 34 <TR> <TD ALIGN=left>4.8 <TD ALIGN=left COLSPAN=2> NIC Optimizations For High Speed &nbsp;&nbsp 34 <TR> <TD ALIGN=left>4.9 <TD ALIGN=left COLSPAN=2> Onboard Address Recognition &nbsp;&nbsp 35 <TR> <TD ALIGN=left> <TD ALIGN=left>4.9.1 <TD ALIGN=left> Unicast And Broadcast Recognition And Filtering &nbsp;&nbsp 35 <TR> <TD ALIGN=left> <TD ALIGN=left>4.9.2 <TD ALIGN=left> Multicast Recognition And Filtering &nbsp;&nbsp 35 <TR> <TD ALIGN=left>4.10 <TD ALIGN=left COLSPAN=2> Onboard Packet Buffering &nbsp;&nbsp 36 <TR> <TD ALIGN=left>4.11 <TD ALIGN=left COLSPAN=2> Direct Memory Access &nbsp;&nbsp 37 <TR> <TD ALIGN=left>4.12 <TD ALIGN=left COLSPAN=2> Operation And Data Chaining &nbsp;&nbsp 38 <TR> <TD ALIGN=left>4.13 <TD ALIGN=left COLSPAN=2> Data Flow Diagram &nbsp;&nbsp 39 <TR> <TD ALIGN=left>4.14 <TD ALIGN=left COLSPAN=2> Promiscuous Mode &nbsp;&nbsp 39 <TR> <TD ALIGN=left>4.15 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 40 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 40<BR> </TABLE> <BR> <BR> <H3>Chapter 5 &nbsp; Basic Packet Processing: Algorithms And Data Structures &nbsp;&nbsp; 43</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>5.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 43 <TR> <TD ALIGN=left>5.2 <TD ALIGN=left COLSPAN=2> State Information and Resource Exhaustion &nbsp;&nbsp 43 <TR> <TD ALIGN=left>5.3 <TD ALIGN=left COLSPAN=2> Packet Buffer Allocation &nbsp;&nbsp 44 <TR> <TD ALIGN=left>5.4 <TD ALIGN=left COLSPAN=2> Packet Buffer Size And Copying &nbsp;&nbsp 45 <TR> <TD ALIGN=left>5.5 <TD ALIGN=left COLSPAN=2> Protocol Layering And Copying &nbsp;&nbsp 45 <TR> <TD ALIGN=left>5.6 <TD ALIGN=left COLSPAN=2> Heterogeneity And Network Byte Order &nbsp;&nbsp 46 <TR> <TD ALIGN=left>5.7 <TD ALIGN=left COLSPAN=2> Bridge Algorithm &nbsp;&nbsp 47 <TR> <TD ALIGN=left>5.8 <TD ALIGN=left COLSPAN=2> Table Lookup And Hashing &nbsp;&nbsp 49 <TR> <TD ALIGN=left>5.9 <TD ALIGN=left COLSPAN=2> IP Datagram Fragmentation And Reassembly &nbsp;&nbsp 50 <TR> <TD ALIGN=left> <TD ALIGN=left>5.9.1 <TD ALIGN=left> Interpretation Of The Flags Field &nbsp;&nbsp 51 <TR> <TD ALIGN=left> <TD ALIGN=left>5.9.2 <TD ALIGN=left> Interpretation Of The Fragment Offset Field &nbsp;&nbsp 51 <TR> <TD ALIGN=left> <TD ALIGN=left>5.9.3 <TD ALIGN=left> IP Fragmentation Algorithm &nbsp;&nbsp 52 <TR> <TD ALIGN=left> <TD ALIGN=left>5.9.4 <TD ALIGN=left> Fragmenting A Fragment &nbsp;&nbsp 53 <TR> <TD ALIGN=left> <TD ALIGN=left>5.9.5 <TD ALIGN=left> IP Reassembly &nbsp;&nbsp 53 <TR> <TD ALIGN=left> <TD ALIGN=left>5.9.6 <TD ALIGN=left> Grouping Fragments Together &nbsp;&nbsp 54 <TR> <TD ALIGN=left> <TD ALIGN=left>5.9.7 <TD ALIGN=left> Fragment Position &nbsp;&nbsp 54 <TR> <TD ALIGN=left> <TD ALIGN=left>5.9.8 <TD ALIGN=left> IP Reassembly Algorithm &nbsp;&nbsp 55 <TR> <TD ALIGN=left>5.10 <TD ALIGN=left COLSPAN=2> IP Datagram Forwarding &nbsp;&nbsp 56 <TR> <TD ALIGN=left>5.11 <TD ALIGN=left COLSPAN=2> IP Forwarding Algorithm &nbsp;&nbsp 57 <TR> <TD ALIGN=left>5.12 <TD ALIGN=left COLSPAN=2> High-Speed IP Forwarding &nbsp;&nbsp 57 <TR> <TD ALIGN=left>5.13 <TD ALIGN=left COLSPAN=2> TCP Connection Recognition Algorithm &nbsp;&nbsp 59 <TR> <TD ALIGN=left>5.14 <TD ALIGN=left COLSPAN=2> TCP Splicing Algorithm &nbsp;&nbsp 60 <TR> <TD ALIGN=left>5.15 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 62 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 63<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 63<BR> </TABLE> <BR> <BR> <H3>Chapter 6 &nbsp; Packet Processing Functions &nbsp;&nbsp; 67</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>6.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 67 <TR> <TD ALIGN=left>6.2 <TD ALIGN=left COLSPAN=2> Packet Processing &nbsp;&nbsp 68 <TR> <TD ALIGN=left>6.3 <TD ALIGN=left COLSPAN=2> Address Lookup And Packet Forwarding &nbsp;&nbsp 68 <TR> <TD ALIGN=left>6.4 <TD ALIGN=left COLSPAN=2> Error Detection And Correction &nbsp;&nbsp 69 <TR> <TD ALIGN=left>6.5 <TD ALIGN=left COLSPAN=2> Fragmentation, Segmentation, And Reassembly &nbsp;&nbsp 70 <TR> <TD ALIGN=left>6.6 <TD ALIGN=left COLSPAN=2> Frame And Protocol Demultiplexing &nbsp;&nbsp 70 <TR> <TD ALIGN=left>6.7 <TD ALIGN=left COLSPAN=2> Packet Classification &nbsp;&nbsp 71 <TR> <TD ALIGN=left> <TD ALIGN=left>6.7.1 <TD ALIGN=left> Static And Dynamic Classification &nbsp;&nbsp 71 <TR> <TD ALIGN=left> <TD ALIGN=left>6.7.2 <TD ALIGN=left> Demultiplexing Vs. Classification &nbsp;&nbsp 71 <TR> <TD ALIGN=left> <TD ALIGN=left>6.7.3 <TD ALIGN=left> Optimized Packet Processing &nbsp;&nbsp 72 <TR> <TD ALIGN=left> <TD ALIGN=left>6.7.4 <TD ALIGN=left> Classification Languages &nbsp;&nbsp 72 <TR> <TD ALIGN=left>6.8 <TD ALIGN=left COLSPAN=2> Queueing And Packet Discard &nbsp;&nbsp 73 <TR> <TD ALIGN=left> <TD ALIGN=left>6.8.1 <TD ALIGN=left> Basic Queueing &nbsp;&nbsp 73 <TR> <TD ALIGN=left> <TD ALIGN=left>6.8.2 <TD ALIGN=left> Priority Mechanisms &nbsp;&nbsp 74 <TR> <TD ALIGN=left> <TD ALIGN=left>6.8.3 <TD ALIGN=left> Packet Discard &nbsp;&nbsp 75 <TR> <TD ALIGN=left>6.9 <TD ALIGN=left COLSPAN=2> Scheduling And Timing &nbsp;&nbsp 75 <TR> <TD ALIGN=left>6.10 <TD ALIGN=left COLSPAN=2> Security: Authentication And Privacy &nbsp;&nbsp 76 <TR> <TD ALIGN=left>6.11 <TD ALIGN=left COLSPAN=2> Traffic Measurement And Policing &nbsp;&nbsp 76 <TR> <TD ALIGN=left>6.12 <TD ALIGN=left COLSPAN=2> Traffic Shaping &nbsp;&nbsp 77 <TR> <TD ALIGN=left>6.13 <TD ALIGN=left COLSPAN=2> Timer Management &nbsp;&nbsp 79 <TR> <TD ALIGN=left>6.14 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 80 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 80<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 80<BR> </TABLE> <BR> <BR> <H3>Chapter 7 &nbsp; Software Architectures For Protocol Processing &nbsp;&nbsp; 83</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>7.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 83 <TR> <TD ALIGN=left>7.2 <TD ALIGN=left COLSPAN=2> Implementation Of Packet Processing In An Application &nbsp;&nbsp 83 <TR> <TD ALIGN=left>7.3 <TD ALIGN=left COLSPAN=2> Fast Packet Processing In Software &nbsp;&nbsp 84 <TR> <TD ALIGN=left>7.4 <TD ALIGN=left COLSPAN=2> Embedded Systems &nbsp;&nbsp 84 <TR> <TD ALIGN=left>7.5 <TD ALIGN=left COLSPAN=2> Operating Systems Implementation &nbsp;&nbsp 85 <TR> <TD ALIGN=left>7.6 <TD ALIGN=left COLSPAN=2> Software Interrupts And Priorities &nbsp;&nbsp 85 <TR> <TD ALIGN=left>7.7 <TD ALIGN=left COLSPAN=2> Multiple Priorities And Kernel Threads &nbsp;&nbsp 87 <TR> <TD ALIGN=left>7.8 <TD ALIGN=left COLSPAN=2> Thread Synchronization &nbsp;&nbsp 88 <TR> <TD ALIGN=left>7.9 <TD ALIGN=left COLSPAN=2> Software For Layered Protocols &nbsp;&nbsp 88 <TR> <TD ALIGN=left> <TD ALIGN=left>7.9.1 <TD ALIGN=left> One Thread Per Layer &nbsp;&nbsp 89 <TR> <TD ALIGN=left> <TD ALIGN=left>7.9.2 <TD ALIGN=left> One Thread Per Protocol &nbsp;&nbsp 90 <TR> <TD ALIGN=left> <TD ALIGN=left>7.9.3 <TD ALIGN=left> Multiple Threads Per Protocol &nbsp;&nbsp 90 <TR> <TD ALIGN=left> <TD ALIGN=left>7.9.4 <TD ALIGN=left> Separate Timer Management Threads &nbsp;&nbsp 90 <TR> <TD ALIGN=left> <TD ALIGN=left>7.9.5 <TD ALIGN=left> One Thread Per Packet &nbsp;&nbsp 91 <TR> <TD ALIGN=left>7.10 <TD ALIGN=left COLSPAN=2> Asynchronous Vs. Synchronous Programming &nbsp;&nbsp 92 <TR> <TD ALIGN=left>7.11 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 92 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 93<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 93<BR> </TABLE> <BR> <BR> <H3>Chapter 8 &nbsp; Hardware Architectures For Protocol Processing &nbsp;&nbsp; 95</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>8.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 95 <TR> <TD ALIGN=left>8.2 <TD ALIGN=left COLSPAN=2> Network Systems Architecture &nbsp;&nbsp 95 <TR> <TD ALIGN=left>8.3 <TD ALIGN=left COLSPAN=2> The Traditional Software Router &nbsp;&nbsp 96 <TR> <TD ALIGN=left>8.4 <TD ALIGN=left COLSPAN=2> Aggregate Data Rate &nbsp;&nbsp 97 <TR> <TD ALIGN=left>8.5 <TD ALIGN=left COLSPAN=2> Aggregate Packet Rate &nbsp;&nbsp 97 <TR> <TD ALIGN=left>8.6 <TD ALIGN=left COLSPAN=2> Packet Rate And Software Router Feasibility &nbsp;&nbsp 99 <TR> <TD ALIGN=left>8.7 <TD ALIGN=left COLSPAN=2> Overcoming The Single CPU Bottleneck &nbsp;&nbsp 101 <TR> <TD ALIGN=left>8.8 <TD ALIGN=left COLSPAN=2> Fine-Grain Parallelism &nbsp;&nbsp 102 <TR> <TD ALIGN=left>8.9 <TD ALIGN=left COLSPAN=2> Symmetric Coarse-Grain Parallelism &nbsp;&nbsp 102 <TR> <TD ALIGN=left>8.10 <TD ALIGN=left COLSPAN=2> Asymmetric Coarse-Grain Parallelism &nbsp;&nbsp 103 <TR> <TD ALIGN=left>8.11 <TD ALIGN=left COLSPAN=2> Special Purpose Coprocessors &nbsp;&nbsp 103 <TR> <TD ALIGN=left>8.12 <TD ALIGN=left COLSPAN=2> ASIC Coprocessor Implementation &nbsp;&nbsp 104 <TR> <TD ALIGN=left>8.13 <TD ALIGN=left COLSPAN=2> NICs With Onboard Processing &nbsp;&nbsp 105 <TR> <TD ALIGN=left>8.14 <TD ALIGN=left COLSPAN=2> Smart NICs With Onboard Stacks &nbsp;&nbsp 106 <TR> <TD ALIGN=left>8.15 <TD ALIGN=left COLSPAN=2> Cell Switching &nbsp;&nbsp 106 <TR> <TD ALIGN=left>8.16 <TD ALIGN=left COLSPAN=2> Data Pipelines &nbsp;&nbsp 107 <TR> <TD ALIGN=left>8.17 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 109 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 109<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 109<BR> </TABLE> <BR> <BR> <H3>Chapter 9 &nbsp; Classification And Forwarding &nbsp;&nbsp; 113</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>9.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 113 <TR> <TD ALIGN=left>9.2 <TD ALIGN=left COLSPAN=2> Inherent Limits Of Demultiplexing &nbsp;&nbsp 113 <TR> <TD ALIGN=left>9.3 <TD ALIGN=left COLSPAN=2> Packet Classification &nbsp;&nbsp 114 <TR> <TD ALIGN=left>9.4 <TD ALIGN=left COLSPAN=2> Software Implementation Of Classification &nbsp;&nbsp 115 <TR> <TD ALIGN=left>9.5 <TD ALIGN=left COLSPAN=2> Optimizing Software-Based Classification &nbsp;&nbsp 116 <TR> <TD ALIGN=left>9.6 <TD ALIGN=left COLSPAN=2> Software Classification On Special-Purpose Hardware &nbsp;&nbsp 117 <TR> <TD ALIGN=left>9.7 <TD ALIGN=left COLSPAN=2> Hardware Implementation Of Classification &nbsp;&nbsp 117 <TR> <TD ALIGN=left>9.8 <TD ALIGN=left COLSPAN=2> Optimized Classification Of Multiple Rule Sets &nbsp;&nbsp 118 <TR> <TD ALIGN=left>9.9 <TD ALIGN=left COLSPAN=2> Classification Of Variable-Size Headers &nbsp;&nbsp 120 <TR> <TD ALIGN=left>9.10 <TD ALIGN=left COLSPAN=2> Hybrid Hardware/Software Classification &nbsp;&nbsp 121 <TR> <TD ALIGN=left>9.11 <TD ALIGN=left COLSPAN=2> Dynamic Vs. Static Classification &nbsp;&nbsp 122 <TR> <TD ALIGN=left>9.12 <TD ALIGN=left COLSPAN=2> Fine-Grain Flow Creation &nbsp;&nbsp 123 <TR> <TD ALIGN=left>9.13 <TD ALIGN=left COLSPAN=2> Flow Forwarding In A Connection-Oriented Network &nbsp;&nbsp 124 <TR> <TD ALIGN=left>9.14 <TD ALIGN=left COLSPAN=2> Connectionless Network Classification And Forwarding &nbsp;&nbsp 124 <TR> <TD ALIGN=left>9.15 <TD ALIGN=left COLSPAN=2> Second Generation Network Systems &nbsp;&nbsp 125 <TR> <TD ALIGN=left>9.16 <TD ALIGN=left COLSPAN=2> Embedded Processors In Second Generation Systems &nbsp;&nbsp 126 <TR> <TD ALIGN=left>9.17 <TD ALIGN=left COLSPAN=2> Classification And Forwarding Chips &nbsp;&nbsp 127 <TR> <TD ALIGN=left>9.18 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 128 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 128<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 128<BR> </TABLE> <BR> <BR> <H3>Chapter 10 &nbsp; Switching Fabrics &nbsp;&nbsp; 131</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>10.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 131 <TR> <TD ALIGN=left>10.2 <TD ALIGN=left COLSPAN=2> Bandwidth Of An Internal Fast Path &nbsp;&nbsp 131 <TR> <TD ALIGN=left>10.3 <TD ALIGN=left COLSPAN=2> The Switching Fabric Concept &nbsp;&nbsp 132 <TR> <TD ALIGN=left>10.4 <TD ALIGN=left COLSPAN=2> Synchronous And Asynchronous Fabrics &nbsp;&nbsp 133 <TR> <TD ALIGN=left>10.5 <TD ALIGN=left COLSPAN=2> A Taxonomy Of Switching Fabric Architectures &nbsp;&nbsp 134 <TR> <TD ALIGN=left>10.6 <TD ALIGN=left COLSPAN=2> Dedicated Internal Paths And Port Contention &nbsp;&nbsp 134 <TR> <TD ALIGN=left>10.7 <TD ALIGN=left COLSPAN=2> Crossbar Architecture &nbsp;&nbsp 135 <TR> <TD ALIGN=left>10.8 <TD ALIGN=left COLSPAN=2> Basic Queueing &nbsp;&nbsp 137 <TR> <TD ALIGN=left>10.9 <TD ALIGN=left COLSPAN=2> Time Division Solutions: Sharing Data Paths &nbsp;&nbsp 139 <TR> <TD ALIGN=left>10.10 <TD ALIGN=left COLSPAN=2> Shared Bus Architecture &nbsp;&nbsp 139 <TR> <TD ALIGN=left>10.11 <TD ALIGN=left COLSPAN=2> Other Shared Medium Architectures &nbsp;&nbsp 140 <TR> <TD ALIGN=left>10.12 <TD ALIGN=left COLSPAN=2> Shared Memory Architecture &nbsp;&nbsp 141 <TR> <TD ALIGN=left>10.13 <TD ALIGN=left COLSPAN=2> Multistage Fabrics &nbsp;&nbsp 142 <TR> <TD ALIGN=left>10.14 <TD ALIGN=left COLSPAN=2> Banyan Architecture &nbsp;&nbsp 143 <TR> <TD ALIGN=left>10.15 <TD ALIGN=left COLSPAN=2> Scaling A Banyan Switch &nbsp;&nbsp 144 <TR> <TD ALIGN=left>10.16 <TD ALIGN=left COLSPAN=2> Commercial Technologies &nbsp;&nbsp 146 <TR> <TD ALIGN=left>10.17 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 146 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 147<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 147<BR> </TABLE> <BR> <BR><H3> PART II &nbsp;&nbsp; Network Processor Technology &nbsp;&nbsp; 149</H3> <BR> <H3>Chapter 11 &nbsp; Network Processors: Motivation And Purpose &nbsp;&nbsp; 151</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>11.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 151 <TR> <TD ALIGN=left>11.2 <TD ALIGN=left COLSPAN=2> The CPU In A Second Generation Architecture &nbsp;&nbsp 151 <TR> <TD ALIGN=left>11.3 <TD ALIGN=left COLSPAN=2> Third Generation Network Systems &nbsp;&nbsp 152 <TR> <TD ALIGN=left>11.4 <TD ALIGN=left COLSPAN=2> The Motivation For Embedded Processors &nbsp;&nbsp 153 <TR> <TD ALIGN=left>11.5 <TD ALIGN=left COLSPAN=2> RISC vs. CISC &nbsp;&nbsp 153 <TR> <TD ALIGN=left>11.6 <TD ALIGN=left COLSPAN=2> The Need For Custom Silicon &nbsp;&nbsp 154 <TR> <TD ALIGN=left>11.7 <TD ALIGN=left COLSPAN=2> Definition Of A Network Processor &nbsp;&nbsp 155 <TR> <TD ALIGN=left>11.8 <TD ALIGN=left COLSPAN=2> A Fundamental Idea: Flexibility Through Programmability &nbsp;&nbsp 156 <TR> <TD ALIGN=left>11.9 <TD ALIGN=left COLSPAN=2> Instruction Set &nbsp;&nbsp 157 <TR> <TD ALIGN=left>11.10 <TD ALIGN=left COLSPAN=2> Scalability With Parallelism And Pipelining &nbsp;&nbsp 157 <TR> <TD ALIGN=left>11.11 <TD ALIGN=left COLSPAN=2> The Costs And Benefits Of Network Processors &nbsp;&nbsp 158 <TR> <TD ALIGN=left>11.12 <TD ALIGN=left COLSPAN=2> The Status And Future Of Network Processors &nbsp;&nbsp 159 <TR> <TD ALIGN=left>11.13 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 160 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 160<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 160<BR> </TABLE> <BR> <BR> <H3>Chapter 12 &nbsp; The Complexity Of Network Processor Design &nbsp;&nbsp; 163</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>12.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 163 <TR> <TD ALIGN=left>12.2 <TD ALIGN=left COLSPAN=2> Network Processor Functionality &nbsp;&nbsp 163 <TR> <TD ALIGN=left>12.3 <TD ALIGN=left COLSPAN=2> Packet Processing Functions &nbsp;&nbsp 164 <TR> <TD ALIGN=left>12.4 <TD ALIGN=left COLSPAN=2> Ingress And Egress Processing &nbsp;&nbsp 165 <TR> <TD ALIGN=left> <TD ALIGN=left>12.4.1 <TD ALIGN=left> Ingress Processing &nbsp;&nbsp 165 <TR> <TD ALIGN=left> <TD ALIGN=left>12.4.2 <TD ALIGN=left> Egress Processing &nbsp;&nbsp 166 <TR> <TD ALIGN=left>12.5 <TD ALIGN=left COLSPAN=2> Parallel And Distributed Architecture &nbsp;&nbsp 168 <TR> <TD ALIGN=left>12.6 <TD ALIGN=left COLSPAN=2> The Architectural Roles Of Network Processors &nbsp;&nbsp 169 <TR> <TD ALIGN=left>12.7 <TD ALIGN=left COLSPAN=2> Consequences For Each Architectural Role &nbsp;&nbsp 169 <TR> <TD ALIGN=left>12.8 <TD ALIGN=left COLSPAN=2> Macroscopic Data Pipelining And Heterogeneity &nbsp;&nbsp 171 <TR> <TD ALIGN=left>12.9 <TD ALIGN=left COLSPAN=2> Network Processor Design And Software Emulation &nbsp;&nbsp 171 <TR> <TD ALIGN=left>12.10 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 172 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 172<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 173<BR> </TABLE> <BR> <BR> <H3>Chapter 13 &nbsp; Network Processor Architectures &nbsp;&nbsp; 175</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>13.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 175 <TR> <TD ALIGN=left>13.2 <TD ALIGN=left COLSPAN=2> Architectural Variety &nbsp;&nbsp 175 <TR> <TD ALIGN=left>13.3 <TD ALIGN=left COLSPAN=2> Primary Architectural Characteristics &nbsp;&nbsp 176 <TR> <TD ALIGN=left> <TD ALIGN=left>13.3.1 <TD ALIGN=left> Processor Hierarchy &nbsp;&nbsp 176 <TR> <TD ALIGN=left> <TD ALIGN=left>13.3.2 <TD ALIGN=left> Memory Hierarchy &nbsp;&nbsp 177 <TR> <TD ALIGN=left> <TD ALIGN=left>13.3.3 <TD ALIGN=left> Internal Transfer Mechanisms &nbsp;&nbsp 179 <TR> <TD ALIGN=left> <TD ALIGN=left>13.3.4 <TD ALIGN=left> External Interface And Communication Mechanisms &nbsp;&nbsp 180 <TR> <TD ALIGN=left> <TD ALIGN=left>13.3.5 <TD ALIGN=left> Special-Purpose Hardware &nbsp;&nbsp 181 <TR> <TD ALIGN=left> <TD ALIGN=left>13.3.6 <TD ALIGN=left> Polling And Notification Mechanisms &nbsp;&nbsp 181 <TR> <TD ALIGN=left> <TD ALIGN=left>13.3.7 <TD ALIGN=left> Concurrent Execution Support &nbsp;&nbsp 182 <TR> <TD ALIGN=left> <TD ALIGN=left>13.3.8 <TD ALIGN=left> Hardware Support For Programming &nbsp;&nbsp 183 <TR> <TD ALIGN=left> <TD ALIGN=left>13.3.9 <TD ALIGN=left> Hardware And Software Dispatch Mechanisms &nbsp;&nbsp 183 <TR> <TD ALIGN=left> <TD ALIGN=left>13.3.10 <TD ALIGN=left> Implicit And Explicit Parallelism &nbsp;&nbsp 184 <TR> <TD ALIGN=left>13.4 <TD ALIGN=left COLSPAN=2> Architecture, Packet Flow, And Clock Rates &nbsp;&nbsp 184 <TR> <TD ALIGN=left>13.5 <TD ALIGN=left COLSPAN=2> Software Architecture &nbsp;&nbsp 187 <TR> <TD ALIGN=left>13.6 <TD ALIGN=left COLSPAN=2> Assigning Functionality To The Processor Hierarchy &nbsp;&nbsp 187 <TR> <TD ALIGN=left>13.7 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 189 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 190<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 190<BR> </TABLE> <BR> <BR> <H3>Chapter 14 &nbsp; Issues In Scaling A Network Processor &nbsp;&nbsp; 193</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>14.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 193 <TR> <TD ALIGN=left>14.2 <TD ALIGN=left COLSPAN=2> The Processing Hierarchy And Scaling &nbsp;&nbsp 193 <TR> <TD ALIGN=left>14.3 <TD ALIGN=left COLSPAN=2> Scaling By Making Processors Faster &nbsp;&nbsp 194 <TR> <TD ALIGN=left>14.4 <TD ALIGN=left COLSPAN=2> Scaling By Increasing The Number of Processors &nbsp;&nbsp 194 <TR> <TD ALIGN=left>14.5 <TD ALIGN=left COLSPAN=2> Scaling By Increasing Processor Types &nbsp;&nbsp 195 <TR> <TD ALIGN=left>14.6 <TD ALIGN=left COLSPAN=2> Scaling A Memory Hierarchy &nbsp;&nbsp 196 <TR> <TD ALIGN=left>14.7 <TD ALIGN=left COLSPAN=2> Scaling By Increasing Memory Size &nbsp;&nbsp 198 <TR> <TD ALIGN=left>14.8 <TD ALIGN=left COLSPAN=2> Scaling By Increasing Memory Bandwidth &nbsp;&nbsp 198 <TR> <TD ALIGN=left>14.9 <TD ALIGN=left COLSPAN=2> Scaling By Increasing Types Of Memory &nbsp;&nbsp 199 <TR> <TD ALIGN=left>14.10 <TD ALIGN=left COLSPAN=2> Scaling By Adding Memory Caches &nbsp;&nbsp 200 <TR> <TD ALIGN=left>14.11 <TD ALIGN=left COLSPAN=2> Scaling With Content Addressable Memory &nbsp;&nbsp 201 <TR> <TD ALIGN=left>14.12 <TD ALIGN=left COLSPAN=2> Using CAM for Packet Classification &nbsp;&nbsp 203 <TR> <TD ALIGN=left>14.13 <TD ALIGN=left COLSPAN=2> Other Limitations On Scale &nbsp;&nbsp 205 <TR> <TD ALIGN=left>14.14 <TD ALIGN=left COLSPAN=2> Software Scalability &nbsp;&nbsp 206 <TR> <TD ALIGN=left>14.15 <TD ALIGN=left COLSPAN=2> Bottlenecks And Scale &nbsp;&nbsp 207 <TR> <TD ALIGN=left>14.16 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 207 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 208<BR> </TABLE> <BR> <BR> <H3>Chapter 15 &nbsp; Examples Of Commercial Network Processors &nbsp;&nbsp; 211</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>15.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 211 <TR> <TD ALIGN=left>15.2 <TD ALIGN=left COLSPAN=2> An Explosion Of Commercial Products &nbsp;&nbsp 211 <TR> <TD ALIGN=left>15.3 <TD ALIGN=left COLSPAN=2> A Selection of Products &nbsp;&nbsp 212 <TR> <TD ALIGN=left>15.4 <TD ALIGN=left COLSPAN=2> Multi-Chip Pipeline (Agere) &nbsp;&nbsp 212 <TR> <TD ALIGN=left>15.5 <TD ALIGN=left COLSPAN=2> Augmented RISC Processor (Alchemy) &nbsp;&nbsp 216 <TR> <TD ALIGN=left>15.6 <TD ALIGN=left COLSPAN=2> Embedded Processor Plus Coprocessors (AMCC) &nbsp;&nbsp 217 <TR> <TD ALIGN=left>15.7 <TD ALIGN=left COLSPAN=2> Pipeline Of Homogeneous Processors (Cisco) &nbsp;&nbsp 219 <TR> <TD ALIGN=left>15.8 <TD ALIGN=left COLSPAN=2> Configurable Instruction Set Processors (Cognigine) &nbsp;&nbsp 220 <TR> <TD ALIGN=left>15.9 <TD ALIGN=left COLSPAN=2> Pipeline Of Heterogeneous Processors (EZchip) &nbsp;&nbsp 221 <TR> <TD ALIGN=left>15.10 <TD ALIGN=left COLSPAN=2> Extensive And Diverse Processors (IBM) &nbsp;&nbsp 223 <TR> <TD ALIGN=left>15.11 <TD ALIGN=left COLSPAN=2> Flexible RISC Plus Coprocessors (Motorola) &nbsp;&nbsp 225 <TR> <TD ALIGN=left>15.12 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 229 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 229<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 229<BR> </TABLE> <BR> <BR> <H3>Chapter 16 &nbsp; Languages Used For Classification &nbsp;&nbsp; 231</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>16.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 231 <TR> <TD ALIGN=left>16.2 <TD ALIGN=left COLSPAN=2> Optimized Classification &nbsp;&nbsp 231 <TR> <TD ALIGN=left>16.3 <TD ALIGN=left COLSPAN=2> Imperative And Declarative Paradigms &nbsp;&nbsp 232 <TR> <TD ALIGN=left>16.4 <TD ALIGN=left COLSPAN=2> A Programming Language For Classification &nbsp;&nbsp 233 <TR> <TD ALIGN=left>16.5 <TD ALIGN=left COLSPAN=2> Automated Translation &nbsp;&nbsp 233 <TR> <TD ALIGN=left>16.6 <TD ALIGN=left COLSPAN=2> Language Features That Aid Programming &nbsp;&nbsp 234 <TR> <TD ALIGN=left>16.7 <TD ALIGN=left COLSPAN=2> The Relationship Between Language And Hardware &nbsp;&nbsp 234 <TR> <TD ALIGN=left>16.8 <TD ALIGN=left COLSPAN=2> Efficiency And Execution Speed &nbsp;&nbsp 235 <TR> <TD ALIGN=left>16.9 <TD ALIGN=left COLSPAN=2> Commercial Classification Languages &nbsp;&nbsp 236 <TR> <TD ALIGN=left>16.10 <TD ALIGN=left COLSPAN=2> Intel's Network Classification Language (NCL) &nbsp;&nbsp 236 <TR> <TD ALIGN=left>16.11 <TD ALIGN=left COLSPAN=2> An Example Of NCL Code &nbsp;&nbsp 237 <TR> <TD ALIGN=left>16.12 <TD ALIGN=left COLSPAN=2> NCL Intrinsic Functions &nbsp;&nbsp 240 <TR> <TD ALIGN=left>16.13 <TD ALIGN=left COLSPAN=2> Predicates &nbsp;&nbsp 241 <TR> <TD ALIGN=left>16.14 <TD ALIGN=left COLSPAN=2> Conditional Rule Execution &nbsp;&nbsp 241 <TR> <TD ALIGN=left>16.15 <TD ALIGN=left COLSPAN=2> Incremental Protocol Definition &nbsp;&nbsp 242 <TR> <TD ALIGN=left>16.16 <TD ALIGN=left COLSPAN=2> NCL Set Facility &nbsp;&nbsp 243 <TR> <TD ALIGN=left>16.17 <TD ALIGN=left COLSPAN=2> Other NCL Features &nbsp;&nbsp 244 <TR> <TD ALIGN=left>16.18 <TD ALIGN=left COLSPAN=2> Agere's Functional Programming Language (FPL) &nbsp;&nbsp 245 <TR> <TD ALIGN=left>16.19 <TD ALIGN=left COLSPAN=2> Two Pass Processing &nbsp;&nbsp 245 <TR> <TD ALIGN=left>16.20 <TD ALIGN=left COLSPAN=2> Designating The First And Second Pass &nbsp;&nbsp 247 <TR> <TD ALIGN=left>16.21 <TD ALIGN=left COLSPAN=2> Using Patterns For Conditionals &nbsp;&nbsp 247 <TR> <TD ALIGN=left>16.22 <TD ALIGN=left COLSPAN=2> Symbolic Constants &nbsp;&nbsp 249 <TR> <TD ALIGN=left>16.23 <TD ALIGN=left COLSPAN=2> Example FPL Code For Second Pass Processing &nbsp;&nbsp 249 <TR> <TD ALIGN=left>16.24 <TD ALIGN=left COLSPAN=2> Sequential Pattern Matching Paradigm &nbsp;&nbsp 250 <TR> <TD ALIGN=left>16.25 <TD ALIGN=left COLSPAN=2> Tree Functions And The BITS Default &nbsp;&nbsp 252 <TR> <TD ALIGN=left>16.26 <TD ALIGN=left COLSPAN=2> Return Values &nbsp;&nbsp 252 <TR> <TD ALIGN=left>16.27 <TD ALIGN=left COLSPAN=2> Passing Information To The Routing Engine &nbsp;&nbsp 252 <TR> <TD ALIGN=left>16.28 <TD ALIGN=left COLSPAN=2> Access To Built-in And External Functions &nbsp;&nbsp 253 <TR> <TD ALIGN=left>16.29 <TD ALIGN=left COLSPAN=2> Other FPL Features &nbsp;&nbsp 253 <TR> <TD ALIGN=left> <TD ALIGN=left>16.29.1 <TD ALIGN=left> FPL Constant Syntax &nbsp;&nbsp 253 <TR> <TD ALIGN=left> <TD ALIGN=left>16.29.2 <TD ALIGN=left> FPL Variables &nbsp;&nbsp 254 <TR> <TD ALIGN=left> <TD ALIGN=left>16.29.3 <TD ALIGN=left> FPL Support For Dynamic Classification &nbsp;&nbsp 255 <TR> <TD ALIGN=left>16.30 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 255 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 255<BR> </TABLE> <BR> <BR> <H3>Chapter 17 &nbsp; Design Tradeoffs And Consequences &nbsp;&nbsp; 259</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>17.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 259 <TR> <TD ALIGN=left>17.2 <TD ALIGN=left COLSPAN=2> Low Cost Vs. Performance &nbsp;&nbsp 259 <TR> <TD ALIGN=left>17.3 <TD ALIGN=left COLSPAN=2> Programmability Vs. Processing Speed &nbsp;&nbsp 260 <TR> <TD ALIGN=left>17.4 <TD ALIGN=left COLSPAN=2> Performance: Packet Rate, Data Rate, And Bursts &nbsp;&nbsp 260 <TR> <TD ALIGN=left>17.5 <TD ALIGN=left COLSPAN=2> Speed Vs. Functionality &nbsp;&nbsp 261 <TR> <TD ALIGN=left>17.6 <TD ALIGN=left COLSPAN=2> Per-Interface Rate Vs. Aggregate Data Rate &nbsp;&nbsp 261 <TR> <TD ALIGN=left>17.7 <TD ALIGN=left COLSPAN=2> Network Processor Speed Vs. Bandwidth &nbsp;&nbsp 261 <TR> <TD ALIGN=left>17.8 <TD ALIGN=left COLSPAN=2> Coprocessor Design: Lookaside Vs. Flow-Through &nbsp;&nbsp 262 <TR> <TD ALIGN=left>17.9 <TD ALIGN=left COLSPAN=2> Pipelining: Uniform Vs. Synchronized &nbsp;&nbsp 262 <TR> <TD ALIGN=left>17.10 <TD ALIGN=left COLSPAN=2> Explicit Parallelism Vs. Cost And Programmability &nbsp;&nbsp 262 <TR> <TD ALIGN=left>17.11 <TD ALIGN=left COLSPAN=2> Parallelism: Scale Vs. Packet Ordering &nbsp;&nbsp 263 <TR> <TD ALIGN=left>17.12 <TD ALIGN=left COLSPAN=2> Parallelism: Speed Vs. Stateful Classification &nbsp;&nbsp 263 <TR> <TD ALIGN=left>17.13 <TD ALIGN=left COLSPAN=2> Memory: Speed Vs. Programmability &nbsp;&nbsp 263 <TR> <TD ALIGN=left>17.14 <TD ALIGN=left COLSPAN=2> I/O Performance Vs. Pin Count &nbsp;&nbsp 264 <TR> <TD ALIGN=left>17.15 <TD ALIGN=left COLSPAN=2> Programming Languages: A Three-Way Tradeoff &nbsp;&nbsp 264 <TR> <TD ALIGN=left>17.16 <TD ALIGN=left COLSPAN=2> Multithreading: Speed Vs. Programmability &nbsp;&nbsp 264 <TR> <TD ALIGN=left>17.17 <TD ALIGN=left COLSPAN=2> Traffic Management Vs. Blind Forwarding At Low Cost &nbsp;&nbsp 265 <TR> <TD ALIGN=left>17.18 <TD ALIGN=left COLSPAN=2> Generality Vs. Specific Architectural Role &nbsp;&nbsp 265 <TR> <TD ALIGN=left>17.19 <TD ALIGN=left COLSPAN=2> Memory Type: Special-Purpose Vs. General-Purpose &nbsp;&nbsp 265 <TR> <TD ALIGN=left>17.20 <TD ALIGN=left COLSPAN=2> Backward Compatibility Vs. Architectural Advances &nbsp;&nbsp 266 <TR> <TD ALIGN=left>17.21 <TD ALIGN=left COLSPAN=2> Parallelism Vs. Pipelining &nbsp;&nbsp 266 <TR> <TD ALIGN=left>17.22 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 267 <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 267<BR> </TABLE> <BR> <BR><H3> PART III &nbsp;&nbsp; Example Network Processor &nbsp;&nbsp; 269</H3> <BR> <H3>Chapter 18 &nbsp; Overview Of The Intel Network Processor &nbsp;&nbsp; 271</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>18.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 271 <TR> <TD ALIGN=left>18.2 <TD ALIGN=left COLSPAN=2> Intel Terminology &nbsp;&nbsp 271 <TR> <TD ALIGN=left>18.3 <TD ALIGN=left COLSPAN=2> IXA: Internet Exchange Architecture &nbsp;&nbsp 272 <TR> <TD ALIGN=left>18.4 <TD ALIGN=left COLSPAN=2> IXP: Internet Exchange Processor &nbsp;&nbsp 272 <TR> <TD ALIGN=left>18.5 <TD ALIGN=left COLSPAN=2> Basic IXP1200 Features &nbsp;&nbsp 273 <TR> <TD ALIGN=left>18.6 <TD ALIGN=left COLSPAN=2> External Connections &nbsp;&nbsp 273 <TR> <TD ALIGN=left> <TD ALIGN=left>18.6.1 <TD ALIGN=left> Serial Line Interface &nbsp;&nbsp 275 <TR> <TD ALIGN=left> <TD ALIGN=left>18.6.2 <TD ALIGN=left> PCI Bus &nbsp;&nbsp 275 <TR> <TD ALIGN=left> <TD ALIGN=left>18.6.3 <TD ALIGN=left> IX Bus &nbsp;&nbsp 275 <TR> <TD ALIGN=left> <TD ALIGN=left>18.6.4 <TD ALIGN=left> SDRAM Bus &nbsp;&nbsp 275 <TR> <TD ALIGN=left> <TD ALIGN=left>18.6.5 <TD ALIGN=left> SRAM Bus &nbsp;&nbsp 276 <TR> <TD ALIGN=left>18.7 <TD ALIGN=left COLSPAN=2> Internal Components &nbsp;&nbsp 276 <TR> <TD ALIGN=left>18.8 <TD ALIGN=left COLSPAN=2> IXP1200 Processor Hierarchy &nbsp;&nbsp 277 <TR> <TD ALIGN=left> <TD ALIGN=left>18.8.1 <TD ALIGN=left> General-Purpose Processor &nbsp;&nbsp 278 <TR> <TD ALIGN=left> <TD ALIGN=left>18.8.2 <TD ALIGN=left> Embedded RISC Processor (StrongARM) &nbsp;&nbsp 278 <TR> <TD ALIGN=left> <TD ALIGN=left>18.8.3 <TD ALIGN=left> I/O Processors (Microengines) &nbsp;&nbsp 278 <TR> <TD ALIGN=left> <TD ALIGN=left>18.8.4 <TD ALIGN=left> Coprocessors And Other Functional Units &nbsp;&nbsp 279 <TR> <TD ALIGN=left> <TD ALIGN=left>18.8.5 <TD ALIGN=left> Physical Interface Processors &nbsp;&nbsp 279 <TR> <TD ALIGN=left>18.9 <TD ALIGN=left COLSPAN=2> IXP1200 Memory Hierarchy &nbsp;&nbsp 279 <TR> <TD ALIGN=left>18.10 <TD ALIGN=left COLSPAN=2> Word And Longword Addressing &nbsp;&nbsp 281 <TR> <TD ALIGN=left>18.11 <TD ALIGN=left COLSPAN=2> An Example Of Underlying Complexity &nbsp;&nbsp 281 <TR> <TD ALIGN=left>18.12 <TD ALIGN=left COLSPAN=2> Other Hardware Facilities &nbsp;&nbsp 283 <TR> <TD ALIGN=left>18.13 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 283 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 283<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 284<BR> </TABLE> <BR> <BR> <H3>Chapter 19 &nbsp; Embedded RISC Processor (StrongARM Core) &nbsp;&nbsp; 287</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>19.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 287 <TR> <TD ALIGN=left>19.2 <TD ALIGN=left COLSPAN=2> Purpose Of An Embedded Processor &nbsp;&nbsp 287 <TR> <TD ALIGN=left>19.3 <TD ALIGN=left COLSPAN=2> StrongARM Architecture &nbsp;&nbsp 289 <TR> <TD ALIGN=left>19.4 <TD ALIGN=left COLSPAN=2> RISC Instruction Set And Registers &nbsp;&nbsp 289 <TR> <TD ALIGN=left>19.5 <TD ALIGN=left COLSPAN=2> StrongARM Memory Architecture &nbsp;&nbsp 290 <TR> <TD ALIGN=left>19.6 <TD ALIGN=left COLSPAN=2> StrongARM Memory Map &nbsp;&nbsp 291 <TR> <TD ALIGN=left>19.7 <TD ALIGN=left COLSPAN=2> Virtual Address Space And Memory Management &nbsp;&nbsp 292 <TR> <TD ALIGN=left>19.8 <TD ALIGN=left COLSPAN=2> Shared Memory And Address Translation &nbsp;&nbsp 292 <TR> <TD ALIGN=left>19.9 <TD ALIGN=left COLSPAN=2> Internal Peripheral Units &nbsp;&nbsp 293 <TR> <TD ALIGN=left> <TD ALIGN=left>19.9.1 <TD ALIGN=left> Serial Connection Through UART Hardware &nbsp;&nbsp 293 <TR> <TD ALIGN=left> <TD ALIGN=left>19.9.2 <TD ALIGN=left> Countdown Timers &nbsp;&nbsp 293 <TR> <TD ALIGN=left> <TD ALIGN=left>19.9.3 <TD ALIGN=left> General-Purpose I/O Pins &nbsp;&nbsp 294 <TR> <TD ALIGN=left> <TD ALIGN=left>19.9.4 <TD ALIGN=left> Real-Time Clock &nbsp;&nbsp 294 <TR> <TD ALIGN=left>19.10 <TD ALIGN=left COLSPAN=2> Other I/O &nbsp;&nbsp 294 <TR> <TD ALIGN=left>19.11 <TD ALIGN=left COLSPAN=2> User And Kernel Mode Operation &nbsp;&nbsp 294 <TR> <TD ALIGN=left>19.12 <TD ALIGN=left COLSPAN=2> Coprocessor 15 &nbsp;&nbsp 295 <TR> <TD ALIGN=left>19.13 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 295 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 295<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 296<BR> </TABLE> <BR> <BR> <H3>Chapter 20 &nbsp; Packet Processor Hardware (Microengines And FBI) &nbsp;&nbsp; 299</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>20.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 299 <TR> <TD ALIGN=left>20.2 <TD ALIGN=left COLSPAN=2> The Purpose Of Microengines &nbsp;&nbsp 299 <TR> <TD ALIGN=left>20.3 <TD ALIGN=left COLSPAN=2> Microengine Architecture &nbsp;&nbsp 300 <TR> <TD ALIGN=left>20.4 <TD ALIGN=left COLSPAN=2> The Concept Of Microsequencing &nbsp;&nbsp 300 <TR> <TD ALIGN=left>20.5 <TD ALIGN=left COLSPAN=2> Microengine Instruction Set &nbsp;&nbsp 301 <TR> <TD ALIGN=left>20.6 <TD ALIGN=left COLSPAN=2> Separate Memory Address Spaces &nbsp;&nbsp 303 <TR> <TD ALIGN=left>20.7 <TD ALIGN=left COLSPAN=2> Instruction Pipeline &nbsp;&nbsp 303 <TR> <TD ALIGN=left>20.8 <TD ALIGN=left COLSPAN=2> The Concept Of Instruction Stalls &nbsp;&nbsp 305 <TR> <TD ALIGN=left>20.9 <TD ALIGN=left COLSPAN=2> Conditional Branching And Pipeline Abort &nbsp;&nbsp 306 <TR> <TD ALIGN=left>20.10 <TD ALIGN=left COLSPAN=2> Memory Access Delay &nbsp;&nbsp 306 <TR> <TD ALIGN=left>20.11 <TD ALIGN=left COLSPAN=2> Hardware Threads And Context Switching &nbsp;&nbsp 307 <TR> <TD ALIGN=left>20.12 <TD ALIGN=left COLSPAN=2> Microengine Instruction Store &nbsp;&nbsp 309 <TR> <TD ALIGN=left>20.13 <TD ALIGN=left COLSPAN=2> Microengine Hardware Registers &nbsp;&nbsp 310 <TR> <TD ALIGN=left>20.14 <TD ALIGN=left COLSPAN=2> General Purpose Registers &nbsp;&nbsp 310 <TR> <TD ALIGN=left> <TD ALIGN=left>20.14.1 <TD ALIGN=left> Context-Relative Vs. Absolute Registers &nbsp;&nbsp 310 <TR> <TD ALIGN=left> <TD ALIGN=left>20.14.2 <TD ALIGN=left> Register Banks &nbsp;&nbsp 310 <TR> <TD ALIGN=left>20.15 <TD ALIGN=left COLSPAN=2> Transfer Registers &nbsp;&nbsp 312 <TR> <TD ALIGN=left>20.16 <TD ALIGN=left COLSPAN=2> Local Control And Status Registers (CSRs) &nbsp;&nbsp 313 <TR> <TD ALIGN=left>20.17 <TD ALIGN=left COLSPAN=2> Inter-Processor Communication &nbsp;&nbsp 313 <TR> <TD ALIGN=left>20.18 <TD ALIGN=left COLSPAN=2> FBI Unit &nbsp;&nbsp 314 <TR> <TD ALIGN=left>20.19 <TD ALIGN=left COLSPAN=2> Transmit And Receive FIFOs &nbsp;&nbsp 315 <TR> <TD ALIGN=left>20.20 <TD ALIGN=left COLSPAN=2> FBI Architecture And Push/Pull Engines &nbsp;&nbsp 315 <TR> <TD ALIGN=left>20.21 <TD ALIGN=left COLSPAN=2> Scratchpad Memory &nbsp;&nbsp 316 <TR> <TD ALIGN=left>20.22 <TD ALIGN=left COLSPAN=2> Hash Unit &nbsp;&nbsp 317 <TR> <TD ALIGN=left>20.23 <TD ALIGN=left COLSPAN=2> Configuration, Control, and Status Registers &nbsp;&nbsp 319 <TR> <TD ALIGN=left>20.24 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 319 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 319<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 320<BR> </TABLE> <BR> <BR> <H3>Chapter 21 &nbsp; Reference System And Software Development Kit (Bridal Veil, SDK) &nbsp;&nbsp; 323</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>21.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 323 <TR> <TD ALIGN=left>21.2 <TD ALIGN=left COLSPAN=2> Reference Systems &nbsp;&nbsp 323 <TR> <TD ALIGN=left>21.3 <TD ALIGN=left COLSPAN=2> The Intel Reference System &nbsp;&nbsp 324 <TR> <TD ALIGN=left> <TD ALIGN=left>21.3.1 <TD ALIGN=left> Intel's Hardware Testbed &nbsp;&nbsp 324 <TR> <TD ALIGN=left> <TD ALIGN=left>21.3.2 <TD ALIGN=left> Intel's Software Development Kit &nbsp;&nbsp 325 <TR> <TD ALIGN=left>21.4 <TD ALIGN=left COLSPAN=2> Host Operating System Choices &nbsp;&nbsp 326 <TR> <TD ALIGN=left>21.5 <TD ALIGN=left COLSPAN=2> Operating System Used On The StrongARM &nbsp;&nbsp 326 <TR> <TD ALIGN=left>21.6 <TD ALIGN=left COLSPAN=2> External File Access And Storage &nbsp;&nbsp 327 <TR> <TD ALIGN=left>21.7 <TD ALIGN=left COLSPAN=2> PCI Ethernet Emulation &nbsp;&nbsp 328 <TR> <TD ALIGN=left>21.8 <TD ALIGN=left COLSPAN=2> Bootstrapping The Reference Hardware &nbsp;&nbsp 328 <TR> <TD ALIGN=left>21.9 <TD ALIGN=left COLSPAN=2> Running Software &nbsp;&nbsp 329 <TR> <TD ALIGN=left>21.10 <TD ALIGN=left COLSPAN=2> System Reboot &nbsp;&nbsp 330 <TR> <TD ALIGN=left>21.11 <TD ALIGN=left COLSPAN=2> Alternative Cross-Development Software &nbsp;&nbsp 330 <TR> <TD ALIGN=left>21.12 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 330 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 331<BR> </TABLE> <BR> <BR> <H3>Chapter 22 &nbsp; Programming Model (ACE) &nbsp;&nbsp; 333</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>22.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 333 <TR> <TD ALIGN=left>22.2 <TD ALIGN=left COLSPAN=2> The ACE Abstraction &nbsp;&nbsp 333 <TR> <TD ALIGN=left>22.3 <TD ALIGN=left COLSPAN=2> ACE Definitions And Terminology &nbsp;&nbsp 334 <TR> <TD ALIGN=left>22.4 <TD ALIGN=left COLSPAN=2> Four Conceptual Parts Of An ACE &nbsp;&nbsp 334 <TR> <TD ALIGN=left>22.5 <TD ALIGN=left COLSPAN=2> Output Targets And Late Binding &nbsp;&nbsp 335 <TR> <TD ALIGN=left>22.6 <TD ALIGN=left COLSPAN=2> An Example Of ACE Interconnection &nbsp;&nbsp 335 <TR> <TD ALIGN=left>22.7 <TD ALIGN=left COLSPAN=2> Division Of An ACE Into Core And Microblocks &nbsp;&nbsp 336 <TR> <TD ALIGN=left>22.8 <TD ALIGN=left COLSPAN=2> Microblock Groups &nbsp;&nbsp 337 <TR> <TD ALIGN=left>22.9 <TD ALIGN=left COLSPAN=2> Replicated Microblock Groups &nbsp;&nbsp 338 <TR> <TD ALIGN=left>22.10 <TD ALIGN=left COLSPAN=2> Microblock Structure &nbsp;&nbsp 338 <TR> <TD ALIGN=left>22.11 <TD ALIGN=left COLSPAN=2> The Dispatch Loop &nbsp;&nbsp 339 <TR> <TD ALIGN=left>22.12 <TD ALIGN=left COLSPAN=2> Dispatch Loop Calling Conventions &nbsp;&nbsp 340 <TR> <TD ALIGN=left>22.13 <TD ALIGN=left COLSPAN=2> Packet Queues &nbsp;&nbsp 341 <TR> <TD ALIGN=left>22.14 <TD ALIGN=left COLSPAN=2> Exceptions &nbsp;&nbsp 342 <TR> <TD ALIGN=left>22.15 <TD ALIGN=left COLSPAN=2> Crosscalls &nbsp;&nbsp 343 <TR> <TD ALIGN=left>22.16 <TD ALIGN=left COLSPAN=2> Application Programs Outside The ACE Model &nbsp;&nbsp 344 <TR> <TD ALIGN=left>22.17 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 344 </TABLE> <BR> <BR> <H3>Chapter 23 &nbsp; ACE Run-Time Structure And StrongARM Facilities &nbsp;&nbsp; 347</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>23.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 347 <TR> <TD ALIGN=left>23.2 <TD ALIGN=left COLSPAN=2> StrongARM Responsibilities &nbsp;&nbsp 347 <TR> <TD ALIGN=left>23.3 <TD ALIGN=left COLSPAN=2> Principle Run-Time Components &nbsp;&nbsp 348 <TR> <TD ALIGN=left>23.4 <TD ALIGN=left COLSPAN=2> Core Components Of ACEs &nbsp;&nbsp 348 <TR> <TD ALIGN=left>23.5 <TD ALIGN=left COLSPAN=2> Object Management Services (OMS) &nbsp;&nbsp 349 <TR> <TD ALIGN=left> <TD ALIGN=left>23.5.1 <TD ALIGN=left> Resolver &nbsp;&nbsp 349 <TR> <TD ALIGN=left> <TD ALIGN=left>23.5.2 <TD ALIGN=left> Name Server &nbsp;&nbsp 350 <TR> <TD ALIGN=left>23.6 <TD ALIGN=left COLSPAN=2> Resource Manager &nbsp;&nbsp 350 <TR> <TD ALIGN=left>23.7 <TD ALIGN=left COLSPAN=2> Operating System Specific Library (OSSL) &nbsp;&nbsp 350 <TR> <TD ALIGN=left>23.8 <TD ALIGN=left COLSPAN=2> Action Services Library &nbsp;&nbsp 351 <TR> <TD ALIGN=left>23.9 <TD ALIGN=left COLSPAN=2> Automated Microengine Assignment &nbsp;&nbsp 351 <TR> <TD ALIGN=left>23.10 <TD ALIGN=left COLSPAN=2> ACE Program Structure &nbsp;&nbsp 352 <TR> <TD ALIGN=left>23.11 <TD ALIGN=left COLSPAN=2> ACE Main Program And Event Loop &nbsp;&nbsp 352 <TR> <TD ALIGN=left>23.12 <TD ALIGN=left COLSPAN=2> ACE Event Loop And Blocking &nbsp;&nbsp 353 <TR> <TD ALIGN=left>23.13 <TD ALIGN=left COLSPAN=2> Asynchronous Programming Paradigm And Callbacks &nbsp;&nbsp 354 <TR> <TD ALIGN=left>23.14 <TD ALIGN=left COLSPAN=2> Asynchronous Execution And Mutual Exclusion &nbsp;&nbsp 356 <TR> <TD ALIGN=left>23.15 <TD ALIGN=left COLSPAN=2> Memory Allocation &nbsp;&nbsp 357 <TR> <TD ALIGN=left>23.16 <TD ALIGN=left COLSPAN=2> Loading And Starting An ACE (ixstart) &nbsp;&nbsp 358 <TR> <TD ALIGN=left>23.17 <TD ALIGN=left COLSPAN=2> ACE Control Block Allocation And Initialization &nbsp;&nbsp 359 <TR> <TD ALIGN=left>23.18 <TD ALIGN=left COLSPAN=2> Crosscalls &nbsp;&nbsp 360 <TR> <TD ALIGN=left>23.19 <TD ALIGN=left COLSPAN=2> Crosscall Declaration Using IDL &nbsp;&nbsp 361 <TR> <TD ALIGN=left>23.20 <TD ALIGN=left COLSPAN=2> Communications Access Point (CAP) &nbsp;&nbsp 362 <TR> <TD ALIGN=left>23.21 <TD ALIGN=left COLSPAN=2> Timer Management &nbsp;&nbsp 362 <TR> <TD ALIGN=left>23.22 <TD ALIGN=left COLSPAN=2> NCL Classification, Actions, And Default &nbsp;&nbsp 364 <TR> <TD ALIGN=left>23.23 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 365 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 366<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 366<BR> </TABLE> <BR> <BR> <H3>Chapter 24 &nbsp; Microengine Programming I &nbsp;&nbsp; 369</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>24.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 369 <TR> <TD ALIGN=left>24.2 <TD ALIGN=left COLSPAN=2> Intel's Microengine Assembler &nbsp;&nbsp 369 <TR> <TD ALIGN=left>24.3 <TD ALIGN=left COLSPAN=2> Microengine Assembly Language Syntax &nbsp;&nbsp 370 <TR> <TD ALIGN=left>24.4 <TD ALIGN=left COLSPAN=2> Example Operand Syntax &nbsp;&nbsp 371 <TR> <TD ALIGN=left>24.5 <TD ALIGN=left COLSPAN=2> Symbolic Register Names And Allocation &nbsp;&nbsp 374 <TR> <TD ALIGN=left>24.6 <TD ALIGN=left COLSPAN=2> Register Types And Syntax &nbsp;&nbsp 375 <TR> <TD ALIGN=left>24.7 <TD ALIGN=left COLSPAN=2> Local Register Scope, Nesting, And Shadowing &nbsp;&nbsp 376 <TR> <TD ALIGN=left>24.8 <TD ALIGN=left COLSPAN=2> Register Assignments And Conflicts &nbsp;&nbsp 377 <TR> <TD ALIGN=left>24.9 <TD ALIGN=left COLSPAN=2> The Macro Preprocessor &nbsp;&nbsp 378 <TR> <TD ALIGN=left>24.10 <TD ALIGN=left COLSPAN=2> Macro Definition &nbsp;&nbsp 378 <TR> <TD ALIGN=left>24.11 <TD ALIGN=left COLSPAN=2> Repeated Generation Of A Code Segment &nbsp;&nbsp 380 <TR> <TD ALIGN=left>24.12 <TD ALIGN=left COLSPAN=2> Structured Programming Directives &nbsp;&nbsp 381 <TR> <TD ALIGN=left>24.13 <TD ALIGN=left COLSPAN=2> Instructions That Can Cause A Context Switch &nbsp;&nbsp 383 <TR> <TD ALIGN=left>24.14 <TD ALIGN=left COLSPAN=2> Indirect Reference &nbsp;&nbsp 384 <TR> <TD ALIGN=left>24.15 <TD ALIGN=left COLSPAN=2> External Transfers &nbsp;&nbsp 385 <TR> <TD ALIGN=left>24.16 <TD ALIGN=left COLSPAN=2> Library Macros And Transfer Register Allocation &nbsp;&nbsp 386 <TR> <TD ALIGN=left>24.17 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 387 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 388<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 388<BR> </TABLE> <BR> <BR> <H3>Chapter 25 &nbsp; Microengine Programming II &nbsp;&nbsp; 391</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>25.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 391 <TR> <TD ALIGN=left>25.2 <TD ALIGN=left COLSPAN=2> Specialized Memory Operations &nbsp;&nbsp 391 <TR> <TD ALIGN=left>25.3 <TD ALIGN=left COLSPAN=2> Buffer Pool Manipulation &nbsp;&nbsp 392 <TR> <TD ALIGN=left>25.4 <TD ALIGN=left COLSPAN=2> Processor Coordination Via Bit Testing &nbsp;&nbsp 392 <TR> <TD ALIGN=left>25.5 <TD ALIGN=left COLSPAN=2> Atomic Memory Increment &nbsp;&nbsp 393 <TR> <TD ALIGN=left>25.6 <TD ALIGN=left COLSPAN=2> Processor Coordination Via Memory Locking &nbsp;&nbsp 394 <TR> <TD ALIGN=left>25.7 <TD ALIGN=left COLSPAN=2> Control And Status Registers &nbsp;&nbsp 395 <TR> <TD ALIGN=left>25.8 <TD ALIGN=left COLSPAN=2> Intel Dispatch Loop Macros &nbsp;&nbsp 397 <TR> <TD ALIGN=left>25.9 <TD ALIGN=left COLSPAN=2> Packet Queues And Selection &nbsp;&nbsp 398 <TR> <TD ALIGN=left>25.10 <TD ALIGN=left COLSPAN=2> Accessing Fields In A Packet Header &nbsp;&nbsp 399 <TR> <TD ALIGN=left>25.11 <TD ALIGN=left COLSPAN=2> Initialization Required For Dispatch Loop Macros &nbsp;&nbsp 401 <TR> <TD ALIGN=left>25.12 <TD ALIGN=left COLSPAN=2> Packet I/O And The Concept Of Mpackets &nbsp;&nbsp 402 <TR> <TD ALIGN=left>25.13 <TD ALIGN=left COLSPAN=2> Packet Input Without Interrupts &nbsp;&nbsp 403 <TR> <TD ALIGN=left>25.14 <TD ALIGN=left COLSPAN=2> Ingress Packet Transfer &nbsp;&nbsp 404 <TR> <TD ALIGN=left>25.15 <TD ALIGN=left COLSPAN=2> Packet Egress &nbsp;&nbsp 404 <TR> <TD ALIGN=left>25.16 <TD ALIGN=left COLSPAN=2> Other I/O Details &nbsp;&nbsp 406 <TR> <TD ALIGN=left>25.17 <TD ALIGN=left COLSPAN=2> Summary &nbsp;&nbsp 407 <TR> <TD><TD ALIGN=left COLSPAN=2> For Further Study &nbsp;&nbsp 407<BR> <TR> <TD><TD ALIGN=left COLSPAN=2> Exercises &nbsp;&nbsp 407<BR> </TABLE> <BR> <BR> <H3>Chapter 26 &nbsp; An Example ACE &nbsp;&nbsp; 407</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>26.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 407 </TABLE> <BR> <BR> <H3>Chapter 27 &nbsp; Intel's Second Generation Processors &nbsp;&nbsp; 409</H3> <TABLE cellspacing=2 cellpadding=0> <TR> <TD ALIGN=left>27.1 <TD ALIGN=left COLSPAN=2> Introduction &nbsp;&nbsp 409 <TR> <TD ALIGN=left>27.2 <TD ALIGN=left COLSPAN=2> Use Of Dual Chips For Higher Data Rates &nbsp;&nbsp 409 <TR> <TD ALIGN=left>27.3 <TD ALIGN=left COLSPAN=2> Physical Interfaces And Multiplexing &nbsp;&nbsp 410 <TR> <TD ALIGN=left>27.4 <TD ALIGN=left COLSPAN=2> External Connections &nbsp;&nbsp 410 </TABLE> <BR> <BR><H3> Appendix 1 &nbsp; Glossary Of Terms And Abbreviations &nbsp;&nbsp; 416</H3> <BR><H3> Bibliography &nbsp;&nbsp;462</H3> <BR><H3> Index &nbsp;&nbsp;410</H3> </UL></UL> </BODY> </BODY>
</DOC>
